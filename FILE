#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.7).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `#!/bin/sh' line above, then type `sh FILE'.
#
lock_dir=_sh09884
# Made on 2016-10-12 10:46 PDT by <karti@nome02.eecs.oregonstate.edu>.
# Source directory was `/nfs/guille/ams/users/karti/ece521/c-code/hw2'.
#
# Existing files will *not* be overwritten, unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#    311 -rw------- Makefile
#   3572 -rw------- main.c
#   1843 -rw------- res.c
#   1864 -rw------- utils.c
#    658 -rw------- res.h
#   1025 -rw------- sparse/Makefile
#    148 -rw------- sparse/mat0
#   1182 -rw------- sparse/mat1
#    560 -rw------- sparse/mat2
#   1080 -rw------- sparse/mat3
#    100 -rw------- sparse/mat5
#   1634 -rw------- sparse/smpl-test.c
#  21591 -rw------- sparse/spAllocate.c
#  32504 -rw------- sparse/spBuild.c
#  20494 -rw------- sparse/spConfig.h
#  34667 -rw------- sparse/spDefs.h
# 257781 -rw------- sparse/spDoc.pdf
#  98805 -rw------- sparse/spFactor.c
#  56802 -rw------- sparse/spFortran.c
#   1474 -rw------- sparse/spLicense
#  12377 -rw------- sparse/spMatrix.h
#  22792 -rw------- sparse/spOutput.c
#   3994 -rw------- sparse/spRevision
#   7999 -rw------- sparse/spSMP.c
#  22041 -rw------- sparse/spSolve.c
#  12073 -rw------- sparse/spSpice3.h
#  38455 -rw------- sparse/spTest.c
#  68909 -rw------- sparse/spUtils.c
#
MD5SUM=${MD5SUM-md5sum}
f=`${MD5SUM} --version | egrep '^md5sum .*(core|text)utils'`
test -n "${f}" && md5check=true || md5check=false
${md5check} || \
  echo 'Note: not verifying md5sums.  Consider installing GNU coreutils.'
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    case `$dir/gettext --version 2>&1 | sed 1q` in
      *GNU*) gettext_dir=$dir ;;
    esac
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null
then if (echo -n test; echo 1,2,3) | grep n >/dev/null
     then shar_n= shar_c='
'
     else shar_n=-n shar_c= ; fi
else shar_n= shar_c='\c' ; fi
f=shar-touch.$$
st1=200112312359.59
st2=123123592001.59
st2tr=123123592001.5 # old SysV 14-char limit
st3=1231235901

if touch -am -t ${st1} ${f} >/dev/null 2>&1 && \
   test ! -f ${st1} && test -f ${f}; then
  shar_touch='touch -am -t $1$2$3$4$5$6.$7 "$8"'

elif touch -am ${st2} ${f} >/dev/null 2>&1 && \
   test ! -f ${st2} && test ! -f ${st2tr} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$1$2.$7 "$8"'

elif touch -am ${st3} ${f} >/dev/null 2>&1 && \
   test ! -f ${st3} && test -f ${f}; then
  shar_touch='touch -am $3$4$5$6$2 "$8"'

else
  shar_touch=:
  echo
  ${echo} 'WARNING: not restoring timestamps.  Consider getting and'
  ${echo} 'installing GNU `touch'\'', distributed in GNU coreutils...'
  echo
fi
rm -f ${st1} ${st2} ${st2tr} ${st3} ${f}
#
if test ! -d ${lock_dir}
then : ; else ${echo} 'lock directory '${lock_dir}' exists'
  exit 1
fi
if mkdir ${lock_dir}
then ${echo} 'x - created lock directory `'${lock_dir}\''.'
else ${echo} 'x - failed to create lock directory `'${lock_dir}\''.'
  exit 1
fi
# ============= Makefile ==============
if test -f 'Makefile' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING Makefile (file already exists)'
else
${echo} 'x - extracting Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
CC = gcc
CFLAGS=	-g
CSRC=	main.c utils.c res.c isrc.c vsrc.c vcvs.c vccs.c ccvs.c cccs.c dio.c
COBJ=	main.o utils.o res.o isrc.o vsrc.o vcvs.o vccs.o ccvs.o cccs.o dio.o
X
X.c.o:	${CSRC}
X	${CC} ${CFLAGS} -c $*.c
myspice: ${COBJ} 
X	${CC} ${CFLAGS} -o myspice ${COBJ} sparse/sparse.a -lm
clean:
X	rm myspice ${COBJ}
SHAR_EOF
  (set 20 05 04 12 10 57 36 'Makefile'; eval "$shar_touch") &&
  chmod 0600 'Makefile'
if test $? -ne 0
then ${echo} 'restore of Makefile failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'Makefile: MD5 check failed'
       ) << \SHAR_EOF
831b23a675b06980825ae112ef219783  Makefile
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'Makefile'` -ne 311 && \
  ${echo} 'restoration warning:  size of Makefile is not 311'
  fi
fi
# ============= main.c ==============
if test -f 'main.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING main.c (file already exists)'
else
${echo} 'x - extracting main.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
#include <stdio.h>
#include "macros.h"
#include "defs.h"
#include "res.h"
#include "isrc.h"
#include "vsrc.h"
#include "vcvs.h"
#include "cccs.h"
#include "vccs.h"
#include "ccvs.h"
#include "dio.h"
#include "sparse/spMatrix.h"
X
int NumNodes = 0;
int NumBranches = 0;
char **NodeArray;
char **BranchArray;
X
main(ac, av)
char **av;
{
X    char *inFile;
X    FILE *fopen(), *fpIn;
X    char buf[MAXLINE];
X    resistor 	*Res[MAXELEM];
X    isource	*Isrc[MAXELEM];
X    vsource	*Vsrc[MAXELEM];
X    vcvs	*Esrc[MAXELEM];
X    cccs	*Fsrc[MAXELEM];
X    vccs	*Gsrc[MAXELEM];
X    ccvs	*Hsrc[MAXELEM];
X    diode    	*Dio[MAXELEM]; 
X    int i = 0;
X    int j = 0;
X    int numRes = 0;
X    int numIsrc = 0;
X    int numVsrc = 0;
X    int numEsrc = 0;
X    int numFsrc = 0;
X    int numGsrc = 0;
X    int numHsrc = 0;
X    int numDio = 0;
X    int numEqns;
X    char *cktMatrix;
X    double *Rhs, *Sol;
X    BOOLEAN foundError();
X    int error;
X
X    switch (ac) {
X        case 2:
X            inFile = av[1];
X            break;
X        default:
X            printf( "\n File Name Required \n");
X            exit(-1);
X    }
X    /* initialization */
X    NodeArray = CALLOC(char *, MAXNODE);
X    BranchArray = CALLOC(char *, MAXBRANCH);
X    for(i = 0; i < MAXNODE; i++) {
X	NodeArray[i] = CALLOC(char, MAXFIELD);
X    }
X    for(i = 0; i < MAXBRANCH; i++ ) {
X	BranchArray[i] = CALLOC(char, MAXFIELD) ;
X    }
X    /* fill in ground node */
X    strcpy(NodeArray[0], (char *)"0");
X
X    
X    fpIn = fopen( inFile, "r" );
X    while (fgets( buf, MAXLINE, fpIn ) != NULL) {
X	if(tolower(buf[0]) == 'r') 
X	{
X	    /* resistor */
X	    numRes++;
X	    makeRes(Res, numRes, buf);
X	} 
X	else if(tolower(buf[0]) == 'i') 
X	{
X	    /* isource */
X	    numIsrc++;
X	    makeIsrc(Isrc, numIsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'v') 
X	{
X	    /* vsource */
X	    numVsrc++;
X	    makeVsrc(Vsrc, numVsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'e') 
X	{
X	    /* vcvs */
X	    numEsrc++;
X	    makeEsrc(Esrc, numEsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'f') 
X	{
X	    /* cccs */
X	    numFsrc++;
X	    makeFsrc(Fsrc, numFsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'g') 
X	{
X	    /* vccs */
X	    numGsrc++;
X	    makeGsrc(Gsrc, numGsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'h') 
X	{
X	    /* ccvs */
X	    numHsrc++;
X	    makeHsrc(Hsrc, numHsrc, buf);
X	}
X	else if(tolower(buf[0]) == 'd') 
X	{
X	    /* diode */
X	numDio++;
X	    makeDio(Dio, numDio, buf);
X	}
X    }
X    fclose( fpIn );
X
X    /* print circuit elements */
X    printRes(Res, numRes);
X    printIsrc(Isrc, numIsrc); 
X    printVsrc(Vsrc, numVsrc); 
X    printEsrc(Esrc, numEsrc); 
X    printFsrc(Fsrc, numFsrc); 
X    printGsrc(Gsrc, numGsrc); 
X    printHsrc(Hsrc, numHsrc); 
X    printDio(Dio, numDio);
X
X    /* setup circuit matrix */
X    numEqns = NumNodes+NumBranches;
X    cktMatrix = spCreate( numEqns, 0, &error );
X    if( error IS spNO_MEMORY ) {
X	printf( "\n: --- NO MEMORY ---" );
X	exit( -1 );
X    }
X    /* Allocate RHS and Solution vectors */
X    Rhs = CALLOC(double, numEqns+1);
X    Sol = CALLOC(double, numEqns+1);
X
X    /* do any preprocessing */
X    setupRes(cktMatrix, Res, numRes);
X
X    /* load circuit matrix */
X    loadRes(cktMatrix, Rhs, Res, numRes);
X
X    /* print circuit matrix */
X    printf("\n");
X    spPrint(cktMatrix, 0, 1, 0);
X
X    /* compute DC solution */
X    /* first Factor the matrix and then Forward/Back solve */
X    error = spFactor( cktMatrix );
X    if( foundError( error ) ) {
X	exit( -1 );
X    }
X    spSolve( cktMatrix, Rhs, Sol );
X
X    /* print solution */
X    printf("Solution\n");
X    for(i = 1; i<= numEqns; i++) {
X	printf("X[%d] = %g\n", i, Sol[i]);
X    }
X
}
SHAR_EOF
  (set 20 05 04 12 14 34 57 'main.c'; eval "$shar_touch") &&
  chmod 0600 'main.c'
if test $? -ne 0
then ${echo} 'restore of main.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'main.c: MD5 check failed'
       ) << \SHAR_EOF
0915ea2c42d0121464f3c4e42fa2db93  main.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'main.c'` -ne 3572 && \
  ${echo} 'restoration warning:  size of main.c is not 3572'
  fi
fi
# ============= res.c ==============
if test -f 'res.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING res.c (file already exists)'
else
${echo} 'x - extracting res.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'res.c' &&
#include "macros.h"
#include "defs.h"
#include "res.h"
#include "sparse/spMatrix.h"
X
void makeRes(Res, numRes, buf)
resistor *Res[];
int numRes;
char *buf;
{
X    resistor *inst;
X    int j, nodeA, nodeB, atoi();
X    char name[MAXFIELD], node[MAXFIELD], num[MAXFIELD];
X    double value, atof();
X
X    j = 0;	
X    j = getNextField(buf, name, j);
X    j = getNextField(buf, node, j);
X    nodeA = getMappedNode(node);
X    j = getNextField(buf, node, j);
X    nodeB = getMappedNode(node);
X    j = getNextField(buf, num, j);
X    value = atof(num);
X
X    inst = CALLOC(resistor, 1);
X    inst->name = (char *)strdup(name);
X    inst->pNode = nodeA;
X    inst->nNode = nodeB;
X    inst->value = value;
X    Res[numRes] = inst;
}
X
void printRes(Res, numRes)
resistor *Res[];
int numRes;
{
X    int i;
X    resistor *inst;
X
X    for(i = 1; i <= numRes; i++) {
X	inst = Res[i];
X	printf("%s\t%s\t%s\t%f\n", inst->name, NodeArray[inst->pNode], NodeArray[inst->nNode], inst->value);
X    }
}
X
void setupRes(Matrix, Res, numRes)
char *Matrix;
resistor *Res[];
int numRes;
{
X    int i, n1, n2;
X    resistor *inst;
X
X    /* do any preprocessing steps here */
X    for(i = 1; i <= numRes; i++) {
X	inst = Res[i];
X	inst->conduct = 1.0/inst->value;
X	n1 = inst->pNode;
X	n2 = inst->nNode;
X	/* setup matrix and pointers */
X	inst->pn1n1 = spGetElement(Matrix, n1, n1);
X	inst->pn1n2 = spGetElement(Matrix, n1, n2);
X	inst->pn2n2 = spGetElement(Matrix, n2, n2);
X	inst->pn2n1 = spGetElement(Matrix, n2, n1);
X    }
}
X
void loadRes(Matrix, Rhs, Res, numRes)
char *Matrix;
double *Rhs;
resistor *Res[];
int numRes;
{
X    int i;
X    resistor *inst;
X    double conduct;
X
X    /* load matrix */
X    for(i = 1; i <= numRes; i++) {
X	inst = Res[i];
X	conduct = inst->conduct;
X	*(inst->pn1n1) += conduct; 
X	*(inst->pn1n2) -= conduct; 
X	*(inst->pn2n2) += conduct; 
X	*(inst->pn2n1) -= conduct; 
X    }
}
SHAR_EOF
  (set 20 05 04 12 10 47 16 'res.c'; eval "$shar_touch") &&
  chmod 0600 'res.c'
if test $? -ne 0
then ${echo} 'restore of res.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'res.c: MD5 check failed'
       ) << \SHAR_EOF
bd7f7b601f26f836145114f28f59e450  res.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'res.c'` -ne 1843 && \
  ${echo} 'restoration warning:  size of res.c is not 1843'
  fi
fi
# ============= utils.c ==============
if test -f 'utils.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING utils.c (file already exists)'
else
${echo} 'x - extracting utils.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'utils.c' &&
X
#include <stdio.h>
#include <strings.h>
#include "macros.h"
#include "defs.h"
#include "sparse/spMatrix.h"
X
int getNextField(input, field, start)
char *input, *field;
int start;
{
X    int i, j;
X    for(i=0; i < MAXFIELD; i++, j++) {
X	field[i] = '\0';
X    }
X    for(i = 0, j = start; i < MAXFIELD; i++, j++) {
X	if (input[j] == ' ' OR input[j] == '\n') break;
X	field[i] = input[j];
X    }
X    /* strip trailing blanks */
X    while( input[j] == ' ') j++;
X    return( j );
}
X
/* map a nodename to an integer */
int getMappedNode(nodeName)
char *nodeName;
{
X    int i;
X    for(i = 0; i <= NumNodes; i++) {
X	if(!strcmp(NodeArray[i], nodeName)) return( i );
X    }
X    /* node doesn't exist in NodeArray - so insert */
X    NumNodes++;
X    strcpy(NodeArray[NumNodes],  nodeName);
X    return(NumNodes);
}
X
/* map a branch name to an integer */
int getMappedBranch(branchName)
char *branchName;
{
X    int i;
X    for(i = 0; i <= NumBranches; i++) {
X	if(!strcmp(BranchArray[i], branchName)) return( i );
X    }
X    /* branch doesn't exist in BranchArray - so insert */
X    NumBranches++;
X    strcpy(BranchArray[NumBranches],  branchName);
X    return(NumBranches);
}
X
BOOLEAN
foundError( error )
int error;
{
X    BOOLEAN matrixError;
X    switch( error ) {
X	case spSMALL_PIVOT:
X	    printf( "\n *****Error in Decomp: SMALL_PIVOT" );
X	    matrixError = TRUE;
X	    break;
X	case spPANIC:
X	    printf( "\n *****Error in Decomp: RANGE" );
X	    matrixError = TRUE;
X	    break;
X	case spSINGULAR:
X	    printf( "\n *****Error in Decomp: SINGULAR" );
X	    matrixError = TRUE;
X	    break;
X	case spZERO_DIAG:
X	    printf( "\n *****Error in Decomp: ZERO PIVOT" );
X	    matrixError = TRUE;
X	    break;
X	case spNO_MEMORY:
X	    printf( "\n *****Error in Decomp: NO_MEMORY" );
X	    matrixError = TRUE;
X	    break;
X	default:
X	    matrixError = FALSE;
X	    break;
X    }
X    return( matrixError );
}
SHAR_EOF
  (set 20 05 04 12 10 59 37 'utils.c'; eval "$shar_touch") &&
  chmod 0600 'utils.c'
if test $? -ne 0
then ${echo} 'restore of utils.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'utils.c: MD5 check failed'
       ) << \SHAR_EOF
3f56461f1d01834c101fd524c764e0f2  utils.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'utils.c'` -ne 1864 && \
  ${echo} 'restoration warning:  size of utils.c is not 1864'
  fi
fi
# ============= res.h ==============
if test -f 'res.h' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING res.h (file already exists)'
else
${echo} 'x - extracting res.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'res.h' &&
/* information used to describe a single instance */
X
typedef struct resistor{
X    char *name;  /* pointer to character string naming this instance */
X    int pNode; /* number of positive node of resistor */
X    int nNode; /* number of negative node of resistor */
X
X    double value;  /* resistance */
X    double conduct;  /* conductance */
X    double *pn1n1;     /*pointer to sparse-matrix location (pNode, pNode)*/
X    double *pn1n2;     /*pointer to sparse-matrix location (pNode, nNode)*/
X    double *pn2n2;     /*pointer to sparse-matrix location (nNode, nNode)*/
X    double *pn2n1;     /*pointer to sparse-matrix location (nNode, pNode)*/
} resistor ;
SHAR_EOF
  (set 20 05 04 12 09 59 45 'res.h'; eval "$shar_touch") &&
  chmod 0600 'res.h'
if test $? -ne 0
then ${echo} 'restore of res.h failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'res.h: MD5 check failed'
       ) << \SHAR_EOF
d28c1575a510adb1aecb480deb27a567  res.h
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'res.h'` -ne 658 && \
  ${echo} 'restoration warning:  size of res.h is not 658'
  fi
fi
# ============= sparse/Makefile ==============
if test ! -d 'sparse'; then
  mkdir 'sparse'
if test $? -eq 0
then ${echo} 'x - created directory `sparse'\''.'
else ${echo} 'x - failed to create directory `sparse'\''.'
  exit 1
fi
fi
if test -f 'sparse/Makefile' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/Makefile (file already exists)'
else
${echo} 'x - extracting sparse/Makefile (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/Makefile' &&
#  Makefile for Sparse1.4
#
#  Ken Kundert
#  kundert@users.sourceforge.net
#
#
#  To run tests ...
#  On Linux machines run: make
#  On Unix machines run: gnumake
X
CFLAGS = -O -std=c89
LINTFLAGS = -lc -lm
SHELL = /bin/sh
CC = gcc
X
HFILES = spConfig.h spDefs.h spMatrix.h
CFILES = spAllocate.c spBuild.c spFactor.c spOutput.c spSolve.c spUtils.c \
X	 spFortran.c
OFILES = spAllocate.o spBuild.o spFactor.o spOutput.o spSolve.o spUtils.o \
X	 spFortran.o
LIBRARY = sparse.a
DESTINATION = sparse
TESTC = spTest.c
TESTO = spTest.o
X
SOURCE = $(HFILES) $(CFILES)
X
$(DESTINATION)	: $(LIBRARY) $(TESTO)
X	$(CC) $(CFLAGS) -o $(DESTINATION) $(TESTO) $(LIBRARY) -lm
X
$(LIBRARY)	: $(OFILES)
X	ar r   $(LIBRARY) $?
X	ranlib $(LIBRARY)
X
lint		:
X	@lint $(LINTFLAGS) $(CFILES) $(TESTC) | grep -v "but never used"
X
clean		:
X	rm -f $(OFILES) $(LIBRARY) $(TESTO) $(DESTINATION) core
X
touch		:
X	touch -c  $(OFILES) $(LIBRARY)
X	ranlib $(LIBRARY)
X
tags		: $(SOURCE) $(TESTC)
X	ctags -t -w $(SOURCE) $(TESTC)
X
$(OFILES)	: $(HFILES)
$(TESTO)	: $(HFILES)
SHAR_EOF
  (set 20 16 10 12 10 43 57 'sparse/Makefile'; eval "$shar_touch") &&
  chmod 0600 'sparse/Makefile'
if test $? -ne 0
then ${echo} 'restore of sparse/Makefile failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/Makefile: MD5 check failed'
       ) << \SHAR_EOF
7028bcae10bafabadb59a1a45d6f5e59  sparse/Makefile
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/Makefile'` -ne 1025 && \
  ${echo} 'restoration warning:  size of sparse/Makefile is not 1025'
  fi
fi
# ============= sparse/mat0 ==============
if test ! -d 'sparse'; then
  mkdir 'sparse'
if test $? -eq 0
then ${echo} 'x - created directory `sparse'\''.'
else ${echo} 'x - failed to create directory `sparse'\''.'
  exit 1
fi
fi
if test -f 'sparse/mat0' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/mat0 (file already exists)'
else
${echo} 'x - extracting sparse/mat0 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/mat0' &&
mat0  --  Simple matrix.
4 real
1 1  2.0
1 2 -1.0
2 1 -1.0
2 2  3.0
2 3 -1.0
3 2 -1.0
3 3  3.0
3 4 -1.0
4 3 -1.0
4 4  3.0
0 0  0.0
34.0
0.0
0.0
0.0
SHAR_EOF
  (set 20 05 04 12 10 08 33 'sparse/mat0'; eval "$shar_touch") &&
  chmod 0600 'sparse/mat0'
if test $? -ne 0
then ${echo} 'restore of sparse/mat0 failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/mat0: MD5 check failed'
       ) << \SHAR_EOF
e902c724bc37bd19771d9ea1a58cce4c  sparse/mat0
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/mat0'` -ne 148 && \
  ${echo} 'restoration warning:  size of sparse/mat0 is not 148'
  fi
fi
# ============= sparse/mat1 ==============
if test -f 'sparse/mat1' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/mat1 (file already exists)'
else
${echo} 'x - extracting sparse/mat1 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/mat1' &&
mat1  --  Typical circuit matrix, somewhat ill-conditioned.
23	real
1 1 0.0201303
1 6 -0.0108325
1 19 -0.00992221
2 2 0.00196826
2 6 -7.00819e-05
2 16 -0.000149258
3 3 0.00233598
3 6 -6.89538e-05
3 13 -3.81701e-05
3 14 -0.000161645
4 4 0.00181074
4 6 -7.11072e-05
5 5 0.00193524
5 6 -8.35603e-05
5 8 -0.000160605
6 1 -1.72443e-05
6 2 -9.41688e-05
6 3 -4.87603e-05
6 4 -9.88527e-05
6 5 -1.01501e-05
6 6 0.0237867
7 7 0.0020023
7 20 -0.002
8 5 -6.08416e-05
8 8 0.000306666
8 11 3.52493e-05
9 9 0.00012008
10 10 0.00200237
10 22 -0.002
11 11 9.74511e-05
12 12 0.000182758
13 3 -0.000458012
13 13 0.00205898
13 21 -0.002
14 3 -4.65368e-05
14 14 0.000305252
14 17 3.7642e-05
15 15 0.00012008
16 2 -0.000156934
16 16 0.00217081
16 23 -0.002
17 17 9.5915e-05
18 18 0.000182758
19 1 -0.00413682
19 19 0.0189592
20 7 -0.002
20 20 10.0037
20 21 -10
21 13 -0.002
21 20 -10
21 21 10.002
22 10 -0.002
22 22 10.0037
22 23 -10
23 16 -0.002
23 22 -10
23 23 10.002
0  0  0.0
-2.57565e-05
-4.48769e-07
-4.13483e-06
-1.01714e-06
-1.37342e-05
2.90276e-07
1.51576e-09
-1.56322e-07
0
5.2198e-08
0
0
-4.63536e-07
1.99061e-06
0
1.95645e-06
0
0
3.74634e-05
6.29115e-06
-4.69183e-06
-3.57397e-06
1.88248e-06
SHAR_EOF
  (set 20 05 04 12 10 08 33 'sparse/mat1'; eval "$shar_touch") &&
  chmod 0600 'sparse/mat1'
if test $? -ne 0
then ${echo} 'restore of sparse/mat1 failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/mat1: MD5 check failed'
       ) << \SHAR_EOF
1270a381de6e5ce471ccfdd392fe4e9c  sparse/mat1
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/mat1'` -ne 1182 && \
  ${echo} 'restoration warning:  size of sparse/mat1 is not 1182'
  fi
fi
# ============= sparse/mat2 ==============
if test -f 'sparse/mat2' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/mat2 (file already exists)'
else
${echo} 'x - extracting sparse/mat2 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/mat2' &&
mat2  --  Typical circuit matrix.
8	real
1 1 0.0010686
1 2 -1.66e-05
1 5 -0.001
1 6 -4.2e-05
2 1 5.9554e-05
2 2 0.000131298
2 6 -9.16434e-05
2 7 0.000148333
3 3 0.00213033
3 5 -0.002
3 7 0.000190213
3 8 -4.2e-05
4 4 0.000275862
4 6 -4.6936e-05
5 1 -0.001
5 3 -0.002
5 5 0.00308858
5 8 0.000666678
6 1 -0.000118154
6 2 -6.68894e-08
6 4 -4.71518e-05
6 6 0.000366644
7 2 -0.000200677
7 3 -1.8e-06
7 7 0.000333767
8 3 -0.000198585
8 5 -7.2e-06
8 8 0.000431315
0 0 0.0
4.03934e-07
-3.044e-07
-1.53475e-05
5.28676e-08
1.5958e-05
-9.9608e-08
-2.13155e-07
4.15313e-09
SHAR_EOF
  (set 20 05 04 12 10 08 33 'sparse/mat2'; eval "$shar_touch") &&
  chmod 0600 'sparse/mat2'
if test $? -ne 0
then ${echo} 'restore of sparse/mat2 failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/mat2: MD5 check failed'
       ) << \SHAR_EOF
efd12c706227c2a2e90b65337aa19e86  sparse/mat2
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/mat2'` -ne 560 && \
  ${echo} 'restoration warning:  size of sparse/mat2 is not 560'
  fi
fi
# ============= sparse/mat3 ==============
if test -f 'sparse/mat3' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/mat3 (file already exists)'
else
${echo} 'x - extracting sparse/mat3 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/mat3' &&
mat3  --  Ill-conditioned matrix.
22	real
1 1 0.0201303
1 6 -0.0108325
1 19 -0.00992221
2 2 0.00196826
2 6 -7.00819e-05
2 16 -0.000149258
3 3 0.00233598
3 6 -6.89538e-05
3 13 -3.81701e-05
3 14 -0.000161645
4 4 0.00181074
4 6 -7.11072e-05
5 5 0.00193524
5 6 -8.35603e-05
5 8 -0.000160605
6 1 -1.72443e-05
6 2 -9.41688e-05
6 3 -4.87603e-05
6 4 -9.88527e-05
6 5 -1.01501e-05
6 6 0.0237867
7 5 -6.08416e-05
7 8 0.000306666
7 11 3.52493e-05
8 9 0.00012008
9 10 0.00200237
9 22 -0.002
10 11 9.74511e-05
11 12 0.000182758
12 3 -0.000458012
12 13 0.00205898
12 21 -0.002
13 3 -4.65368e-05
13 14 0.000305252
13 17 3.7642e-05
14 15 0.00012008
15 2 -0.000156934
15 16 0.00217081
16 17 9.5915e-05
17 18 0.000182758
18 1 -0.00413682
18 19 0.0189592
19 7 -0.002
19 20 10.0037
19 21 -10
20 13 -0.002
20 20 -10
20 21 10.002
21 10 -0.002
21 22 10.0037
22 16 -0.002
22 22 -10
0  0  0.0
-2.57565e-05
-4.48769e-07
-4.13483e-06
-1.01714e-06
-1.37342e-05
2.90276e-07
1.51576e-09
-1.56322e-07
0
5.2198e-08
0
0
-4.63536e-07
1.99061e-06
0
1.95645e-06
0
0
3.74634e-05
6.29115e-06
-4.69183e-06
-3.57397e-06
SHAR_EOF
  (set 20 05 04 12 10 08 33 'sparse/mat3'; eval "$shar_touch") &&
  chmod 0600 'sparse/mat3'
if test $? -ne 0
then ${echo} 'restore of sparse/mat3 failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/mat3: MD5 check failed'
       ) << \SHAR_EOF
e0d4826ba846411eb2d4e687011a2501  sparse/mat3
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/mat3'` -ne 1080 && \
  ${echo} 'restoration warning:  size of sparse/mat3 is not 1080'
  fi
fi
# ============= sparse/mat5 ==============
if test -f 'sparse/mat5' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/mat5 (file already exists)'
else
${echo} 'x - extracting sparse/mat5 (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/mat5' &&
mat5  --  Test of complete pivoting capability.
3	real
1	2	1.0
2	3	1.0
3	1	1.0
0	0	0.0
2.0
3.0
1.0
X
SHAR_EOF
  (set 20 05 04 12 10 08 33 'sparse/mat5'; eval "$shar_touch") &&
  chmod 0600 'sparse/mat5'
if test $? -ne 0
then ${echo} 'restore of sparse/mat5 failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/mat5: MD5 check failed'
       ) << \SHAR_EOF
8a4083ec8ae1f46a0d9218e9351cf000  sparse/mat5
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/mat5'` -ne 100 && \
  ${echo} 'restoration warning:  size of sparse/mat5 is not 100'
  fi
fi
# ============= sparse/smpl-test.c ==============
if test -f 'sparse/smpl-test.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/smpl-test.c (file already exists)'
else
${echo} 'x - extracting sparse/smpl-test.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/smpl-test.c' &&
/*
X * Simple test (and example) for Sparse
X *
X * This test builds a simple ladder network and then performs an AC analysis
X * to compute is transfer characteristics versus frequency.
X * 
X * Assumes Sparse is configured for complex matrices and that
X * spSEPARATED_COMPLEX_VECTORS is NO.
X */
X
#include <stdio.h>
#include <math.h>
#include "spMatrix.h"
X
int
main( int argc, char **argv )
{
spMatrix A;
struct spTemplate Stamp[3];
spError err;
struct complex { double re; double im; } x[3], b[3];
double f, omega;
X
/* Create and build the matrix. */
X    A = spCreate( 2, 1, &err );
X    if (err >= spFATAL) {
X        spErrorMessage( A, stderr, argv[0] );
X	return 1;
X    }
X    spGetAdmittance( A, 1, 0, &Stamp[0] );
X    spGetAdmittance( A, 1, 2, &Stamp[1] );
X    spGetAdmittance( A, 2, 0, &Stamp[2] );
X    if (spErrorState( A ) >= spFATAL) {
X        spErrorMessage( A, stderr, argv[0] );
X	return 1;
X    }
X
/* Drive the circuit at node 1. */
X    b[1].re = 1.0;     b[1].im = 0.0;
X    b[2].re = 0.0;     b[2].im = 0.0;
X
/* Perform AC analysis over a range of frequencies. */
X    for (f = 0.0; f <= 100000.0; f += 1000.0) {
X	omega = 2.0 * M_PI * f; 
X
/* Load the matrix. */
X	spClear( A );
X	spADD_COMPLEX_QUAD( Stamp[0], 1/50.0, 1e-6*omega ); 
X	spADD_REAL_QUAD( Stamp[1], 1/200.0 ); 
X	spADD_COMPLEX_QUAD( Stamp[2], 1/50.0, 1e-6*omega ); 
X
/* Solve the matrix equations Ax = b for x. */
X        err = spFactor( A );
X	if (err >= spFATAL) {
X	    spErrorMessage( A, stderr, argv[0] );
X	    return 1;
X	}
X	spSolve( A, (spREAL *)b, (spREAL *)x );
X	printf( "f = %f, h = %f\n", f, sqrt(x[2].re*x[2].re + x[2].im*x[2].im) );
X    }
X    return 0;
}
X    
X
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/smpl-test.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/smpl-test.c'
if test $? -ne 0
then ${echo} 'restore of sparse/smpl-test.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/smpl-test.c: MD5 check failed'
       ) << \SHAR_EOF
a951634082dc60763c8b6b3328c6fc3d  sparse/smpl-test.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/smpl-test.c'` -ne 1634 && \
  ${echo} 'restoration warning:  size of sparse/smpl-test.c is not 1634'
  fi
fi
# ============= sparse/spAllocate.c ==============
if test -f 'sparse/spAllocate.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spAllocate.c (file already exists)'
else
${echo} 'x - extracting sparse/spAllocate.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spAllocate.c' &&
/*
X *  MATRIX ALLOCATION MODULE
X *
X *  Author:                     Advising professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X */
/*!\file
X *  This file contains functions for allocating and freeing matrices, configuring them, and for
X *  accessing global information about the matrix (size, error status, etc.).
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X * \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spCreate
X *  spDestroy
X *  spErrorState
X *  spWhereSingular
X *  spGetSize
X *  spSetReal
X *  spSetComplex
X *  spFillinCount
X *  spElementCount
X *
X *  >>> Other functions contained in this file:
X *  spcGetElement
X *  InitializeElementBlocks
X *  spcGetFillin
X *  RecordAllocation
X *  AllocateBlockOfAllocationList
X *  EnlargeMatrix
X *  ExpandTranslationArrays
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spAllocate.c,v 1.3 2003/06/29 04:19:52 kundert Exp $";
#endif
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *      Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *      Macros and declarations to be imported by the user.
X *  spDefs.h
X *      Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
X
/*
X * Global strings
X */
X
char spcMatrixIsNotValid[] = "Matrix passed to Sparse is not valid";
char spcErrorsMustBeCleared[] = "Error not cleared";
char spcMatrixMustBeFactored[] = "Matrix must be factored";
char spcMatrixMustNotBeFactored[] = "Matrix must not be factored";
X
X
X
X
/*
X *  Function declarations
X */
X
static spError ReserveElements( MatrixPtr, int );
static void InitializeElementBlocks( MatrixPtr, int, int );
static void RecordAllocation( MatrixPtr, void* );
static void AllocateBlockOfAllocationList( MatrixPtr );
X
X
X
/*!
X *  Allocates and initializes the data structures associated with a matrix.
X *
X *  \return
X *  A pointer to the matrix is returned cast into \a spMatrix (typically a
X *  pointer to a void).  This pointer is then passed and used by the other
X *  matrix routines to refer to a particular matrix.  If an error occurs,
X *  the \a NULL pointer is returned.
X *
X *  \param Size
X *      Size of matrix or estimate of size of matrix if matrix is \a EXPANDABLE.
X *  \param Complex
X *      Type of matrix.  If \a Complex is 0 then the matrix is real, otherwise
X *      the matrix will be complex.  Note that if the routines are not set up
X *      to handle the type of matrix requested, then an \a spPANIC error will occur.
X *      Further note that if a matrix will be both real and complex, it must
X *      be specified here as being complex.
X *  \param pError
X *      Returns error flag, needed because function \a spErrorState() will
X *      not work correctly if \a spCreate() returns \a NULL. Possible errors
X *      include \a  spNO_MEMORY and \a spPANIC.
X */
/*  >>> Local variables:
X *  AllocatedSize  (int)
X *      The size of the matrix being allocated.
X *  Matrix  (MatrixPtr)
X *      A pointer to the matrix frame being created.
X */
X
spMatrix
spCreate(
X    int  Size,
X    int  Complex,
X    spError *pError
)
{
register  unsigned  SizePlusOne;
register  MatrixPtr  Matrix;
register  int  I;
int  AllocatedSize;
X
/* Begin `spCreate'. */
/* Clear error flag. */
X    *pError = spOKAY;
X
/* Test for valid size. */
X    vASSERT( (Size >= 0) AND (Size != 0 OR EXPANDABLE), "Invalid size" );
X
/* Test for valid type. */
#if NOT spCOMPLEX
X    ASSERT( NOT Complex );
#endif
#if NOT REAL
X    ASSERT( Complex );
#endif
X
/* Create Matrix. */
X    AllocatedSize = MAX( Size, MINIMUM_ALLOCATED_SIZE );
X    SizePlusOne = (unsigned)(AllocatedSize + 1);
X
X    if ((Matrix = ALLOC(struct MatrixFrame, 1)) == NULL)
X    {   *pError = spNO_MEMORY;
X        return NULL;
X    }
X
/* Initialize matrix */
X    Matrix->ID = SPARSE_ID;
X    Matrix->Complex = Complex;
X    Matrix->PreviousMatrixWasComplex = Complex;
X    Matrix->Factored = NO;
X    Matrix->Elements = 0;
X    Matrix->Error = *pError;
X    Matrix->Fillins = 0;
X    Matrix->Reordered = NO;
X    Matrix->NeedsOrdering = YES;
X    Matrix->NumberOfInterchangesIsOdd = NO;
X    Matrix->Partitioned = NO;
X    Matrix->RowsLinked = NO;
X    Matrix->InternalVectorsAllocated = NO;
X    Matrix->SingularCol = 0;
X    Matrix->SingularRow = 0;
X    Matrix->Size = Size;
X    Matrix->AllocatedSize = AllocatedSize;
X    Matrix->ExtSize = Size;
X    Matrix->AllocatedExtSize = AllocatedSize;
X    Matrix->CurrentSize = 0;
X    Matrix->ExtToIntColMap = NULL;
X    Matrix->ExtToIntRowMap = NULL;
X    Matrix->IntToExtColMap = NULL;
X    Matrix->IntToExtRowMap = NULL;
X    Matrix->MarkowitzRow = NULL;
X    Matrix->MarkowitzCol = NULL;
X    Matrix->MarkowitzProd = NULL;
X    Matrix->DoCmplxDirect = NULL;
X    Matrix->DoRealDirect = NULL;
X    Matrix->Intermediate = NULL;
X    Matrix->RelThreshold = DEFAULT_THRESHOLD;
X    Matrix->AbsThreshold = 0.0;
X
X    Matrix->TopOfAllocationList = NULL;
X    Matrix->RecordsRemaining = 0;
X    Matrix->ElementsRemaining = 0;
X    Matrix->FillinsRemaining = 0;
X
X    RecordAllocation( Matrix, (void *)Matrix );
X    if (Matrix->Error == spNO_MEMORY) goto MemoryError;
X
/* Take out the trash. */
X    Matrix->TrashCan.Real = 0.0;
#if spCOMPLEX
X    Matrix->TrashCan.Imag = 0.0;
#endif
X    Matrix->TrashCan.Row = 0;
X    Matrix->TrashCan.Col = 0;
X    Matrix->TrashCan.NextInRow = NULL;
X    Matrix->TrashCan.NextInCol = NULL;
#if INITIALIZE
X    Matrix->TrashCan.pInitInfo = NULL;
#endif
X
/* Allocate space in memory for Diag pointer vector. */
X    CALLOC( Matrix->Diag, ElementPtr, SizePlusOne);
X    if (Matrix->Diag == NULL)
X        goto MemoryError;
X
/* Allocate space in memory for FirstInCol pointer vector. */
X    CALLOC( Matrix->FirstInCol, ElementPtr, SizePlusOne);
X    if (Matrix->FirstInCol == NULL)
X        goto MemoryError;
X
/* Allocate space in memory for FirstInRow pointer vector. */
X    CALLOC( Matrix->FirstInRow, ElementPtr, SizePlusOne);
X    if (Matrix->FirstInRow == NULL)
X        goto MemoryError;
X
/* Allocate space in memory for IntToExtColMap vector. */
X    if (( Matrix->IntToExtColMap = ALLOC(int, SizePlusOne)) == NULL)
X        goto MemoryError;
X
/* Allocate space in memory for IntToExtRowMap vector. */
X    if (( Matrix->IntToExtRowMap = ALLOC(int, SizePlusOne)) == NULL)
X        goto MemoryError;
X
/* Initialize MapIntToExt vectors. */
X    for (I = 1; I <= AllocatedSize; I++)
X    {   Matrix->IntToExtRowMap[I] = I;
X        Matrix->IntToExtColMap[I] = I;
X    }
X
#if TRANSLATE
/* Allocate space in memory for ExtToIntColMap vector. */
X    if (( Matrix->ExtToIntColMap = ALLOC(int, SizePlusOne)) == NULL)
X        goto MemoryError;
X
/* Allocate space in memory for ExtToIntRowMap vector. */
X    if (( Matrix->ExtToIntRowMap = ALLOC(int, SizePlusOne)) == NULL)
X        goto MemoryError;
X
/* Initialize MapExtToInt vectors. */
X    for (I = 1; I <= AllocatedSize; I++)
X    {   Matrix->ExtToIntColMap[I] = -1;
X        Matrix->ExtToIntRowMap[I] = -1;
X    }
X    Matrix->ExtToIntColMap[0] = 0;
X    Matrix->ExtToIntRowMap[0] = 0;
#endif
X
/* Allocate space for fill-ins and initial set of elements. */
X    InitializeElementBlocks( Matrix, SPACE_FOR_ELEMENTS*AllocatedSize,
X                                     SPACE_FOR_FILL_INS*AllocatedSize );
X    if (Matrix->Error == spNO_MEMORY)
X        goto MemoryError;
X
X    return (char *)Matrix;
X
MemoryError:
X
/* Deallocate matrix and return no pointer to matrix if there is not enough
X   memory. */
X    *pError = spNO_MEMORY;
X    spDestroy( (char *)Matrix);
X    return NULL;
}
X
X
X
X
X
X
X
X
X
/*
X *  ELEMENT ALLOCATION
X *
X *  This routine allocates space for matrix elements. It requests large blocks
X *  of storage from the system and doles out individual elements as required.
X *  This technique, as opposed to allocating elements individually, tends to
X *  speed the allocation process.
X *
X *  >>> Returned:
X *  A pointer to an element.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *
X *  >>> Local variables:
X *  pElement  (ElementPtr)
X *      A pointer to the first element in the group of elements being allocated.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
ElementPtr
spcGetElement( MatrixPtr Matrix )
{
ElementPtr  pElement;
X
/* Begin `spcGetElement'. */
X
/* Allocate block of MatrixElements if necessary. */
X    if (Matrix->ElementsRemaining == 0)
X    {   pElement = ALLOC(struct MatrixElement, ELEMENTS_PER_ALLOCATION);
X        RecordAllocation( Matrix, (void *)pElement );
X        if (Matrix->Error == spNO_MEMORY) return NULL;
X        Matrix->ElementsRemaining = ELEMENTS_PER_ALLOCATION;
X        Matrix->NextAvailElement = pElement;
X    }
X
/* Update Element counter and return pointer to Element. */
X    Matrix->ElementsRemaining--;
X    return Matrix->NextAvailElement++;
}
X
X
X
X
X
X
X
X
/*
X *  ELEMENT ALLOCATION INITIALIZATION
X *
X *  This routine allocates space for matrix fill-ins and an initial set of
X *  elements.  Besides being faster than allocating space for elements one
X *  at a time, it tends to keep the fill-ins physically close to the other
X *  matrix elements in the computer memory.  This keeps virtual memory paging
X *  to a minimum.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  InitialNumberOfElements  <input> (int)
X *      This number is used as the size of the block of memory, in
X *      MatrixElements, reserved for elements. If more than this number of
X *      elements are generated, then more space is allocated later.
X *  NumberOfFillinsExpected  <input> (int)
X *      This number is used as the size of the block of memory, in
X *      MatrixElements, reserved for fill-ins. If more than this number of
X *      fill-ins are generated, then more space is allocated, but they may
X *      not be physically close in computer's memory.
X *
X *  >>> Local variables:
X *  pElement  (ElementPtr)
X *      A pointer to the first element in the group of elements being allocated.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
static void
InitializeElementBlocks(
X    MatrixPtr Matrix,
X    int InitialNumberOfElements,
X    int NumberOfFillinsExpected
)
{
ElementPtr  pElement;
X
/* Begin `InitializeElementBlocks'. */
X
/* Allocate block of MatrixElements for elements. */
X    pElement = ALLOC(struct MatrixElement, InitialNumberOfElements);
X    RecordAllocation( Matrix, (void *)pElement );
X    if (Matrix->Error == spNO_MEMORY) return;
X    Matrix->ElementsRemaining = InitialNumberOfElements;
X    Matrix->NextAvailElement = pElement;
X
/* Allocate block of MatrixElements for fill-ins. */
X    pElement = ALLOC(struct MatrixElement, NumberOfFillinsExpected);
X    RecordAllocation( Matrix, (void *)pElement );
X    if (Matrix->Error == spNO_MEMORY) return;
X    Matrix->FillinsRemaining = NumberOfFillinsExpected;
X    Matrix->NextAvailFillin = pElement;
X
/* Allocate a fill-in list structure. */
X    Matrix->FirstFillinListNode = ALLOC(struct FillinListNodeStruct,1);
X    RecordAllocation( Matrix, (void *)Matrix->FirstFillinListNode );
X    if (Matrix->Error == spNO_MEMORY) return;
X    Matrix->LastFillinListNode = Matrix->FirstFillinListNode;
X
X    Matrix->FirstFillinListNode->pFillinList = pElement;
X    Matrix->FirstFillinListNode->NumberOfFillinsInList =NumberOfFillinsExpected;
X    Matrix->FirstFillinListNode->Next = NULL;
X
X    return;
}
X
X
X
X
X
X
X
X
X
X
/*
X *  FILL-IN ALLOCATION
X *
X *  This routine allocates space for matrix fill-ins. It requests large blocks
X *  of storage from the system and doles out individual elements as required.
X *  This technique, as opposed to allocating elements individually, tends to
X *  speed the allocation process.
X *
X *  >>> Returned:
X *  A pointer to the fill-in.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
ElementPtr
spcGetFillin( MatrixPtr Matrix )
{
struct FillinListNodeStruct *pListNode;
ElementPtr  pFillins;
X
/* Begin `spcGetFillin'. */
X
#if NOT STRIP OR LINT
X    if (Matrix->FillinsRemaining == 0)
X        return spcGetElement( Matrix );
#endif
#if STRIP OR LINT
X
X    if (Matrix->FillinsRemaining == 0)
X    {   pListNode = Matrix->LastFillinListNode;
X
/* First see if there are any stripped fill-ins left. */
X        if (pListNode->Next != NULL)
X        {   Matrix->LastFillinListNode = pListNode = pListNode->Next;
X            Matrix->FillinsRemaining = pListNode->NumberOfFillinsInList;
X            Matrix->NextAvailFillin = pListNode->pFillinList;
X        }
X        else
X        {
/* Allocate block of fill-ins. */
X            pFillins = ALLOC(struct MatrixElement, ELEMENTS_PER_ALLOCATION);
X            RecordAllocation( Matrix, (void *)pFillins );
X            if (Matrix->Error == spNO_MEMORY) return NULL;
X            Matrix->FillinsRemaining = ELEMENTS_PER_ALLOCATION;
X            Matrix->NextAvailFillin = pFillins;
X
/* Allocate a fill-in list structure. */
X            pListNode->Next = ALLOC(struct FillinListNodeStruct,1);
X            RecordAllocation( Matrix, (void *)pListNode->Next );
X            if (Matrix->Error == spNO_MEMORY) return NULL;
X            Matrix->LastFillinListNode = pListNode = pListNode->Next;
X
X            pListNode->pFillinList = pFillins;
X            pListNode->NumberOfFillinsInList = ELEMENTS_PER_ALLOCATION;
X            pListNode->Next = NULL;
X        }
X    }
#endif
X
/* Update Fill-in counter and return pointer to Fill-in. */
X    Matrix->FillinsRemaining--;
X    return Matrix->NextAvailFillin++;
}
X
X
X
X
X
X
X
X
X
/*
X *  RECORD A MEMORY ALLOCATION
X *
X *  This routine is used to record all memory allocations so that the memory
X *  can be freed later.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  AllocatedPtr  <input>  (void *)
X *      The pointer returned by malloc or calloc.  These pointers are saved in
X *      a list so that they can be easily freed.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
static void
RecordAllocation(
X    MatrixPtr Matrix,
X    void *AllocatedPtr
)
{
/* Begin `RecordAllocation'. */
/*
X * If Allocated pointer is NULL, assume that malloc returned a NULL pointer,
X * which indicates a spNO_MEMORY error.
X */
X    if (AllocatedPtr == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X
/* Allocate block of MatrixElements if necessary. */
X    if (Matrix->RecordsRemaining == 0)
X    {   AllocateBlockOfAllocationList( Matrix );
X        if (Matrix->Error == spNO_MEMORY)
X        {   FREE(AllocatedPtr);
X            return;
X        }
X    }
X
/* Add Allocated pointer to Allocation List. */
X    (++Matrix->TopOfAllocationList)->AllocatedPtr = AllocatedPtr;
X    Matrix->RecordsRemaining--;
X    return;
X
}
X
X
X
X
X
X
X
X
/*
X *  ADD A BLOCK OF SLOTS TO ALLOCATION LIST     
X *
X *  This routine increases the size of the allocation list.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *
X *  >>> Local variables:
X *  ListPtr  (AllocationListPtr)
X *      Pointer to the list that contains the pointers to segments of memory
X *      that were allocated by the operating system for the current matrix.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
static void
AllocateBlockOfAllocationList( MatrixPtr Matrix )
{
register  int  I;
register  AllocationListPtr  ListPtr;
X
/* Begin `AllocateBlockOfAllocationList'. */
/* Allocate block of records for allocation list. */
X    ListPtr = ALLOC(struct AllocationRecord, (ELEMENTS_PER_ALLOCATION+1));
X    if (ListPtr == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X
/* String entries of allocation list into singly linked list.  List is linked
X   such that any record points to the one before it. */
X
X    ListPtr->NextRecord = Matrix->TopOfAllocationList;
X    Matrix->TopOfAllocationList = ListPtr;
X    ListPtr += ELEMENTS_PER_ALLOCATION;
X    for (I = ELEMENTS_PER_ALLOCATION; I > 0; I--)
X    {    ListPtr->NextRecord = ListPtr - 1;
X         ListPtr--;
X    }
X
/* Record allocation of space for allocation list on allocation list. */
X    Matrix->TopOfAllocationList->AllocatedPtr = (void *)ListPtr;
X    Matrix->RecordsRemaining = ELEMENTS_PER_ALLOCATION;
X
X    return;
}
X
X
X
X
X
X
X
X
/*!
X *  Destroys a matrix and frees all memory associated with it.
X *
X *  \param eMatrix
X *      Pointer to the matrix frame which is to be destroyed.
X */
/*  >>> Local variables:
X *  ListPtr  (AllocationListPtr)
X *      Pointer into the linked list of pointers to allocated data structures.
X *      Points to pointer to structure to be freed.
X *  NextListPtr  (AllocationListPtr)
X *      Pointer into the linked list of pointers to allocated data structures.
X *      Points to the next pointer to structure to be freed.  This is needed
X *      because the data structure to be freed could include the current node
X *      in the allocation list.
X */
X
void
spDestroy( spMatrix eMatrix )
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
register  AllocationListPtr  ListPtr, NextListPtr;
X
/* Begin `spDestroy'. */
X    ASSERT_IS_SPARSE( Matrix );
X
/* Deallocate the vectors that are located in the matrix frame. */
X    FREE( Matrix->IntToExtColMap );
X    FREE( Matrix->IntToExtRowMap );
X    FREE( Matrix->ExtToIntColMap );
X    FREE( Matrix->ExtToIntRowMap );
X    FREE( Matrix->Diag );
X    FREE( Matrix->FirstInRow );
X    FREE( Matrix->FirstInCol );
X    FREE( Matrix->MarkowitzRow );
X    FREE( Matrix->MarkowitzCol );
X    FREE( Matrix->MarkowitzProd );
X    FREE( Matrix->DoCmplxDirect );
X    FREE( Matrix->DoRealDirect );
X    FREE( Matrix->Intermediate );
X
/* Sequentially step through the list of allocated pointers freeing pointers
X * along the way. */
X    ListPtr = Matrix->TopOfAllocationList;
X    while (ListPtr != NULL)
X    {   NextListPtr = ListPtr->NextRecord;
X        free( ListPtr->AllocatedPtr );
X        ListPtr = NextListPtr;
X    }
X    return;
}
X
X
X
X
X
X
X
/*!
X *  This function returns the error status of the given matrix.
X *
X *  \return
X *      The error status of the given matrix.
X *
X *  \param eMatrix
X *      The pointer to the matrix for which the error status is desired.
X */
X
spError
spErrorState( spMatrix eMatrix )
{
/* Begin `spErrorState'. */
X
X    if (eMatrix != NULL)
X    {   ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X        return ((MatrixPtr)eMatrix)->Error;
X    }
X    else return spNO_MEMORY;   /* This error may actually be spPANIC,
X                                * no way to tell. */
}
X
X
X
X
X
X
X
X
X
/*!
X *  This function returns the row and column number where the matrix was
X *  detected as singular (if pivoting was allowed on the last factorization)
X *  or where a zero was detected on the diagonal (if pivoting was not
X *  allowed on the last factorization). Pivoting is performed only in
X *  spOrderAndFactor().
X *
X *  \param eMatrix
X *      The matrix for which the error status is desired.
X *  \param pRow
X *      The row number.
X *  \param pCol
X *      The column number.
X */
X
void
spWhereSingular(
X    spMatrix eMatrix,
X    int *pRow,
X    int *pCol
)
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
X
/* Begin `spWhereSingular'. */
X    ASSERT_IS_SPARSE( Matrix );
X
X    if (Matrix->Error == spSINGULAR OR Matrix->Error == spZERO_DIAG)
X    {   *pRow = Matrix->SingularRow;
X        *pCol = Matrix->SingularCol;
X    }
X    else *pRow = *pCol = 0;
X    return;
}
X
X
X
X
X
X
/*!
X *  Returns the size of the matrix.  Either the internal or external size of
X *  the matrix is returned.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param External
X *      If \a External is set true, the external size , i.e., the value of the
X *      largest external row or column number encountered is returned.
X *      Otherwise the true size of the matrix is returned.  These two sizes
X *      may differ if the \a TRANSLATE option is set true.
X */
X
int
spGetSize(
X    spMatrix eMatrix,
X    int External
)
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
X
/* Begin `spGetSize'. */
X    ASSERT_IS_SPARSE( Matrix );
X
#if TRANSLATE
X    if (External)
X        return Matrix->ExtSize;
X    else
X        return Matrix->Size;
#else
X    return Matrix->Size;
#endif
}
X
X
X
X
X
X
X
X
/*!
X *  Forces matrix to be real.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X */
X
void
spSetReal( spMatrix eMatrix )
{
/* Begin `spSetReal'. */
X
X    ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X    vASSERT( REAL, "Sparse not compiled to handle real matrices" );
X    ((MatrixPtr)eMatrix)->Complex = NO;
X    return;
}
X
X
/*!
X *  Forces matrix to be complex.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X */
X
void
spSetComplex( spMatrix eMatrix )
{
/* Begin `spSetComplex'. */
X
X    ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X    vASSERT( spCOMPLEX, "Sparse not compiled to handle complex matrices" );
X    ((MatrixPtr)eMatrix)->Complex = YES;
X    return;
}
X
X
X
X
X
X
X
X
X
/*!
X *  This function returns the number of fill-ins that currently exists in a matrix.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X */
X
int
spFillinCount( spMatrix eMatrix )
{
/* Begin `spFillinCount'. */
X
X    ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X    return ((MatrixPtr)eMatrix)->Fillins;
}
X
X
/*!
X *  This function returns the total number of elements (including fill-ins) that currently exists in a matrix.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X */
X
int
spElementCount( spMatrix eMatrix )
{
/* Begin `spElementCount'. */
X
X    ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X    return ((MatrixPtr)eMatrix)->Elements;
}
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spAllocate.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spAllocate.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spAllocate.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spAllocate.c: MD5 check failed'
       ) << \SHAR_EOF
fdb2efb0c741f961e2a722b4123ca339  sparse/spAllocate.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spAllocate.c'` -ne 21591 && \
  ${echo} 'restoration warning:  size of sparse/spAllocate.c is not 21591'
  fi
fi
# ============= sparse/spBuild.c ==============
if test -f 'sparse/spBuild.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spBuild.c (file already exists)'
else
${echo} 'x - extracting sparse/spBuild.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spBuild.c' &&
/*
X *  MATRIX BUILD MODULE
X *
X *  Author:                     Advising professor:
X *     Kenneth S. Kundert           Alberto Sangiovanni-Vincentelli
X *     UC Berkeley
X */
/*!\file
X *  This file contains the routines associated with clearing, loading and
X *  preprocessing the matrix.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spClear
X *  spFindElement
X *  spGetElement
X *  spGetAdmittance
X *  spGetQuad
X *  spGetOnes
X *  spInstallInitInfo
X *  spGetInitInfo
X *  spInitialize
X *
X *  >>> Other functions contained in this file:
X *  Translate
X *  spcFindDiag
X *  spcCreateElement
X *  spcLinkRows
X *  EnlargeMatrix
X *  ExpandTranslationArrays
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spBuild.c,v 1.3 2003/06/29 04:19:52 kundert Exp $";
#endif
X
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *     Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *     Macros and declarations to be imported by the user.
X *  spDefs.h
X *     Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
X
/*
X *  Function declarations
X */
X
static void Translate( MatrixPtr, int*, int* );
static void EnlargeMatrix( MatrixPtr, int );
static void ExpandTranslationArrays( MatrixPtr, int );
X
X
X
X
X
X
/*!
X *  Sets every element of the matrix to zero and clears the error flag.
X *
X *  \param eMatrix
X *     Pointer to matrix that is to be cleared.
X */
/*  >>> Local variables:
X *  pElement  (ElementPtr)
X *     A pointer to the element being cleared.
X */
X
void
spClear( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement;
register  int  I;
X
/* Begin `spClear'. */
X    ASSERT_IS_SPARSE( Matrix );
X
/* Clear matrix. */
#if spCOMPLEX
X    if (Matrix->PreviousMatrixWasComplex OR Matrix->Complex)
X    {   for (I = Matrix->Size; I > 0; I--)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   pElement->Real = 0.0;
X                pElement->Imag = 0.0;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X    else
#endif
X    {   for (I = Matrix->Size; I > 0; I--)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   pElement->Real = 0.0;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X
/* Empty the trash. */
X    Matrix->TrashCan.Real = 0.0;
#if spCOMPLEX
X    Matrix->TrashCan.Imag = 0.0;
#endif
X
X    Matrix->Error = spOKAY;
X    Matrix->Factored = NO;
X    Matrix->SingularCol = 0;
X    Matrix->SingularRow = 0;
X    Matrix->PreviousMatrixWasComplex = Matrix->Complex;
X    return;
}
X
X
X
X
X
X
X
X
X
X
/*!
X *  This routine is used to find an element given its indices.  It will not
X *  create it if it does not exist.
X *
X *  \return
X *  A pointer to the desired element, or \a NULL if it does not exist.
X *
X *  \param eMatrix
X *	Pointer to matrix.
X *  \param Row
X *      Row index for element.
X *  \param Col
X *      Column index for element.
X *
X *  \see spGetElement()
X */
/*  >>> Local variables:
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X */
X
spElement *
spFindElement(
X    spMatrix eMatrix,
X    int Row,
X    int Col
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register ElementPtr  pElement;
long StartAt, Min = LARGEST_LONG_INTEGER;
#define BorderRight 0	/* Start at left border, move right. */
#define BorderDown  1	/* Start at top border, move down. */
#define DiagRight   2	/* Start at diagonal, move right. */
#define DiagDown    3	/* Start at diagonal, move down. */
X
/* Begin `spFindElement'. */
X    if (Row == Col) return &Matrix->Diag[Row]->Real;
X
/* Determine where to start the search. */
X    if (Matrix->RowsLinked)
X    {   if ((Col >= Row) AND Matrix->Diag[Row])
X	{   Min = Col - Row;
X	    StartAt = DiagRight;
X	}
X	else
X	{   Min = Col;
X	    StartAt = BorderRight;
X	}
X    }
X    if ((Row >= Col) AND Matrix->Diag[Col])
X    {   if (Row - Col < Min)
X	    StartAt = DiagDown;
X    }
X    else if (Row < Min)
X	StartAt = BorderDown;
X    
/* Search column for element. */
X    if ((StartAt == BorderDown) OR (StartAt == DiagDown))
X    {   if (StartAt == BorderDown)
X	    pElement = Matrix->FirstInCol[Col];
X	else
X	    pElement = Matrix->Diag[Col];
X
X	while ((pElement != NULL) AND (pElement->Row < Row))
X            pElement = pElement->NextInCol;
X	if (pElement AND (pElement->Row == Row))
X	    return &pElement->Real;
X	else
X	    return NULL;
X    }
X
/* Search row for element. */
X    if (StartAt == BorderRight)
X	pElement = Matrix->FirstInRow[Row];
X    else
X	pElement = Matrix->Diag[Row];
X
X    while ((pElement != NULL) AND (pElement->Col < Col))
X	pElement = pElement->NextInRow;
X    if (pElement AND (pElement->Col == Col))
X	return &pElement->Real;
X    else
X	return NULL;
}
X
X
X
X
X
X
X
X
X
/*!
X *  Finds element [Row,Col] and returns a pointer to it.  If element is
X *  not found then it is created and spliced into matrix.  This routine
X *  is only to be used after spCreate() and before spMNA_Preorder(),
X *  spFactor() or spOrderAndFactor().  Returns a pointer to the
X *  real portion of an \a spElement.  This pointer is later used by
X *  \a spADD_xxx_ELEMENT to directly access element.
X *
X *  \return
X *  Returns a pointer to the element.  This pointer is then used to directly
X *  access the element during successive builds.
X *
X *  \param eMatrix
X *     Pointer to the matrix that the element is to be added to.
X *  \param Row
X *     Row index for element.  Must be in the range of [0..Size] unless
X *     the options \a EXPANDABLE or \a TRANSLATE are used. Elements placed in
X *     row zero are discarded.  In no case may \a Row be less than zero.
X *  \param Col
X *     Column index for element.  Must be in the range of [0..Size] unless
X *     the options \a EXPANDABLE or \a TRANSLATE are used. Elements placed in
X *     column zero are discarded.  In no case may \a Col be less than zero.
X
X *  \see spFindElement()
X */
/*  >>> Local variables:
X *  pElement  (RealNumber *)
X *     Pointer to the element.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X *  Error is not cleared in this routine.
X */
X
spElement *
spGetElement(
X    spMatrix eMatrix,
X    int Row,
X    int Col
)
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
ElementPtr pElement;
X
/* Begin `spGetElement'. */
X    ASSERT_IS_SPARSE( Matrix );
X    vASSERT( Row >= 0 AND Col >= 0, "Negative row or column number" );
X
X    if ((Row == 0) OR (Col == 0))
X        return &Matrix->TrashCan.Real;
X
#if NOT TRANSLATE
X    vASSERT( NOT Matrix->Reordered,
X	     "Set TRANSLATE to add elements to a reordered matrix" );
#endif
X
#if TRANSLATE
X    Translate( Matrix, &Row, &Col );
X    if (Matrix->Error == spNO_MEMORY) return NULL;
#endif
X
#if NOT TRANSLATE
#if NOT EXPANDABLE
X    vASSERT( (Row <= Matrix->Size) AND (Col <= Matrix->Size),
X	     "Row or column number too large" );
#endif
X
#if EXPANDABLE
/* Re-size Matrix if necessary. */
X    if ((Row > Matrix->Size) OR (Col > Matrix->Size))
X        EnlargeMatrix( Matrix, MAX(Row, Col) );
X    if (Matrix->Error == spNO_MEMORY) return NULL;
#endif
#endif
X
X    if ((Row != Col) OR ((pElement = Matrix->Diag[Row]) == NULL))
X    {   /*
X	 * Element does not exist or does not reside along diagonal.  Search
X	 * for element and if it does not exist, create it.
X	 */
X        pElement = spcCreateElement( Matrix, Row, Col,
X				     &(Matrix->FirstInRow[Row]),
X				     &(Matrix->FirstInCol[Col]), NO );
X    }
/*
X * Cast pointer into a pointer to a RealNumber.  This requires that Real
X * be the first record in the MatrixElement structure.
X */
X    return &pElement->Real;
}
X
X
X
X
X
X
X
#if TRANSLATE
X
/*
X *  TRANSLATE EXTERNAL INDICES TO INTERNAL
X *
X *  Convert internal row and column numbers to internal row and column numbers.
X *  Also updates Ext/Int maps.
X *
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  Row  <input/output>  (int *)
X *     Upon entry Row is either a external row number of an external node
X *     number.  Upon entry, the internal equivalent is supplied.
X *  Col  <input/output>  (int *)
X *     Upon entry Column is either a external column number of an external node
X *     number.  Upon entry, the internal equivalent is supplied.
X *
X *  >>> Local variables:
X *  ExtCol  (int)
X *     Temporary variable used to hold the external column or node number
X *     during the external to internal column number translation.
X *  ExtRow  (int)
X *     Temporary variable used to hold the external row or node number during
X *     the external to internal row number translation.
X *  IntCol  (int)
X *     Temporary variable used to hold the internal column or node number
X *     during the external to internal column number translation.
X *  IntRow  (int)
X *     Temporary variable used to hold the internal row or node number during
X *     the external to internal row number translation.
X */
X
static void
Translate( 
X    MatrixPtr Matrix,
X    int *Row,
X    int *Col
)
{
register int IntRow, IntCol, ExtRow, ExtCol;
X
/* Begin `Translate'. */
X    ExtRow = *Row;
X    ExtCol = *Col;
X
/* Expand translation arrays if necessary. */
X    if ((ExtRow > Matrix->AllocatedExtSize) OR
X        (ExtCol > Matrix->AllocatedExtSize))
X    {
X        ExpandTranslationArrays( Matrix, MAX(ExtRow, ExtCol) );
X        if (Matrix->Error == spNO_MEMORY) return;
X    }
X
/* Set ExtSize if necessary. */
X    if ((ExtRow > Matrix->ExtSize) OR (ExtCol > Matrix->ExtSize))
X        Matrix->ExtSize = MAX(ExtRow, ExtCol);
X
/* Translate external row or node number to internal row or node number. */
X    if ((IntRow = Matrix->ExtToIntRowMap[ExtRow]) == -1)
X    {   Matrix->ExtToIntRowMap[ExtRow] = ++Matrix->CurrentSize;
X        Matrix->ExtToIntColMap[ExtRow] = Matrix->CurrentSize;
X        IntRow = Matrix->CurrentSize;
X
#if NOT EXPANDABLE
X        vASSERT( IntRow <= Matrix->Size, "Matrix size fixed" );
#endif
X
#if EXPANDABLE
/* Re-size Matrix if necessary. */
X        if (IntRow > Matrix->Size)
X            EnlargeMatrix( Matrix, IntRow );
X        if (Matrix->Error == spNO_MEMORY) return;
#endif
X
X        Matrix->IntToExtRowMap[IntRow] = ExtRow;
X        Matrix->IntToExtColMap[IntRow] = ExtRow;
X    }
X
/* Translate external column or node number to internal column or node number.*/
X    if ((IntCol = Matrix->ExtToIntColMap[ExtCol]) == -1)
X    {   Matrix->ExtToIntRowMap[ExtCol] = ++Matrix->CurrentSize;
X        Matrix->ExtToIntColMap[ExtCol] = Matrix->CurrentSize;
X        IntCol = Matrix->CurrentSize;
X
#if NOT EXPANDABLE
X        vASSERT( IntCol <= Matrix->Size, "Matrix size fixed" );
#endif
X
#if EXPANDABLE
/* Re-size Matrix if necessary. */
X        if (IntCol > Matrix->Size)
X            EnlargeMatrix( Matrix, IntCol );
X        if (Matrix->Error == spNO_MEMORY) return;
#endif
X
X        Matrix->IntToExtRowMap[IntCol] = ExtCol;
X        Matrix->IntToExtColMap[IntCol] = ExtCol;
X    }
X
X    *Row = IntRow;
X    *Col = IntCol;
X    return;
}
#endif
X
X
X
X
X
X
#if QUAD_ELEMENT
/*!
X *  Performs same function as spGetElement() except rather than one
X *  element, all four matrix elements for a floating two terminal
X *  admittance component are added. This routine also works if component
X *  is grounded.  Positive elements are placed at [Node1,Node2] and
X *  [Node2,Node1].  This routine is only to be used after spCreate()
X *  and before spMNA_Preorder(), spFactor() or spOrderAndFactor().
X *
X *  \return
X *  Error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix
X *     Pointer to the matrix that component is to be entered in.
X *  \param Node1
X *     Row and column indices for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Node zero is the
X *     ground node.  In no case may \a Node1 be less than zero.
X *  \param Node2
X *     Row and column indices for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Node zero is the
X *     ground node.  In no case may \a Node2 be less than zero.
X *  \param Template
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
spError
spGetAdmittance(
X    spMatrix Matrix,
X    int Node1,
X    int Node2,
X    struct spTemplate *Template
)
{
X
/* Begin `spGetAdmittance'. */
X    Template->Element1 = spGetElement(Matrix, Node1, Node1 );
X    Template->Element2 = spGetElement(Matrix, Node2, Node2 );
X    Template->Element3Negated = spGetElement( Matrix, Node2, Node1 );
X    Template->Element4Negated = spGetElement( Matrix, Node1, Node2 );
X    if
X    (   (Template->Element1 == NULL)
X        OR (Template->Element2 == NULL)
X        OR (Template->Element3Negated == NULL)
X        OR (Template->Element4Negated == NULL)
X    )   return spNO_MEMORY;
X
X    if (Node1 == 0)
X        SWAP( RealNumber*, Template->Element1, Template->Element2 );
X
X    return spOKAY;
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
X
X
#if QUAD_ELEMENT
/*!
X *  Similar to spGetAdmittance(), except that spGetAdmittance() only
X *  handles 2-terminal components, whereas spGetQuad() handles simple
X *  4-terminals as well.  These 4-terminals are simply generalized
X *  2-terminals with the option of having the sense terminals different
X *  from the source and sink terminals.  spGetQuad() adds four
X *  elements to the matrix.  Positive elements occur at [Row1,Col1]
X *  [Row2,Col2] while negative elements occur at [Row1,Col2] and [Row2,Col1].
X *  The routine works fine if any of the rows and columns are zero.
X *  This routine is only to be used after spCreate() and before
X *  spMNA_Preorder(), spFactor() or spOrderAndFactor()
X *  unless \a TRANSLATE is set true.
X *
X *  \return
X *  Error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix
X *     Pointer to the matrix that component is to be entered in.
X *  \param Row1
X *     First row index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may Row1 be less than zero.
X *  \param Row2
X *     Second row index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may Row2 be less than zero.
X *  \param Col1
X *     First column index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground column.  In no case may Col1 be less than zero.
X *  \param Col2
X *     Second column index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground column.  In no case may Col2 be less than zero.
X *  \param Template
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
spError
spGetQuad(
X    spMatrix Matrix,
X    int Row1,
X    int Row2,
X    int Col1,
X    int Col2,
X    struct  spTemplate  *Template
)
{
/* Begin `spGetQuad'. */
X    Template->Element1 = spGetElement( Matrix, Row1, Col1);
X    Template->Element2 = spGetElement( Matrix, Row2, Col2 );
X    Template->Element3Negated = spGetElement( Matrix, Row2, Col1 );
X    Template->Element4Negated = spGetElement( Matrix, Row1, Col2 );
X    if
X    (   (Template->Element1 == NULL)
X        OR (Template->Element2 == NULL)
X        OR (Template->Element3Negated == NULL)
X        OR (Template->Element4Negated == NULL)
X    )   return spNO_MEMORY;
X
X    if (Template->Element1 == &((MatrixPtr)Matrix)->TrashCan.Real)
X        SWAP( RealNumber *, Template->Element1, Template->Element2 );
X
X    return spOKAY;
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
X
X
#if QUAD_ELEMENT
/*!
X *  Addition of four structural ones to matrix by index.
X *  Performs similar function to spGetQuad() except this routine is
X *  meant for components that do not have an admittance representation.
X *
X *  The following stamp is used: \code
X *         Pos  Neg  Eqn
X *  Pos  [  .    .    1  ]
X *  Neg  [  .    .   -1  ]
X *  Eqn  [  1   -1    .  ]
X *  \endcode
X *
X *  \return
X *  Error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix
X *     Pointer to the matrix that component is to be entered in.
X *  \param Pos
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Pos be less than zero.
X *  \param Neg
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Neg be less than zero.
X *  \param Eqn
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Eqn be less than zero.
X *  \param Template
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
spError
spGetOnes(
X    spMatrix Matrix,
X    int Pos,
X    int Neg,
X    int Eqn,
X    struct spTemplate *Template
)
{
/* Begin `spGetOnes'. */
X    Template->Element4Negated = spGetElement( Matrix, Neg, Eqn );
X    Template->Element3Negated = spGetElement( Matrix, Eqn, Neg );
X    Template->Element2 = spGetElement( Matrix, Pos, Eqn );
X    Template->Element1 = spGetElement( Matrix, Eqn, Pos );
X    if
X    (   (Template->Element1 == NULL)
X        OR (Template->Element2 == NULL)
X        OR (Template->Element3Negated == NULL)
X        OR (Template->Element4Negated == NULL)
X    )   return spNO_MEMORY;
X
X    spADD_REAL_QUAD( *Template, 1.0 );
X    return spOKAY;
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
/*
X *  FIND DIAGONAL
X *
X *  This routine is used to find a diagonal element.  It will not
X *  create it if it does not exist.
X *
X *  >>> Returned:
X *  A pointer to the desired element, or NULL if it does not exist.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *	Pointer to matrix.
X *  Index  <input>  (int)
X *      Row, Col index for diagonal element.
X *
X *  >>> Local variables:
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X */
X
ElementPtr
spcFindDiag(
X    MatrixPtr Matrix,
X    register int Index
)
{
register ElementPtr  pElement;
X
/* Begin `spcFindDiag'. */
X    pElement = Matrix->FirstInCol[Index];
X
/* Search column for element. */
X    while ((pElement != NULL) AND (pElement->Row < Index))
X	pElement = pElement->NextInCol;
X    if (pElement AND (pElement->Row == Index))
X	return pElement;
X    else
X	return NULL;
}
X
X
X
X
X
X
X
X
/*
X *  CREATE AND SPLICE ELEMENT INTO MATRIX
X *
X *  This routine is used to create new matrix elements and splice them into the
X *  matrix.
X *
X *  >>> Returned:
X *  A pointer to the element that was created is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *	Pointer to matrix.
X *  Row  <input>  (int)
X *      Row index for element.
X *  Col  <input>  (int)
X *      Column index for element.
X *  ppToLeft  <input-output>  (ElementPtr *)
X *      This contains the address of the pointer to an element to the left
X *	of the one being created.  It is used to speed the search and if it
X *	is immediately to the left, it is updated with address of the
X *	created element.
X *  ppAbove  <input-output> (ElementPtr *)
X *      This contains the address of the pointer to an element above the
X *      one being created.  It is used to speed the search and it if it
X *	is immediatley above, it is updated with address of the created
X *	element.
X *  Fillin  <input>  (BOOLEAN)
X *      Flag that indicates if created element is to be a fill-in.
X *
X *  >>> Local variables:
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  pCreatedElement  (ElementPtr)
X *      Pointer to the desired element, the one that was just created.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
ElementPtr
spcCreateElement(
X    MatrixPtr Matrix,
X    int Row,
X    register int Col,
X    register ElementPtr *ppToLeft,
X    register ElementPtr *ppAbove,
X    BOOLEAN Fillin
)
{
register ElementPtr  pElement, pCreatedElement;
X
/* Begin `spcCreateElement'. */
X
/* Find element immediately above the desired element. */
X    pElement = *ppAbove;
X    while ((pElement != NULL) AND (pElement->Row < Row))
X    {   ppAbove = &pElement->NextInCol;
X	pElement = *ppAbove;
X    }
X    if ((pElement != NULL) AND (pElement->Row == Row))
X	return pElement;
X
/* The desired element does not exist, create it. */
X    if (Fillin)
X    {   pCreatedElement = spcGetFillin( Matrix );
X	Matrix->Fillins++;
X
/* Update Markowitz counts and products. */
X	++Matrix->MarkowitzRow[Row];
X	spcMarkoProd( Matrix->MarkowitzProd[Row],
X		      Matrix->MarkowitzRow[Row],
X		      Matrix->MarkowitzCol[Row] );
X	if ((Matrix->MarkowitzRow[Row] == 1) AND
X	    (Matrix->MarkowitzCol[Row] != 0))
X	{
X	    Matrix->Singletons--;
X	}
X	++Matrix->MarkowitzCol[Col];
X	spcMarkoProd( Matrix->MarkowitzProd[Col],
X		      Matrix->MarkowitzCol[Col],
X		      Matrix->MarkowitzRow[Col] );
X	if ((Matrix->MarkowitzRow[Col] != 0) AND
X	    (Matrix->MarkowitzCol[Col] == 1))
X	{
X	    Matrix->Singletons--;
X	}
X    }
X    else
X    {   pCreatedElement = spcGetElement( Matrix );
X	Matrix->NeedsOrdering = YES;
X    }
X    if (pCreatedElement == NULL) return NULL;
X    Matrix->Elements++;
X
/* Initialize Element. */
X    pCreatedElement->Row = Row;
X    pCreatedElement->Col = Col;
X    pCreatedElement->Real = 0.0;
#if spCOMPLEX
X    pCreatedElement->Imag = 0.0;
#endif
#if INITIALIZE
X    pCreatedElement->pInitInfo = NULL;
#endif
X
/* If element is on diagonal, store pointer in Diag. */
X    if (Row == Col) Matrix->Diag[Row] = pCreatedElement;
X
/* Splice element into column. */
X    pCreatedElement->NextInCol = *ppAbove;
X    *ppAbove = pCreatedElement;
X
/* Find Element immediately to the left of the fill-in. */
X    if (Matrix->RowsLinked)
X    {   pElement = *ppToLeft;
X	while (pElement != NULL)
X	{   if (pElement->Col < Col)
X	    {   ppToLeft = &pElement->NextInRow;
X		pElement = *ppToLeft;
X	    }
X	    else break; /* while loop */
X	}
X
/* Splice element into row. */
X	pCreatedElement->NextInRow = *ppToLeft;
X	*ppToLeft = pCreatedElement;
X    }
X    return pCreatedElement;
}
X
X
X
X
X
X
X
X
/*
X *
X *  LINK ROWS
X *
X *  This routine is used to generate the row links.  The spGetElement()
X *  routines do not create row links, which are needed by the spFactor()
X *  routines.
X *
X *  >>>  Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *
X *  >>> Local variables:
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  FirstInRowEntry  (ElementPtr *)
X *      A pointer into the FirstInRow array.  Points to the FirstInRow entry
X *      currently being operated upon.
X *  FirstInRowArray  (ArrayOfElementPtrs)
X *      A pointer to the FirstInRow array.  Same as Matrix->FirstInRow but
X *      resides in a register and requires less indirection so is faster to
X *      use.
X *  Col  (int)
X *      Column currently being operated upon.
X */
X
void
spcLinkRows( MatrixPtr Matrix )
{
register  ElementPtr  pElement, *FirstInRowEntry;
register  ArrayOfElementPtrs  FirstInRowArray;
register  int  Col;
X
/* Begin `spcLinkRows'. */
X    FirstInRowArray = Matrix->FirstInRow;
X    for (Col = Matrix->Size; Col >= 1; Col--)
X	FirstInRowArray[Col] = NULL;
X
X    for (Col = Matrix->Size; Col >= 1; Col--)
X    {
/* Generate row links for the elements in the Col'th column. */
X        pElement = Matrix->FirstInCol[Col];
X
X        while (pElement != NULL)
X        {   pElement->Col = Col;
X            FirstInRowEntry = &FirstInRowArray[pElement->Row];
X            pElement->NextInRow = *FirstInRowEntry;
X            *FirstInRowEntry = pElement;
X            pElement = pElement->NextInCol;
X        }
X    }
X    Matrix->RowsLinked = YES;
X    return;
}
X
X
X
X
X
X
X
X
/*
X *  ENLARGE MATRIX
X *
X *  Increases the size of the matrix.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  NewSize  <input>  (int)
X *     The new size of the matrix.
X *
X *  >>> Local variables:
X *  OldAllocatedSize  (int)
X *     The allocated size of the matrix before it is expanded.
X */
X
static void
EnlargeMatrix(
X    MatrixPtr Matrix,
X    register int NewSize
)
{
register int I, OldAllocatedSize = Matrix->AllocatedSize;
X
/* Begin `EnlargeMatrix'. */
X    Matrix->Size = NewSize;
X
X    if (NewSize <= OldAllocatedSize)
X        return;
X
/* Expand the matrix frame. */
X    NewSize = MAX( NewSize, (int)(EXPANSION_FACTOR * OldAllocatedSize) );
X    Matrix->AllocatedSize = NewSize;
X
X    if (( REALLOC(Matrix->IntToExtColMap, int, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    if (( REALLOC(Matrix->IntToExtRowMap, int, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    if (( REALLOC(Matrix->Diag, ElementPtr, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    if (( REALLOC(Matrix->FirstInCol, ElementPtr, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    if (( REALLOC(Matrix->FirstInRow, ElementPtr, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X
/*
X * Destroy the Markowitz and Intermediate vectors, they will be recreated
X * in spOrderAndFactor().
X */
X    FREE( Matrix->MarkowitzRow );
X    FREE( Matrix->MarkowitzCol );
X    FREE( Matrix->MarkowitzProd );
X    FREE( Matrix->DoRealDirect );
X    FREE( Matrix->DoCmplxDirect );
X    FREE( Matrix->Intermediate );
X    Matrix->InternalVectorsAllocated = NO;
X
/* Initialize the new portion of the vectors. */
X    for (I = OldAllocatedSize+1; I <= NewSize; I++)
X    {   Matrix->IntToExtColMap[I] = I;
X        Matrix->IntToExtRowMap[I] = I;
X        Matrix->Diag[I] = NULL;
X        Matrix->FirstInRow[I] = NULL;
X        Matrix->FirstInCol[I] = NULL;
X    }
X
X    return;
}
X
X
X
X
X
X
X
X
#if TRANSLATE
X
/*
X *  EXPAND TRANSLATION ARRAYS
X *
X *  Increases the size arrays that are used to translate external to internal
X *  row and column numbers.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  NewSize  <input>  (int)
X *     The new size of the translation arrays.
X *
X *  >>> Local variables:
X *  OldAllocatedSize  (int)
X *     The allocated size of the translation arrays before being expanded.
X */
X
static void
ExpandTranslationArrays(
X    MatrixPtr Matrix,
X    register int NewSize
)
{
register int I, OldAllocatedSize = Matrix->AllocatedExtSize;
X
/* Begin `ExpandTranslationArrays'. */
X    Matrix->ExtSize = NewSize;
X
X    if (NewSize <= OldAllocatedSize)
X        return;
X
/* Expand the translation arrays ExtToIntRowMap and ExtToIntColMap. */
X    NewSize = MAX( NewSize, (int)(EXPANSION_FACTOR * OldAllocatedSize) );
X    Matrix->AllocatedExtSize = NewSize;
X
X    if (( REALLOC(Matrix->ExtToIntRowMap, int, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    if (( REALLOC(Matrix->ExtToIntColMap, int, NewSize+1)) == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X
/* Initialize the new portion of the vectors. */
X    for (I = OldAllocatedSize+1; I <= NewSize; I++)
X    {   Matrix->ExtToIntRowMap[I] = -1;
X        Matrix->ExtToIntColMap[I] = -1;
X    }
X
X    return;
}
#endif
X
X
X
X
X
X
X
X
X
#if INITIALIZE
/*!
X *   Initialize the matrix.
X *
X *   With the \a INITIALIZE compiler option (see spConfig.h) set true,
X *   Sparse allows the user to keep initialization information with each
X *   structurally nonzero matrix element.  Each element has a pointer
X *   that is set and used by the user.  The user can set this pointer
X *   using spInstallInitInfo() and may be read using spGetInitInfo().  Both
X *   may be used only after the element exists.  The function
X *   spInitialize() is a user customizable way to initialize the matrix.
X *   Passed to this routine is a function pointer.  spInitialize() sweeps
X *   through every element in the matrix and checks the \a pInitInfo
X *   pointer (the user supplied pointer).  If the \a pInitInfo is \a NULL,
X *   which is true unless the user changes it (almost always true for
X *   fill-ins), then the element is zeroed.  Otherwise, the function
X *   pointer is called and passed the \a pInitInfo pointer as well as the
X *   element pointer and the external row and column numbers.  If the
X *   user sets the value of each element, then spInitialize() replaces
X *   spClear().
X *
X *   The user function is expected to return a nonzero integer if there
X *   is a fatal error and zero otherwise.  Upon encountering a nonzero
X *   return code, spInitialize() terminates, sets the error state of
X *   the matrix to be \a spMANGLED, and returns the error code.
X *
X *   \return
X *	Returns the return value of the \a pInit() function.
X *   \param eMatrix
X *      Pointer to matrix.
X *   \param pInit
X *      Pointer to a function that initializes an element.
X
X *   \see spClear()
X */
X
int
spInitialize(
X    spMatrix eMatrix,
X    int (*pInit)(
X	spElement *pElement,
X	spGenericPtr pInitInfo,
X	int Row,
X	int Col
X    )
)
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
register ElementPtr pElement;
int J, Error, Col;
X
/* Begin `spInitialize'. */
X    ASSERT_IS_SPARSE( Matrix );
X
#if spCOMPLEX
/* Clear imaginary part of matrix if matrix is real but was complex. */
X    if (Matrix->PreviousMatrixWasComplex AND NOT Matrix->Complex)
X    {   for (J = Matrix->Size; J > 0; J--)
X        {   pElement = Matrix->FirstInCol[J];
X            while (pElement != NULL)
X            {   pElement->Imag = 0.0;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
#endif /* spCOMPLEX */
X
/* Initialize the matrix. */
X    for (J = Matrix->Size; J > 0; J--)
X    {   pElement = Matrix->FirstInCol[J];
X        Col = Matrix->IntToExtColMap[J];
X        while (pElement != NULL)
X        {   if (pElement->pInitInfo == NULL)
X            {   pElement->Real = 0.0;
#               if spCOMPLEX
X                    pElement->Imag = 0.0;
#               endif
X            }
X            else
X            {   Error = (*pInit)((RealNumber *)pElement, pElement->pInitInfo,
X                                 Matrix->IntToExtRowMap[pElement->Row], Col);
X                if (Error)
X                {   Matrix->Error = spMANGLED;
X                    return Error;
X                }
X
X            }
X            pElement = pElement->NextInCol;
X        }
X    }
X
/* Empty the trash. */
X    Matrix->TrashCan.Real = 0.0;
#if spCOMPLEX
X    Matrix->TrashCan.Imag = 0.0;
#endif
X
X    Matrix->Error = spOKAY;
X    Matrix->Factored = NO;
X    Matrix->SingularCol = 0;
X    Matrix->SingularRow = 0;
X    Matrix->PreviousMatrixWasComplex = Matrix->Complex;
X    return 0;
}
X
X
X
X
/*!
X *   This function installs a pointer to a data structure that is used
X *   to contain initialization information to a matrix element. It is
X *   is then used by spInitialize() to initialize the matrix.
X *
X *   \param pElement
X *       Pointer to matrix element.
X *   \param pInitInfo
X *       Pointer to the data structure that will contain initialiation
X *       information.
X *   \see spInitialize()
X */
X
void
spInstallInitInfo(
X    spElement *pElement,
X    spGenericPtr pInitInfo
)
{
/* Begin `spInstallInitInfo'. */
X    vASSERT( pElement != NULL, "Invalid element pointer" );
X
X    ((ElementPtr)pElement)->pInitInfo = pInitInfo;
}
X
X
/*!
X *   This function returns a pointer to a data structure that is used
X *   to contain initialization information to a matrix element. 
X *
X *   \return
X *       The pointer to the initialiation information data structure
X *       that is associated with a particular matrix element.
X *
X *   \param pElement
X *       Pointer to the matrix element.
X *
X *   \see spInitialize()
X */
spGenericPtr
spGetInitInfo(
X    spElement *pElement
)
{
/* Begin `spGetInitInfo'. */
X    vASSERT( pElement != NULL, "Invalid element pointer" );
X
X    return (spGenericPtr)((ElementPtr)pElement)->pInitInfo;
}
#endif /* INITIALIZE */
SHAR_EOF
  (set 20 16 10 12 10 44 29 'sparse/spBuild.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spBuild.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spBuild.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spBuild.c: MD5 check failed'
       ) << \SHAR_EOF
52e89651613f1f96d78e8ca19733608d  sparse/spBuild.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spBuild.c'` -ne 32504 && \
  ${echo} 'restoration warning:  size of sparse/spBuild.c is not 32504'
  fi
fi
# ============= sparse/spConfig.h ==============
if test -f 'sparse/spConfig.h' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spConfig.h (file already exists)'
else
${echo} 'x - extracting sparse/spConfig.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spConfig.h' &&
/* CONFIGURATION MACRO DEFINITIONS for sparse matrix routines */
/*!
X *  \file
X *
X *  This file contains macros for the sparse matrix routines that are used
X *  to define the personality of the routines.  The user is expected to
X *  modify this file to maximize the performance of the routines with
X *  his/her matrices.
X *
X *  Macros are distinguished by using solely capital letters in their
X *  identifiers.  This contrasts with C defined identifiers which are
X *  strictly lower case, and program variable and procedure names which use
X *  both upper and lower case.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X *
X *  $Date: 2003/06/30 19:41:29 $
X *  $Revision: 1.5 $
X */
X
X
#ifndef spCONFIG_DEFS
#define spCONFIG_DEFS
X
X
X
X
#ifdef spINSIDE_SPARSE
/*
X *  OPTIONS
X *
X *  These are compiler options.  Set each option to one to compile that
X *  section of the code.  If a feature is not desired, set the macro
X *  to NO.
X */
X
/* Begin options. */
X
/* Arithmetic Precision
X *
X * The precision of the arithmetic used by Sparse can be set by
X * changing changing the spREAL macro.  This macro is
X * contained in the file spMatrix.h.  It is strongly suggested to
X * used double precision with circuit simulators.  Note that
X * because C always performs arithmetic operations in double
X * precision, the only benefit to using single precision is that
X * less storage is required.  There is often a noticeable speed
X * penalty when using single precision.  Sparse internally refers
X * to a spREAL as a RealNumber.
X */
X
/*!
X * This specifies that the routines are expected to handle real
X * systems of equations.  The routines can be compiled to handle
X * both real and complex systems at the same time, but there is a
X * slight speed and memory advantage if the routines are complied
X * to handle only real systems of equations.
X */
#define  REAL                           YES
X
/*!
X * Setting this compiler flag true (1) makes the matrix
X * expandable before it has been factored.  If the matrix is
X * expandable, then if an element is added that would be
X * considered out of bounds in the current matrix, the size of
X * the matrix is increased to hold that element.  As a result,
X * the size of the matrix need not be known before the matrix is
X * built.  The matrix can be allocated with size zero and expanded.
X */
#define  EXPANDABLE                     YES
X
/*!
X * This option allows the set of external row and column numbers
X * to be non-packed.  In other words, the row and column numbers
X * do not have to be contiguous.  The priced paid for this
X * flexibility is that when \a TRANSLATE is set true, the time
X * required to initially build the matrix will be greater because
X * the external row and column number must be translated into
X * internal equivalents.  This translation brings about other
X * benefits though.  First, the spGetElement() and
X * spGetAdmittance() routines may be used after the matrix has
X * been factored.  Further, elements, and even rows and columns,
X * may be added to the matrix, and row and columns may be deleted
X * from the matrix, after it has been factored.  Note that when
X * the set of row and column number is not a packed set, neither
X * are the \a RHS and \a Solution vectors.  Thus the size of these
X * vectors must be at least as large as the external size, which
X * is the value of the largest given row or column numbers.
X */
#define  TRANSLATE                      YES
X
/*!
X * Causes the spInitialize(), spGetInitInfo(), and
X * spInstallInitInfo() routines to be compiled.  These routines
X * allow the user to store and read one pointer in each nonzero
X * element in the matrix.  spInitialize() then calls a user
X * specified function for each structural nonzero in the matrix,
X * and includes this pointer as well as the external row and
X * column numbers as arguments.  This allows the user to write
X * custom matrix initialization routines.
X */
#define  INITIALIZE                     YES
X
/*!
X * Many matrices, and in particular node- and modified-node
X * admittance matrices, tend to be nearly symmetric and nearly
X * diagonally dominant.  For these matrices, it is a good idea to
X * select pivots from the diagonal.  With this option enabled,
X * this is exactly what happens, though if no satisfactory pivot
X * can be found on the diagonal, an off-diagonal pivot will be
X * used.  If this option is disabled, Sparse does not
X * preferentially search the diagonal.  Because of this, Sparse
X * has a wider variety of pivot candidates available, and so
X * presumably fewer fill-ins will be created.  However, the
X * initial pivot selection process will take considerably longer.
X * If working with node admittance matrices, or other matrices
X * with a strong diagonal, it is probably best to use
X * \a DIAGONAL_PIVOTING for two reasons.  First, accuracy will be
X * better because pivots will be chosen from the large diagonal
X * elements, thus reducing the chance of growth.  Second, a near
X * optimal ordering will be chosen quickly.  If the class of
X * matrices you are working with does not have a strong diagonal,
X * do not use \a DIAGONAL_PIVOTING, but consider using a larger
X * threshold.  When \a DIAGONAL_PIVOTING is turned off, the following
X * options and constants are not used: \a MODIFIED_MARKOWITZ,
X * \a MAX_MARKOWITZ_TIES, and \a TIES_MULTIPLIER.
X */
#define  DIAGONAL_PIVOTING              YES
X
/*!
X * This determines whether arrays start at an index of zero or one.
X * This option is necessitated by the fact that standard C
X * convention dictates that arrays begin with an index of zero but
X * the standard mathematic convention states that arrays begin with
X * an index of one.  So if you prefer to start your arrays with
X * zero, or your calling Sparse from FORTRAN, set ARRAY_OFFSET to
X * NO or 0.  Otherwise, set ARRAY_OFFSET to YES or 1.  Note that if
X * you use an offset of one, the arrays that you pass to Sparse
X * must have an allocated length of one plus the size of the
X * matrix.  ARRAY_OFFSET must be either 0 or 1, no other offsets
X * are valid.
X */
#define  ARRAY_OFFSET                   NOT FORTRAN
X
/*!
X * This specifies that the modified Markowitz method of pivot
X * selection is to be used.  The modified Markowitz method differs
X * from standard Markowitz in two ways.  First, under modified
X * Markowitz, the search for a pivot can be terminated early if a
X * adequate (in terms of sparsity) pivot candidate is found.
X * Thus, when using modified Markowitz, the initial factorization
X * can be faster, but at the expense of a suboptimal pivoting
X * order that may slow subsequent factorizations.  The second
X * difference is in the way modified Markowitz breaks Markowitz
X * ties.  When two or more elements are pivot candidates and they
X * all have the same Markowitz product, then the tie is broken by
X * choosing the element that is best numerically.  The numerically
X * best element is the one with the largest ratio of its magnitude
X * to the magnitude of the largest element in the same column,
X * excluding itself.  The modified Markowitz method results in
X * marginally better accuracy.  This option is most appropriate
X * for use when working with very large matrices where the initial
X * factor time represents an unacceptable burden. \a NO is recommended.
X */
#define  MODIFIED_MARKOWITZ             NO
X
/*!
X * This specifies that the spDeleteRowAndCol() routine
X * should be compiled.  Note that for this routine to be
X * compiled, both \a DELETE and \a TRANSLATE should be set true.
X */
#define  DELETE                         YES
X
/*!
X * This specifies that the spStripFills() routine should be compiled.
X */
#define  STRIP                          YES
X
/*!
X * This specifies that the routine that preorders modified node
X * admittance matrices should be compiled.  This routine results
X * in greater speed and accuracy if used with this type of
X * matrix.
X */
#define  MODIFIED_NODAL                 YES
X
/*!
X * This specifies that the routines that allow four related
X * elements to be entered into the matrix at once should be
X * compiled.  These elements are usually related to an
X * admittance.  The routines affected by \a QUAD_ELEMENT are the
X * spGetAdmittance(), spGetQuad() and spGetOnes() routines.
X */
#define  QUAD_ELEMENT                   YES
X
/*!
X * This specifies that the routines that solve the matrix as if
X * it was transposed should be compiled.  These routines are
X * useful when performing sensitivity analysis using the adjoint
X * method.
X */
#define  TRANSPOSE                      YES
X
/*!
X * This specifies that the routine that performs scaling on the
X * matrix should be complied.  Scaling is not strongly
X * supported.  The routine to scale the matrix is provided, but
X * no routines are provided to scale and descale the RHS and
X * Solution vectors.  It is suggested that if scaling is desired,
X * it only be preformed when the pivot order is being chosen [in
X * spOrderAndFactor()].  This is the only time scaling has
X * an effect.  The scaling may then either be removed from the
X * solution by the user or the scaled factors may simply be
X * thrown away. \a NO is recommended.
X */
#define  SCALING                        YES
X
/*!
X * This specifies that routines that are used to document the
X * matrix, such as spPrint() and spFileMatrix(), should be
X * compiled.
X */
#define  DOCUMENTATION                  YES
X
/*!
X * This specifies that routines that are used to multily the
X * matrix by a vector, such as spMultiply() and spMultTransposed(), should be
X * compiled.
X */
#define  MULTIPLICATION                 YES
X
/*!
X * This specifies that the routine spDeterminant() should be complied.
X */
#define  DETERMINANT                    YES
X
/*!
X * This specifies that spLargestElement() and spRoundoff() should
X * be compiled.  These routines are used to check the stability (and
X * hence the quality of the pivoting) of the factorization by
X * computing a bound on the size of the element is the matrix
X * \f$ E = A - LU \f$.  If this bound is very high after applying
X * spOrderAndFactor(), then the pivot threshold should be raised.
X * If the bound increases greatly after using spFactor(), then the
X * matrix should probably be reordered. Recomend \a NO.
X */
#define  STABILITY                      YES
X
/*!
X * This specifies that spCondition() and spNorm(), the code that
X * computes a good estimate of the condition number of the matrix,
X * should be compiled. Recomend \a NO.
X */
#define  CONDITION                      YES
X
/*!
X * This specifies that spPseudoCondition(), the code that computes
X * a crude and easily fooled indicator of ill-conditioning in the
X * matrix, should be compiled. Recomend \a NO.
X */
#define  PSEUDOCONDITION                YES
X
/*!
X * This specifies that the \a FORTRAN interface routines should be
X * compiled.  When interfacing to \a FORTRAN programs, the \a ARRAY_OFFSET
X * options should be set to NO.
X */
#define  FORTRAN                        NO
X
/*!
X * This specifies that additional error checking will be compiled.
X * The type of error checked are those that are common when the
X * matrix routines are first integrated into a user's program.  Once
X * the routines have been integrated in and are running smoothly, this
X * option should be turned off. \a YES is recommended.
X */
#define  DEBUG                          YES
X
#endif /* spINSIDE_SPARSE */
X
/*
X *  The following options affect Sparse exports and so are exported as a
X *  side effect.  For this reason they use the `sp' prefix.  The boolean
X *  constants YES an NO are not defined in spMatrix.h to avoid conflicts
X *  with user code, so use 0 for NO and 1 for YES.
X */
X
/*!
X * This specifies that the routines will be complied to handle
X * complex systems of equations.
X */
#define  spCOMPLEX                      1
X
/*!
X * This specifies the format for complex vectors.  If this is set
X * false then a complex vector is made up of one double sized
X * array of RealNumber's in which the real and imaginary numbers
X * are placed alternately in the array.  In other
X * words, the first entry would be Complex[1].Real, then comes
X * Complex[1].Imag, then Complex[2].Real, etc.  If
X * \a spSEPARATED_COMPLEX_VECTORS is set true, then each complex
X * vector is represented by two arrays of \a spREALs, one with
X * the real terms, the other with the imaginary. \a NO is recommended.
X */
#define  spSEPARATED_COMPLEX_VECTORS    0
X
#ifdef spINSIDE_SPARSE
X
X
X
X
X
X
X
/*
X *  MATRIX CONSTANTS
X *
X *  These constants are used throughout the sparse matrix routines.  They
X *  should be set to suit the type of matrix being solved.
X */
X
/* Begin constants. */
X
/*!
X * The relative threshold used if the user enters an invalid
X * threshold.  Also the threshold used by spFactor() when
X * calling spOrderAndFactor().  The default threshold should
X * not be less than or equal to zero nor larger than one.
X * 0.001 is recommended.
X */
#define  DEFAULT_THRESHOLD              1.0e-3
X
/*!
X * This indicates whether spOrderAndFactor() should use diagonal
X * pivoting as default.  This issue only arises when
X * spOrderAndFactor() is called from spFactor(). \a YES is recommended.
X */
#define  DIAG_PIVOTING_AS_DEFAULT       YES
X
/*!
X * This number multiplied by the size of the matrix equals the number
X * of elements for which memory is initially allocated in spCreate().
X * 6 is recommended.
X */
#define  SPACE_FOR_ELEMENTS             6
X
/*!
X * This number multiplied by the size of the matrix equals the number
X * of elements for which memory is initially allocated and specifically
X * reserved for fill-ins in spCreate(). 4 is recommended.
X */
#define  SPACE_FOR_FILL_INS             4
X
/*!
X * The number of matrix elements requested from the malloc utility on
X * each call to it.  Setting this value greater than 1 reduces the
X * amount of overhead spent in this system call. On a virtual memory
X * machine, its good to allocate slightly less than a page worth of
X * elements at a time (or some multiple thereof).
X * 31 is recommended.
X */
#define  ELEMENTS_PER_ALLOCATION        31
X
/*!
X * The minimum allocated size of a matrix.  Note that this does not
X * limit the minimum size of a matrix.  This just prevents having to
X * resize a matrix many times if the matrix is expandable, large and
X * allocated with an estimated size of zero.  This number should not
X * be less than one.
X */
#define  MINIMUM_ALLOCATED_SIZE         6
X
/*!
X * The amount the allocated size of the matrix is increased when it
X * is expanded.
X */
#define  EXPANSION_FACTOR               1.5
X
/*!
X * Some terminology should be defined.  The Markowitz row count is the number
X * of non-zero elements in a row excluding the one being considered as pivot.
X * There is one Markowitz row count for every row.  The Markowitz column
X * is defined similarly for columns.  The Markowitz product for an element
X * is the product of its row and column counts. It is a measure of how much
X * work would be required on the next step of the factorization if that
X * element were chosen to be pivot.  A small Markowitz product is desirable.
X *
X * This number is used for two slightly different things, both of which
X * relate to the search for the best pivot.  First, it is the maximum
X * number of elements that are Markowitz tied that will be sifted
X * through when trying to find the one that is numerically the best.
X * Second, it creates an upper bound on how large a Markowitz product
X * can be before it eliminates the possibility of early termination
X * of the pivot search.  In other words, if the product of the smallest
X * Markowitz product yet found and \a TIES_MULTIPLIER is greater than
X * \a MAX_MARKOWITZ_TIES, then no early termination takes place.
X * Set \a MAX_MARKOWITZ_TIES to some small value if no early termination of
X * the pivot search is desired. An array of RealNumbers is allocated
X * of size \a MAX_MARKOWITZ_TIES so it must be positive and shouldn't
X * be too large.  Active when MODIFIED_MARKOWITZ is 1 (YES).
X * 100 is recommended.
X * \see TIES_MULTIPLIER
X */
#define  MAX_MARKOWITZ_TIES             100
X
/*!
X * Specifies the number of Markowitz ties that are allowed to occur
X * before the search for the pivot is terminated early.  Set to some
X * large value if no early termination of the pivot search is desired.
X * This number is multiplied times the Markowitz product to determine
X * how many ties are required for early termination.  This means that
X * more elements will be searched before early termination if a large
X * number of fill-ins could be created by accepting what is currently
X * considered the best choice for the pivot.  Active when
X * \a MODIFIED_MARKOWITZ is 1 (YES).  Setting this number to zero
X * effectively eliminates all pivoting, which should be avoided.
X * This number must be positive.  \a TIES_MULTIPLIER is also used when
X * diagonal pivoting breaks down. 5 is recommended.
X * \see MAX_MARKOWITZ_TIES
X */
#define  TIES_MULTIPLIER                5
X
/*!
X * Which partition mode is used by spPartition() as default.
X * Possibilities include \a spDIRECT_PARTITION (each row used direct
X * addressing, best for a few relatively dense matrices),
X * \a spINDIRECT_PARTITION (each row used indirect addressing, best
X * for a few very sparse matrices), and \a spAUTO_PARTITION (direct or
X * indirect addressing is chosen on a row-by-row basis, carries a large
X * overhead, but speeds up both dense and sparse matrices, best if there
X * is a large number of matrices that can use the same ordering.
X */
#define  DEFAULT_PARTITION              spAUTO_PARTITION
X
/*!
X * The number of characters per page width.  Set to 80 for terminal,
X * 132 for line printer. Controls how many columns printed by
X * spPrint() per page width.
X */
#define  PRINTER_WIDTH  80
X
X
X
X
X
X
X
X
X
X
#endif /* spINSIDE_SPARSE */
/*
X * PORTABILITY MACROS
X */
X
#ifdef __STDC__
#   define spcCONCAT(prefix,suffix)        prefix ## suffix
#   define spcQUOTE(x)                     # x
#   define spcFUNC_NEEDS_FILE(func,file)   \
X		func ## _requires_ ## file ## _to_be_included_
#else
#   define spcCONCAT(prefix,suffix)        prefix/**/suffix
#   define spcQUOTE(x)                     "x"
#   define spcFUNC_NEEDS_FILE(func,file)   \
X		func/**/_requires_/**/file/**/_to_be_included_
#endif
X
#if defined(__cplusplus) || defined(c_plusplus)
X    /*
X     * Definitions for C++
X     */
#   define spcEXTERN		extern "C"
#   define spcNO_ARGS
#   define spcCONST		const
X    typedef void *spGenericPtr;
#else
#ifdef __STDC__
X    /*
X     * Definitions for ANSI C
X     */
#   define spcEXTERN		extern
#   define spcNO_ARGS		void
#   define spcCONST		const
X    typedef void *spGenericPtr;
#   else
X    /*
X     * Definitions for K&R C -- ignore function prototypes
X     */
#   define spcEXTERN		extern
#   define spcNO_ARGS
#   define spcCONST
X    typedef char *spGenericPtr;
#endif
#endif
X
#ifdef spINSIDE_SPARSE
X
X
X
X
X
X
X
/*
X *  MACHINE CONSTANTS
X *
X *  These numbers must be updated when the program is ported to a new machine.
X */
X
/* Begin machine constants. */
#include <limits.h>
#include <float.h>
X
/*! The resolution of spREAL. */
#define  MACHINE_RESOLUTION      DBL_EPSILON
X
/*! The largest possible value of spREAL. */
#define  LARGEST_REAL            DBL_MAX
X
/*! The smalles possible positive value of spREAL. */
#define  SMALLEST_REAL           DBL_MIN
X
/*! The largest possible value of shorts. */
#define  LARGEST_SHORT_INTEGER   SHRT_MAX
X
/*! The largest possible value of longs. */
#define  LARGEST_LONG_INTEGER    LONG_MAX
X
X
X
X
X
X
/* ANNOTATION */
/*!
X * This macro changes the amount of annotation produced by the matrix
X * routines.  The annotation is used as a debugging aid.  Change the number
X * associated with \a ANNOTATE to change the amount of annotation produced by
X * the program. Possible values include \a NONE, \a ON_STRANGE_BEHAVIOR, and
X * \a FULL. \a NONE is recommended.
X */
#define  ANNOTATE               NONE
X
/*!
X * A possible value for \a ANNOTATE. Disables all annotation.
X */
#define  NONE                   0
X
/*!
X * A possible value for \a ANNOTATE. Causes annotation to be produce
X * upon unusual occurances only.
X */
#define  ON_STRANGE_BEHAVIOR    1
X
/*!
X * A possible value for \a ANNOTATE. Enables full annotation.
X */
#define  FULL                   2
X
#endif /* spINSIDE_SPARSE */
#endif /* spCONFIG_DEFS */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spConfig.h'; eval "$shar_touch") &&
  chmod 0600 'sparse/spConfig.h'
if test $? -ne 0
then ${echo} 'restore of sparse/spConfig.h failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spConfig.h: MD5 check failed'
       ) << \SHAR_EOF
6d3a958b3b6d12db4938a5d61837e099  sparse/spConfig.h
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spConfig.h'` -ne 20494 && \
  ${echo} 'restoration warning:  size of sparse/spConfig.h is not 20494'
  fi
fi
# ============= sparse/spDefs.h ==============
if test -f 'sparse/spDefs.h' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spDefs.h (file already exists)'
else
${echo} 'x - extracting sparse/spDefs.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spDefs.h' &&
/*
X *  DATA STRUCTURE AND MACRO DEFINITIONS for Sparse.
X *
X *  Author:                     Advising professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X *
X *  This file contains common type definitions and macros for the sparse
X *  matrix routines.  These definitions are of no interest to the user.
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X *
X *  $Date: 2003/06/29 04:19:52 $
X *  $Revision: 1.2 $
X */
X
X
X
X
/*
X *  If running lint, change some of the compiler options to get a more
X *  complete inspection.
X */
X
#ifdef lint
#undef  REAL
#undef  spCOMPLEX
#undef  EXPANDABLE
#undef  TRANSLATE
#undef  INITIALIZE
#undef  DELETE
#undef  STRIP
#undef  MODIFIED_NODAL
#undef  QUAD_ELEMENT
#undef  TRANSPOSE
#undef  SCALING
#undef  DOCUMENTATION
#undef  MULTIPLICATION
#undef  DETERMINANT
#undef  CONDITION
#undef  PSEUDOCONDITION
#undef  FORTRAN
#undef  DEBUG
X
#define  REAL                           YES
#define  spCOMPLEX                      YES
#define  EXPANDABLE                     YES
#define  TRANSLATE                      YES
#define  INITIALIZE                     YES
#define  DELETE                         YES
#define  STRIP                          YES
#define  MODIFIED_NODAL                 YES
#define  QUAD_ELEMENT                   YES
#define  TRANSPOSE                      YES
#define  SCALING                        YES
#define  DOCUMENTATION                  YES
#define  MULTIPLICATION                 YES
#define  DETERMINANT                    YES
#define  CONDITION                      YES
#define  PSEUDOCONDITION                YES
#define  FORTRAN                        YES
#define  DEBUG                          YES
X
#define  LINT                           YES
#else /* not lint */
#define  LINT                           NO
#endif /* not lint */
X
X
X
X
X
X
X
/*
X *   MACRO DEFINITIONS
X *
X *   Macros are distinguished by using solely capital letters in their
X *   identifiers.  This contrasts with C defined identifiers which are strictly
X *   lower case, and program variable and procedure names which use both upper
X *   and lower case.
X */
X
/* Begin macros. */
X
/* Boolean data type */
#define  BOOLEAN        int
#define  NO             0
#define  YES            1
#define  NOT            !
#define  AND            &&
#define  OR             ||
X
/* NULL pointer */
#ifndef  NULL
#define  NULL           0
#endif
X
/* Define macros for validating matrix. */
#define  SPARSE_ID			0xDeadBeef	/* Arbitrary. */
#define  IS_SPARSE(matrix)		(((matrix) != NULL) AND \
X                                	 ((matrix)->ID == SPARSE_ID))
#define  NO_ERRORS(matrix)		(((matrix)->Error >= spOKAY) AND \
X				 	 ((matrix)->Error < spFATAL))
#define  IS_FACTORED(matrix)    	((matrix)->Factored AND \
X					 NOT (matrix)->NeedsOrdering)
X
#define  ASSERT_IS_SPARSE(matrix)	vASSERT( IS_SPARSE(matrix), \
X					 spcMatrixIsNotValid )
#define  ASSERT_NO_ERRORS(matrix)	vASSERT( NO_ERRORS(matrix), \
X					 spcErrorsMustBeCleared )
#define  ASSERT_IS_FACTORED(matrix)	vASSERT( IS_FACTORED(matrix), \
X					 spcMatrixMustBeFactored )
#define  ASSERT_IS_NOT_FACTORED(matrix)	vASSERT( NOT (matrix)->Factored, \
X					 spcMatrixMustNotBeFactored )
X
/* Macro commands */
/* Macro functions that return the maximum or minimum independent of type. */
#define  MAX(a,b)           ((a) > (b) ? (a) : (b))
#define  MIN(a,b)           ((a) < (b) ? (a) : (b))
X
/* Macro function that returns the absolute value of a floating point number. */
#define  ABS(a)             ((a) < 0 ? -(a) : (a))
X
/* Macro function that returns the square of a number. */
#define  SQR(a)             ((a)*(a))
X
/* Macro procedure that swaps two entities. */
#define  SWAP(type, a, b)   {type swapx; swapx = a; a = b; b = swapx;}
X
X
/*
X * COMPLEX OPERATION MACROS
X */
X
/* Macro function that returns the approx absolute value of a complex number. */
#if spCOMPLEX
#define  ELEMENT_MAG(ptr)   (ABS((ptr)->Real) + ABS((ptr)->Imag))
#else
#define  ELEMENT_MAG(ptr)   ((ptr)->Real < 0.0 ? -(ptr)->Real : (ptr)->Real)
#endif
X
/* Complex assignment statements. */
#define  CMPLX_ASSIGN(to,from)  \
{   (to).Real = (from).Real;    \
X    (to).Imag = (from).Imag;    \
}
#define  CMPLX_CONJ_ASSIGN(to,from)     \
{   (to).Real = (from).Real;            \
X    (to).Imag = -(from).Imag;           \
}
#define  CMPLX_NEGATE_ASSIGN(to,from)   \
{   (to).Real = -(from).Real;           \
X    (to).Imag = -(from).Imag;           \
}
#define  CMPLX_CONJ_NEGATE_ASSIGN(to,from)      \
{   (to).Real = -(from).Real;                   \
X    (to).Imag = (from).Imag;                    \
}
#define  CMPLX_CONJ(a)  (a).Imag = -(a).Imag
#define  CMPLX_NEGATE(a)        \
{   (a).Real = -(a).Real;       \
X    (a).Imag = -(a).Imag;       \
}
X
/* Macro that returns the approx magnitude (L-1 norm) of a complex number. */
#define  CMPLX_1_NORM(a)        (ABS((a).Real) + ABS((a).Imag))
X
/* Macro that returns the approx magnitude (L-infinity norm) of a complex. */
#define  CMPLX_INF_NORM(a)      (MAX (ABS((a).Real),ABS((a).Imag)))
X
/* Macro function that returns the magnitude (L-2 norm) of a complex number. */
#define  CMPLX_2_NORM(a)        (sqrt((a).Real*(a).Real + (a).Imag*(a).Imag))
X
/* Macro function that performs complex addition. */
#define  CMPLX_ADD(to,from_a,from_b)            \
{   (to).Real = (from_a).Real + (from_b).Real;  \
X    (to).Imag = (from_a).Imag + (from_b).Imag;  \
}
X
/* Macro function that performs complex subtraction. */
#define  CMPLX_SUBT(to,from_a,from_b)           \
{   (to).Real = (from_a).Real - (from_b).Real;  \
X    (to).Imag = (from_a).Imag - (from_b).Imag;  \
}
X
/* Macro function that is equivalent to += operator for complex numbers. */
#define  CMPLX_ADD_ASSIGN(to,from)      \
{   (to).Real += (from).Real;           \
X    (to).Imag += (from).Imag;           \
}
X
/* Macro function that is equivalent to -= operator for complex numbers. */
#define  CMPLX_SUBT_ASSIGN(to,from)     \
{   (to).Real -= (from).Real;           \
X    (to).Imag -= (from).Imag;           \
}
X
/* Macro function that multiplies a complex number by a scalar. */
#define  SCLR_MULT(to,sclr,cmplx)       \
{   (to).Real = (sclr) * (cmplx).Real;  \
X    (to).Imag = (sclr) * (cmplx).Imag;  \
}
X
/* Macro function that multiply-assigns a complex number by a scalar. */
#define  SCLR_MULT_ASSIGN(to,sclr)      \
{   (to).Real *= (sclr);                \
X    (to).Imag *= (sclr);                \
}
X
/* Macro function that multiplies two complex numbers. */
#define  CMPLX_MULT(to,from_a,from_b)           \
{   (to).Real = (from_a).Real * (from_b).Real - \
X                (from_a).Imag * (from_b).Imag;  \
X    (to).Imag = (from_a).Real * (from_b).Imag + \
X                (from_a).Imag * (from_b).Real;  \
}
X
/* Macro function that implements to *= from for complex numbers. */
#define  CMPLX_MULT_ASSIGN(to,from)             \
{   RealNumber to_real_ = (to).Real;            \
X    (to).Real = to_real_ * (from).Real -        \
X                (to).Imag * (from).Imag;        \
X    (to).Imag = to_real_ * (from).Imag +        \
X                (to).Imag * (from).Real;        \
}
X
/* Macro function that multiplies two complex numbers, the first of which is
X * conjugated. */
#define  CMPLX_CONJ_MULT(to,from_a,from_b)      \
{   (to).Real = (from_a).Real * (from_b).Real + \
X                (from_a).Imag * (from_b).Imag;  \
X    (to).Imag = (from_a).Real * (from_b).Imag - \
X                (from_a).Imag * (from_b).Real;  \
}
X
/* Macro function that multiplies two complex numbers and then adds them
X * to another. to = add + mult_a * mult_b */
#define  CMPLX_MULT_ADD(to,mult_a,mult_b,add)                   \
{   (to).Real = (mult_a).Real * (mult_b).Real -                 \
X                (mult_a).Imag * (mult_b).Imag + (add).Real;     \
X    (to).Imag = (mult_a).Real * (mult_b).Imag +                 \
X                (mult_a).Imag * (mult_b).Real + (add).Imag;     \
}
X
/* Macro function that subtracts the product of two complex numbers from
X * another.  to = subt - mult_a * mult_b */
#define  CMPLX_MULT_SUBT(to,mult_a,mult_b,subt)                 \
{   (to).Real = (subt).Real - (mult_a).Real * (mult_b).Real +   \
X                              (mult_a).Imag * (mult_b).Imag;    \
X    (to).Imag = (subt).Imag - (mult_a).Real * (mult_b).Imag -   \
X                              (mult_a).Imag * (mult_b).Real;    \
}
X
/* Macro function that multiplies two complex numbers and then adds them
X * to another. to = add + mult_a* * mult_b where mult_a* represents mult_a
X * conjugate. */
#define  CMPLX_CONJ_MULT_ADD(to,mult_a,mult_b,add)              \
{   (to).Real = (mult_a).Real * (mult_b).Real +                 \
X                (mult_a).Imag * (mult_b).Imag + (add).Real;     \
X    (to).Imag = (mult_a).Real * (mult_b).Imag -                 \
X                (mult_a).Imag * (mult_b).Real + (add).Imag;     \
}
X
/* Macro function that multiplies two complex numbers and then adds them
X * to another. to += mult_a * mult_b */
#define  CMPLX_MULT_ADD_ASSIGN(to,from_a,from_b)        \
{   (to).Real += (from_a).Real * (from_b).Real -        \
X                 (from_a).Imag * (from_b).Imag;         \
X    (to).Imag += (from_a).Real * (from_b).Imag +        \
X                 (from_a).Imag * (from_b).Real;         \
}
X
/* Macro function that multiplies two complex numbers and then subtracts them
X * from another. */
#define  CMPLX_MULT_SUBT_ASSIGN(to,from_a,from_b)       \
{   (to).Real -= (from_a).Real * (from_b).Real -        \
X                 (from_a).Imag * (from_b).Imag;         \
X    (to).Imag -= (from_a).Real * (from_b).Imag +        \
X                 (from_a).Imag * (from_b).Real;         \
}
X
/* Macro function that multiplies two complex numbers and then adds them
X * to the destination. to += from_a* * from_b where from_a* represents from_a
X * conjugate. */
#define  CMPLX_CONJ_MULT_ADD_ASSIGN(to,from_a,from_b)   \
{   (to).Real += (from_a).Real * (from_b).Real +        \
X                 (from_a).Imag * (from_b).Imag;         \
X    (to).Imag += (from_a).Real * (from_b).Imag -        \
X                 (from_a).Imag * (from_b).Real;         \
}
X
/* Macro function that multiplies two complex numbers and then subtracts them
X * from the destination. to -= from_a* * from_b where from_a* represents from_a
X * conjugate. */
#define  CMPLX_CONJ_MULT_SUBT_ASSIGN(to,from_a,from_b)  \
{   (to).Real -= (from_a).Real * (from_b).Real +        \
X                 (from_a).Imag * (from_b).Imag;         \
X    (to).Imag -= (from_a).Real * (from_b).Imag -        \
X                 (from_a).Imag * (from_b).Real;         \
}
X
/*
X * Macro functions that provide complex division.
X */
X
/* Complex division:  to = num / den */
#define CMPLX_DIV(to,num,den)                                           \
{   RealNumber  r_, s_;                                                 \
X    if (((den).Real >= (den).Imag AND (den).Real > -(den).Imag) OR      \
X        ((den).Real < (den).Imag AND (den).Real <= -(den).Imag))        \
X    {   r_ = (den).Imag / (den).Real;                                   \
X        s_ = (den).Real + r_*(den).Imag;                                \
X        (to).Real = ((num).Real + r_*(num).Imag)/s_;                    \
X        (to).Imag = ((num).Imag - r_*(num).Real)/s_;                    \
X    }                                                                   \
X    else                                                                \
X    {   r_ = (den).Real / (den).Imag;                                   \
X        s_ = (den).Imag + r_*(den).Real;                                \
X        (to).Real = (r_*(num).Real + (num).Imag)/s_;                    \
X        (to).Imag = (r_*(num).Imag - (num).Real)/s_;                    \
X    }                                                                   \
}
X
/* Complex division and assignment:  num /= den */
#define CMPLX_DIV_ASSIGN(num,den)                                       \
{   RealNumber  r_, s_, t_;                                             \
X    if (((den).Real >= (den).Imag AND (den).Real > -(den).Imag) OR      \
X        ((den).Real < (den).Imag AND (den).Real <= -(den).Imag))        \
X    {   r_ = (den).Imag / (den).Real;                                   \
X        s_ = (den).Real + r_*(den).Imag;                                \
X        t_ = ((num).Real + r_*(num).Imag)/s_;                           \
X        (num).Imag = ((num).Imag - r_*(num).Real)/s_;                   \
X        (num).Real = t_;                                                \
X    }                                                                   \
X    else                                                                \
X    {   r_ = (den).Real / (den).Imag;                                   \
X        s_ = (den).Imag + r_*(den).Real;                                \
X        t_ = (r_*(num).Real + (num).Imag)/s_;                           \
X        (num).Imag = (r_*(num).Imag - (num).Real)/s_;                   \
X        (num).Real = t_;                                                \
X    }                                                                   \
}
X
/* Complex reciprocation:  to = 1.0 / den */
#define CMPLX_RECIPROCAL(to,den)                                        \
{   RealNumber  r_;                                                     \
X    if (((den).Real >= (den).Imag AND (den).Real > -(den).Imag) OR      \
X        ((den).Real < (den).Imag AND (den).Real <= -(den).Imag))        \
X    {   r_ = (den).Imag / (den).Real;                                   \
X        (to).Imag = -r_*((to).Real = 1.0/((den).Real + r_*(den).Imag)); \
X    }                                                                   \
X    else                                                                \
X    {   r_ = (den).Real / (den).Imag;                                   \
X        (to).Real = -r_*((to).Imag = -1.0/((den).Imag + r_*(den).Real));\
X    }                                                                   \
}
X
X
X
X
X
X
/*
X *  ASSERT and ABORT
X *
X *  Macro used to assert that if the code is working correctly, then 
X *  a condition must be true.  If not, then execution is terminated
X *  and an error message is issued stating that there is an internal
X *  error and giving the file and line number.  These assertions are
X *  not evaluated unless the DEBUG flag is true.
X */
X
#if DEBUG
#define ASSERT(condition)	\
{   if (NOT(condition))		\
X    {   (void)fflush(stdout);	\
X	(void)fprintf(stderr, "sparse: internal error detected in file `%s' at line %d.\n    assertion `%s' failed.\n",\
X	__FILE__, __LINE__, spcQUOTE(condition) ); \
X        (void)fflush(stderr);	\
X	abort();		\
X    }				\
}
#else
#define ASSERT(condition)
#endif
X
#if DEBUG
#define vASSERT(condition,message)	\
{   if (NOT(condition))			\
X	vABORT(message);		\
}
#else
#define vASSERT(condition,message)
#endif
X
#if DEBUG
#define  vABORT(message)	\
{   (void)fflush(stdout);	\
X    (void)fprintf(stderr, "sparse: internal error detected in file `%s' at line %d.\n    %s.\n", __FILE__, __LINE__, message );\
X    (void)fflush(stderr);	\
X    abort();			\
}
X
#define  ABORT()		\
{   (void)fflush(stdout);	\
X    (void)fprintf(stderr, "sparse: internal error detected in file `%s' at line %d.\n", __FILE__, __LINE__ );	\
X    (void)fflush(stderr);	\
X    abort();			\
}
#else
#define  vABORT(message)	abort()
#define  ABORT()		abort()
#endif
X
X
X
X
X
X
/*
X *  IMAGINARY VECTORS
X *
X *  The imaginary vectors iRHS and iSolution are only needed when the
X *  options spCOMPLEX and spSEPARATED_COMPLEX_VECTORS are set.  The following
X *  macro makes it easy to include or exclude these vectors as needed.
X */
X
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
#define IMAG_VECTORS    , iRHS, iSolution
#define IMAG_RHS        , iRHS
#define IMAG_RHS_DECL   , RealVector iRHS
#define IMAG_VECT_DECL  , RealVector iRHS, RealVector iSolution
#else
#define IMAG_VECTORS
#define IMAG_RHS
#define IMAG_RHS_DECL
#define IMAG_VECT_DECL
#endif
X
X
X
X
X
X
/*
X * MEMORY ALLOCATION
X */
X
spcEXTERN void *malloc(size_t size);
spcEXTERN void *calloc(size_t nmemb, size_t size);
spcEXTERN void *realloc(void *ptr, size_t size);
spcEXTERN void free(void *ptr);
spcEXTERN void abort(void);
X
#define ALLOC(type,number)  ((type *)malloc((unsigned)(sizeof(type)*(number))))
#define REALLOC(ptr,type,number)  \
X           ptr = (type *)realloc((char *)ptr,(unsigned)(sizeof(type)*(number)))
#define FREE(ptr) { if ((ptr) != NULL) free((char *)(ptr)); (ptr) = NULL; }
X
X
/* Calloc that properly handles allocating a cleared vector. */
#define CALLOC(ptr,type,number)                         \
{   int i; ptr = ALLOC(type, number);                   \
X    if (ptr != (type *)NULL)                            \
X        for(i=(number)-1;i>=0; i--) ptr[i] = (type) 0;  \
}
X
X
X
X
X
X
X
/*
X * Utility Functions
X */
/*
X * Compute the product of two intergers while avoiding overflow.
X * Used when computing Markowitz products.
X */
X
#define spcMarkoProd(product, op1, op2) \
X        if (( (op1) > LARGEST_SHORT_INTEGER AND (op2) != 0) OR \
X            ( (op2) > LARGEST_SHORT_INTEGER AND (op1) != 0)) \
X        {   double fProduct = (double)(op1) * (double)(op2); \
X            if (fProduct >= LARGEST_LONG_INTEGER) \
X                (product) = LARGEST_LONG_INTEGER; \
X            else \
X                (product) = (long)fProduct; \
X        } \
X        else (product) = (op1)*(op2);
X
X
X
X
X
X
/*
X *  REAL NUMBER
X */
X
/* Begin `RealNumber'. */
X
typedef  spREAL  RealNumber, *RealVector;
X
X
X
X
X
X
X
X
/*
X *  COMPLEX NUMBER DATA STRUCTURE
X *
X *  >>> Structure fields:
X *  Real  (RealNumber)
X *      The real portion of the number.  Real must be the first
X *      field in this structure.
X *  Imag  (RealNumber)
X *      The imaginary portion of the number. This field must follow
X *      immediately after Real.
X */
X
/* Begin `ComplexNumber'. */
X
typedef  struct
{   RealNumber  Real;
X    RealNumber  Imag;
} ComplexNumber, *ComplexVector;
X
X
X
X
X
X
X
X
/*
X *  MATRIX ELEMENT DATA STRUCTURE
X *
X *  Every nonzero element in the matrix is stored in a dynamically allocated
X *  MatrixElement structure.  These structures are linked together in an
X *  orthogonal linked list.  Two different MatrixElement structures exist.
X *  One is used when only real matrices are expected, it is missing an entry
X *  for imaginary data.  The other is used if complex matrices are expected.
X *  It contains an entry for imaginary data.
X *
X *  >>> Structure fields:
X *  Real  (RealNumber)
X *      The real portion of the value of the element.  Real must be the first
X *      field in this structure.
X *  Imag  (RealNumber)
X *      The imaginary portion of the value of the element. If the matrix
X *      routines are not compiled to handle complex matrices, then this
X *      field does not exist.  If it exists, it must follow immediately after
X *      Real.
X *  Row  (int)
X *      The row number of the element.
X *  Col  (int)
X *      The column number of the element.
X *  NextInRow  (struct MatrixElement *)
X *      NextInRow contains a pointer to the next element in the row to the
X *      right of this element.  If this element is the last nonzero in the
X *      row then NextInRow contains NULL.
X *  NextInCol  (struct MatrixElement *)
X *      NextInCol contains a pointer to the next element in the column below
X *      this element.  If this element is the last nonzero in the column then
X *      NextInCol contains NULL.
X *  pInitInfo  (spGenericPtr)
X *      Pointer to user data used for initialization of the matrix element.
X *      Initialized to NULL.
X *
X *  >>> Type definitions:
X *  ElementPtr
X *      A pointer to a MatrixElement.
X *  ArrayOfElementPtrs
X *      An array of ElementPtrs.  Used for FirstInRow, FirstInCol and
X *      Diag pointer arrays.
X */
X
/* Begin `MatrixElement'. */
X
struct  MatrixElement
{   RealNumber   Real;
#if spCOMPLEX
X    RealNumber   Imag;
#endif
X    int          Row;
X    int          Col;
X    struct MatrixElement  *NextInRow;
X    struct MatrixElement  *NextInCol;
#if INITIALIZE
X    spGenericPtr pInitInfo;
#endif
};
X
typedef  struct MatrixElement  *ElementPtr;
typedef  ElementPtr  *ArrayOfElementPtrs;
X
X
X
X
X
X
X
X
/*
X *  ALLOCATION DATA STRUCTURE
X *
X *  The sparse matrix routines keep track of all memory that is allocated by
X *  the operating system so the memory can later be freed.  This is done by
X *  saving the pointers to all the chunks of memory that are allocated to a
X *  particular matrix in an allocation list.  That list is organized as a
X *  linked list so that it can grow without a priori bounds.
X *
X *  >>> Structure fields:
X *  AllocatedPtr  (void *)
X *      Pointer to chunk of memory that has been allocated for the matrix.
X *  NextRecord  (struct  AllocationRecord *)
X *      Pointer to the next allocation record.
X */
X
/* Begin `AllocationRecord'. */
struct AllocationRecord
{   void  *AllocatedPtr;
X    struct  AllocationRecord  *NextRecord;
};
X
typedef  struct  AllocationRecord  *AllocationListPtr;
X
X
X
X
X
X
X
X
X
/*
X *  FILL-IN LIST DATA STRUCTURE
X *
X *  The sparse matrix routines keep track of all fill-ins separately from
X *  user specified elements so they may be removed by spStripFills().  Fill-ins
X *  are allocated in bunched in what is called a fill-in lists.  The data
X *  structure defined below is used to organize these fill-in lists into a
X *  linked-list.
X *
X *  >>> Structure fields:
X *  pFillinList  (ElementPtr)
X *      Pointer to a fill-in list, or a bunch of fill-ins arranged contiguously
X *      in memory.
X *  NumberOfFillinsInList  (int)
X *      Seems pretty self explanatory to me.
X *  Next  (struct  FillinListNodeStruct *)
X *      Pointer to the next fill-in list structures.
X */
X
/* Begin `FillinListNodeStruct'. */
struct FillinListNodeStruct
{   ElementPtr  pFillinList;
X    int         NumberOfFillinsInList;
X    struct      FillinListNodeStruct  *Next;
};
X
X
X
X
X
X
X
X
X
X
/*
X *  MATRIX FRAME DATA STRUCTURE
X *
X *  This structure contains all the pointers that support the orthogonal
X *  linked list that contains the matrix elements.  Also included in this
X *  structure are other numbers and pointers that are used globally by the
X *  sparse matrix routines and are associated with one particular matrix.
X *
X *  >>> Type definitions:
X *  MatrixPtr
X *      A pointer to MatrixFrame.  Essentially, a pointer to the matrix.
X *
X *  >>> Structure fields:
X *  AbsThreshold  (RealNumber)
X *      The absolute magnitude an element must have to be considered as a
X *      pivot candidate, except as a last resort.
X *  AllocatedExtSize  (int)
X *      The allocated size of the arrays used to translate external row and
X *      column numbers to their internal values.
X *  AllocatedSize  (int)
X *      The currently allocated size of the matrix; the size the matrix can
X *      grow to when EXPANDABLE is set true and AllocatedSize is the largest
X *      the matrix can get without requiring that the matrix frame be
X *      reallocated.
X *  Complex  (BOOLEAN)
X *      The flag which indicates whether the matrix is complex (true) or
X *      real.
X *  CurrentSize  (int)
X *      This number is used during the building of the matrix when the
X *      TRANSLATE option is set true.  It indicates the number of internal
X *      rows and columns that have elements in them.
X *  Diag  (ArrayOfElementPtrs)
X *      Array of pointers that points to the diagonal elements.
X *  DoCmplxDirect  (BOOLEAN *)
X *      Array of flags, one for each column in matrix.  If a flag is true
X *      then corresponding column in a complex matrix should be eliminated
X *      in spFactor() using direct addressing (rather than indirect
X *      addressing).
X *  DoRealDirect  (BOOLEAN *)
X *      Array of flags, one for each column in matrix.  If a flag is true
X *      then corresponding column in a real matrix should be eliminated
X *      in spFactor() using direct addressing (rather than indirect
X *      addressing).
X *  Elements  (int)
X *      The number of original elements (total elements minus fill ins)
X *      present in matrix.
X *  Error  (int)
X *      The error status of the sparse matrix package.
X *  ExtSize  (int)
X *      The value of the largest external row or column number encountered.
X *  ExtToIntColMap  (int [])
X *      An array that is used to convert external columns number to internal
X *      external column numbers.  Present only if TRANSLATE option is set true.
X *  ExtToIntRowMap  (int [])
X *      An array that is used to convert external row numbers to internal
X *      external row numbers.  Present only if TRANSLATE option is set true.
X *  Factored  (BOOLEAN)
X *      Indicates if matrix has been factored.  This flag is set true in
X *      spFactor() and spOrderAndFactor() and set false in spCreate()
X *      and spClear().
X *  Fillins  (int)
X *      The number of fill-ins created during the factorization the matrix.
X *  FirstInCol  (ArrayOfElementPtrs)
X *      Array of pointers that point to the first nonzero element of the
X *      column corresponding to the index.
X *  FirstInRow  (ArrayOfElementPtrs)
X *      Array of pointers that point to the first nonzero element of the row
X *      corresponding to the index.
X *  ID  (unsigned long int)
X *      A constant that provides the sparse data structure with a signature.
X *      When DEBUG is true, all externally available sparse routines check
X *      this signature to assure they are operating on a valid matrix.
X *  Intermediate  (RealVector)
X *      Temporary storage used in the spSolve routines. Intermediate is an
X *      array used during forward and backward substitution.  It is
X *      commonly called y when the forward and backward substitution process is
X *      denoted  Ax = b => Ly = b and Ux = y.
X *  InternalVectorsAllocated  (BOOLEAN)
X *      A flag that indicates whether theMmarkowitz vectors and the
X *      Intermediate vector have been created.
X *      These vectors are created in spcCreateInternalVectors().
X *  IntToExtColMap  (int [])
X *      An array that is used to convert internal column numbers to external
X *      external column numbers.
X *  IntToExtRowMap  (int [])
X *      An array that is used to convert internal row numbers to external
X *      external row numbers.
X *  MarkowitzCol  (int [])
X *      An array that contains the count of the non-zero elements excluding
X *      the pivots for each column. Used to generate and update MarkowitzProd.
X *  MarkowitzProd  (long [])
X *      The array of the products of the Markowitz row and column counts. The
X *      element with the smallest product is the best pivot to use to maintain
X *      sparsity.
X *  MarkowitzRow  (int [])
X *      An array that contains the count of the non-zero elements excluding
X *      the pivots for each row. Used to generate and update MarkowitzProd.
X *  MaxRowCountInLowerTri  (int)
X *      The maximum number of off-diagonal element in the rows of L, the
X *      lower triangular matrix.  This quantity is used when computing an
X *      estimate of the roundoff error in the matrix.
X *  NeedsOrdering  (BOOLEAN)
X *      This is a flag that signifies that the matrix needs to be ordered
X *      or reordered.  NeedsOrdering is set true in spCreate() and
X *      spGetElement() or spGetAdmittance() if new elements are added to the
X *      matrix after it has been previously factored.  It is set false in
X *      spOrderAndFactor().
X *  NumberOfInterchangesIsOdd  (BOOLEAN)
X *      Flag that indicates the sum of row and column interchange counts
X *      is an odd number.  Used when determining the sign of the determinant.
X *  Partitioned  (BOOLEAN)
X *      This flag indicates that the columns of the matrix have been 
X *      partitioned into two groups.  Those that will be addressed directly
X *      and those that will be addressed indirectly in spFactor().
X *  PivotsOriginalCol  (int)
X *      Column pivot was chosen from.
X *  PivotsOriginalRow  (int)
X *      Row pivot was chosen from.
X *  PivotSelectionMethod  (char)
X *      Character that indicates which pivot search method was successful.
X *  PreviousMatrixWasComplex  (BOOLEAN)
X *      This flag in needed to determine how to clear the matrix.  When
X *      dealing with real matrices, it is important that the imaginary terms
X *      in the matrix elements be zero.  Thus, if the previous matrix was
X *      complex, then the current matrix will be cleared as if it were complex
X *      even if it is real.
X *  RelThreshold  (RealNumber)
X *      The magnitude an element must have relative to others in its row
X *      to be considered as a pivot candidate, except as a last resort.
X *  Reordered  (BOOLEAN)
X *      This flag signifies that the matrix has been reordered.  It
X *      is cleared in spCreate(), set in spMNA_Preorder() and
X *      spOrderAndFactor() and is used in spPrint().
X *  RowsLinked  (BOOLEAN)
X *      A flag that indicates whether the row pointers exist.  The AddByIndex
X *      routines do not generate the row pointers, which are needed by some
X *      of the other routines, such as spOrderAndFactor() and spScale().
X *      The row pointers are generated in the function spcLinkRows().
X *  SingularCol  (int)
X *      Normally zero, but if matrix is found to be singular, SingularCol is
X *      assigned the external column number of pivot that was zero.
X *  SingularRow  (int)
X *      Normally zero, but if matrix is found to be singular, SingularRow is
X *      assigned the external row number of pivot that was zero.
X *  Singletons  (int)
X *      The number of singletons available for pivoting.  Note that if row I
X *      and column I both contain singletons, only one of them is counted.
X *  Size  (int)
X *      Number of rows and columns in the matrix.  Does not change as matrix
X *      is factored.
X *  TrashCan  (MatrixElement)
X *      This is a dummy MatrixElement that is used to by the user to stuff
X *      data related to the zero row or column.  In other words, when the user
X *      adds an element in row zero or column zero, then the matrix returns
X *      a pointer to TrashCan.  In this way the user can have a uniform way
X *      data into the matrix independent of whether a component is connected
X *      to ground.
X *
X *  >>> The remaining fields are related to memory allocation.
X *  TopOfAllocationList  (AllocationListPtr)
X *      Pointer which points to the top entry in a list. The list contains
X *      all the pointers to the segments of memory that have been allocated
X *      to this matrix. This is used when the memory is to be freed on
X *      deallocation of the matrix.
X *  RecordsRemaining  (int)
X *      Number of slots left in the list of allocations.
X *  NextAvailElement  (ElementPtr)
X *      Pointer to the next available element which has been allocated but as
X *      yet is unused. Matrix elements are allocated in groups of
X *      ELEMENTS_PER_ALLOCATION in order to speed element allocation and
X *      freeing.
X *  ElementsRemaining  (int)
X *      Number of unused elements left in last block of elements allocated.
X *  NextAvailFillin  (ElementPtr)
X *      Pointer to the next available fill-in which has been allocated but
X *      as yet is unused.  Fill-ins are allocated in a group in order to keep
X *      them physically close in memory to the rest of the matrix.
X *  FillinsRemaining  (int)
X *      Number of unused fill-ins left in the last block of fill-ins
X *      allocated.
X *  FirstFillinListNode  (FillinListNodeStruct *)
X *      A pointer to the head of the linked-list that keeps track of the
X *      lists of fill-ins.
X *  LastFillinListNode  (FillinListNodeStruct *)
X *      A pointer to the tail of the linked-list that keeps track of the
X *      lists of fill-ins.
X */
X
/* Begin `MatrixFrame'. */
struct  MatrixFrame
{   RealNumber                   AbsThreshold;
X    int                          AllocatedSize;
X    int                          AllocatedExtSize;
X    BOOLEAN                      Complex;
X    int                          CurrentSize;
X    ArrayOfElementPtrs           Diag;
X    BOOLEAN                     *DoCmplxDirect;
X    BOOLEAN                     *DoRealDirect;
X    int                          Elements;
X    int                          Error;
X    int                          ExtSize;
X    int                         *ExtToIntColMap;
X    int                         *ExtToIntRowMap;
X    BOOLEAN                      Factored;
X    int                          Fillins;
X    ArrayOfElementPtrs           FirstInCol;
X    ArrayOfElementPtrs           FirstInRow;
X    unsigned long                ID;
X    RealVector                   Intermediate;
X    BOOLEAN                      InternalVectorsAllocated;
X    int                         *IntToExtColMap;
X    int                         *IntToExtRowMap;
X    int                         *MarkowitzRow;
X    int                         *MarkowitzCol;
X    long                        *MarkowitzProd;
X    int                          MaxRowCountInLowerTri;
X    BOOLEAN                      NeedsOrdering;
X    BOOLEAN                      NumberOfInterchangesIsOdd;
X    BOOLEAN                      Partitioned;
X    int                          PivotsOriginalCol;
X    int                          PivotsOriginalRow;
X    char                         PivotSelectionMethod;
X    BOOLEAN                      PreviousMatrixWasComplex;
X    RealNumber                   RelThreshold;
X    BOOLEAN                      Reordered;
X    BOOLEAN                      RowsLinked;
X    int                          SingularCol;
X    int                          SingularRow;
X    int                          Singletons;
X    int                          Size;
X    struct MatrixElement         TrashCan;
X
X    AllocationListPtr            TopOfAllocationList;
X    int                          RecordsRemaining;
X    ElementPtr                   NextAvailElement;
X    int                          ElementsRemaining;
X    ElementPtr                   NextAvailFillin;
X    int                          FillinsRemaining;
X    struct FillinListNodeStruct *FirstFillinListNode;
X    struct FillinListNodeStruct *LastFillinListNode;
};
typedef  struct MatrixFrame  *MatrixPtr;
X
X
X
X
/*
X *  Declarations
X */
X
spcEXTERN ElementPtr spcGetElement( MatrixPtr );
spcEXTERN ElementPtr spcGetFillin( MatrixPtr );
spcEXTERN ElementPtr spcFindDiag( MatrixPtr, int );
spcEXTERN ElementPtr spcCreateElement( MatrixPtr, int, int,
X				ElementPtr*, ElementPtr*, int );
spcEXTERN void spcCreateInternalVectors( MatrixPtr );
spcEXTERN void spcLinkRows( MatrixPtr );
spcEXTERN void spcColExchange( MatrixPtr, int, int );
spcEXTERN void spcRowExchange( MatrixPtr, int, int );
X
spcEXTERN char spcMatrixIsNotValid[];
spcEXTERN char spcErrorsMustBeCleared[];
spcEXTERN char spcMatrixMustBeFactored[];
spcEXTERN char spcMatrixMustNotBeFactored[];
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spDefs.h'; eval "$shar_touch") &&
  chmod 0600 'sparse/spDefs.h'
if test $? -ne 0
then ${echo} 'restore of sparse/spDefs.h failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spDefs.h: MD5 check failed'
       ) << \SHAR_EOF
02248b07d06b7eada20321eb3d75d934  sparse/spDefs.h
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spDefs.h'` -ne 34667 && \
  ${echo} 'restoration warning:  size of sparse/spDefs.h is not 34667'
  fi
fi
# ============= sparse/spDoc.pdf ==============
if test -f 'sparse/spDoc.pdf' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spDoc.pdf (file already exists)'
else
${echo} 'x - extracting sparse/spDoc.pdf (binary)'
  sed 's/^X//' << 'SHAR_EOF' | uudecode &&
begin 600 sparse/spDoc.pdf
M)5!$1BTQ+C0-)>+CS],-"C,Y-R`P(&]B:CP\+TA;-3@W-B`V,3$U72],:6YE
M87)I>F5D(#$O12`Y,3(U,R],(#(U-S<X,2].(#(T+T\@-#`P+U0@,C0Y-SDS
M/CX-96YD;V)J#2`@("`@("`@("`@("`@#0IX<F5F#0HS.3<@,C<Y#0HP,#`P
M,#`P,#$V(#`P,#`P(&X-"C`P,#`P,3$Y.3$@,#`P,#`@;@T*,#`P,#`P-3@W
M-B`P,#`P,"!N#0HP,#`P,#$R,#<U(#`P,#`P(&X-"C`P,#`P,3(R,#@@,#`P
M,#`@;@T*,#`P,#`Q,C,W,2`P,#`P,"!N#0HP,#`P,#$R-S$P(#`P,#`P(&X-
M"C`P,#`P,3(Y-C@@,#`P,#`@;@T*,#`P,#`Q,S(X-R`P,#`P,"!N#0HP,#`P
M,#$S-3<Y(#`P,#`P(&X-"C`P,#`P,3,W,S@@,#`P,#`@;@T*,#`P,#`Q-#`U
M,2`P,#`P,"!N#0HP,#`P,#$T-#4X(#`P,#`P(&X-"C`P,#`P,30W,C@@,#`P
M,#`@;@T*,#`P,#`Q-3`P,"`P,#`P,"!N#0HP,#`P,#$U,C8W(#`P,#`P(&X-
M"C`P,#`P,34U,#$@,#`P,#`@;@T*,#`P,#`Q-3<V,2`P,#`P,"!N#0HP,#`P
M,#$U.38P(#`P,#`P(&X-"C`P,#`P,38R-#(@,#`P,#`@;@T*,#`P,#`Q-C0W
M-R`P,#`P,"!N#0HP,#`P,#$V-S$P(#`P,#`P(&X-"C`P,#`P,38X.3<@,#`P
M,#`@;@T*,#`P,#`Q-S$Q,2`P,#`P,"!N#0HP,#`P,#$W,S4P(#`P,#`P(&X-
M"C`P,#`P,3<U.#8@,#`P,#`@;@T*,#`P,#`Q-S@P,"`P,#`P,"!N#0HP,#`P
M,#$W.3@P(#`P,#`P(&X-"C`P,#`P,3@Q-3$@,#`P,#`@;@T*,#`P,#`Q.#0V
M,B`P,#`P,"!N#0HP,#`P,#$X-C@Y(#`P,#`P(&X-"C`P,#`P,3@Y-3(@,#`P
M,#`@;@T*,#`P,#`Q.3$S-"`P,#`P,"!N#0HP,#`P,#$Y-#8P(#`P,#`P(&X-
M"C`P,#`P,3DV-3D@,#`P,#`@;@T*,#`P,#`Q.3@R-"`P,#`P,"!N#0HP,#`P
M,#(P,38S(#`P,#`P(&X-"C`P,#`P,C`T,S<@,#`P,#`@;@T*,#`P,#`R,#8V
M,B`P,#`P,"!N#0HP,#`P,#(P.3DQ(#`P,#`P(&X-"C`P,#`P,C$R,S(@,#`P
M,#`@;@T*,#`P,#`R,34U,"`P,#`P,"!N#0HP,#`P,#(Q.#<U(#`P,#`P(&X-
M"C`P,#`P,C(R,#$@,#`P,#`@;@T*,#`P,#`R,C4S-"`P,#`P,"!N#0HP,#`P
M,#(R.#$Q(#`P,#`P(&X-"C`P,#`P,C,Q-3<@,#`P,#`@;@T*,#`P,#`R,S0Q
M,2`P,#`P,"!N#0HP,#`P,#(S-S(X(#`P,#`P(&X-"C`P,#`P,C0P,S4@,#`P
M,#`@;@T*,#`P,#`R-#(W-2`P,#`P,"!N#0HP,#`P,#(T-3<Q(#`P,#`P(&X-
M"C`P,#`P,C0X.#8@,#`P,#`@;@T*,#`P,#`R-3(P,R`P,#`P,"!N#0HP,#`P
M,#(U-#<T(#`P,#`P(&X-"C`P,#`P,C4W.#`@,#`P,#`@;@T*,#`P,#`R-3DV
M,"`P,#`P,"!N#0HP,#`P,#(V,3<R(#`P,#`P(&X-"C`P,#`P,C8T.#4@,#`P
M,#`@;@T*,#`P,#`R-C<S."`P,#`P,"!N#0HP,#`P,#(W,3,W(#`P,#`P(&X-
M"C`P,#`P,C<U,#8@,#`P,#`@;@T*,#`P,#`R-S@X-B`P,#`P,"!N#0HP,#`P
M,#(X,C<P(#`P,#`P(&X-"C`P,#`P,C@V-C@@,#`P,#`@;@T*,#`P,#`R.3`P
M-2`P,#`P,"!N#0HP,#`P,#(Y-#(S(#`P,#`P(&X-"C`P,#`P,CDW,#4@,#`P
M,#`@;@T*,#`P,#`S,#`X-R`P,#`P,"!N#0HP,#`P,#,P-#0V(#`P,#`P(&X-
M"C`P,#`P,S`W,#8@,#`P,#`@;@T*,#`P,#`S,3`T.2`P,#`P,"!N#0HP,#`P
M,#,Q-#`R(#`P,#`P(&X-"C`P,#`P,S$W.#$@,#`P,#`@;@T*,#`P,#`S,C`Y
M,2`P,#`P,"!N#0HP,#`P,#,R-#@W(#`P,#`P(&X-"C`P,#`P,S(W.3,@,#`P
M,#`@;@T*,#`P,#`S,S$W-"`P,#`P,"!N#0HP,#`P,#,S-C8X(#`P,#`P(&X-
M"C`P,#`P,S0U.#`@,#`P,#`@;@T*,#`P,#`S-#@V-"`P,#`P,"!N#0HP,#`P
M,#,T.30Q(#`P,#`P(&X-"C`P,#`P,S0Y.#,@,#`P,#`@;@T*,#`P,#`S-3$V
M,B`P,#`P,"!N#0HP,#`P,#,U-#@V(#`P,#`P(&X-"C`P,#`P,S4W,S0@,#`P
M,#`@;@T*,#`P,#`S-C`S.2`P,#`P,"!N#0HP,#`P,#,V,S,X(#`P,#`P(&X-
M"C`P,#`P,S8U,S<@,#`P,#`@;@T*,#`P,#`S-C<Q-"`P,#`P,"!N#0HP,#`P
M,#,W,#<V(#`P,#`P(&X-"C`P,#`P,S<T.3(@,#`P,#`@;@T*,#`P,#`S-S@S
M,2`P,#`P,"!N#0HP,#`P,#,X,#<P(#`P,#`P(&X-"C`P,#`P,S@S.38@,#`P
M,#`@;@T*,#`P,#`S.#<Q,B`P,#`P,"!N#0HP,#`P,#,Y,#`U(#`P,#`P(&X-
M"C`P,#`P,SDT,C@@,#`P,#`@;@T*,#`P,#`S.38T-"`P,#`P,"!N#0HP,#`P
M,#0P,#,V(#`P,#`P(&X-"C`P,#`P-#`R-C,@,#`P,#`@;@T*,#`P,#`T,#4Q
M-R`P,#`P,"!N#0HP,#`P,#0P.#$P(#`P,#`P(&X-"C`P,#`P-#$P-C<@,#`P
M,#`@;@T*,#`P,#`T,3,T,"`P,#`P,"!N#0HP,#`P,#0Q-C4V(#`P,#`P(&X-
M"C`P,#`P-#(P,3`@,#`P,#`@;@T*,#`P,#`T,C,P,"`P,#`P,"!N#0HP,#`P
M,#0R-38Y(#`P,#`P(&X-"C`P,#`P-#(X-S8@,#`P,#`@;@T*,#`P,#`T,S$T
M.2`P,#`P,"!N#0HP,#`P,#0S-#,W(#`P,#`P(&X-"C`P,#`P-#,W-#8@,#`P
M,#`@;@T*,#`P,#`T,SDX-R`P,#`P,"!N#0HP,#`P,#0T,C8S(#`P,#`P(&X-
M"C`P,#`P-#0T.34@,#`P,#`@;@T*,#`P,#`T-#@Q,2`P,#`P,"!N#0HP,#`P
M,#0U,#4U(#`P,#`P(&X-"C`P,#`P-#4R,C$@,#`P,#`@;@T*,#`P,#`T-34Q
M-2`P,#`P,"!N#0HP,#`P,#0U.#(Q(#`P,#`P(&X-"C`P,#`P-#8Q.3$@,#`P
M,#`@;@T*,#`P,#`T-C4S,"`P,#`P,"!N#0HP,#`P,#0V.#<R(#`P,#`P(&X-
M"C`P,#`P-#<R,C,@,#`P,#`@;@T*,#`P,#`T-S4T-B`P,#`P,"!N#0HP,#`P
M,#0W.3`T(#`P,#`P(&X-"C`P,#`P-#@Q.3(@,#`P,#`@;@T*,#`P,#`T.#0Q
M."`P,#`P,"!N#0HP,#`P,#0X-C4V(#`P,#`P(&X-"C`P,#`P-#@X-CD@,#`P
M,#`@;@T*,#`P,#`T.3`Y.2`P,#`P,"!N#0HP,#`P,#0Y,S`S(#`P,#`P(&X-
M"C`P,#`P-#DV,CD@,#`P,#`@;@T*,#`P,#`T.3DW."`P,#`P,"!N#0HP,#`P
M,#4P-C8R(#`P,#`P(&X-"C`P,#`P-3`W,#0@,#`P,#`@;@T*,#`P,#`U,#DQ
M-B`P,#`P,"!N#0HP,#`P,#4Q,C(P(#`P,#`P(&X-"C`P,#`P-3$T.#@@,#`P
M,#`@;@T*,#`P,#`U,3<T-R`P,#`P,"!N#0HP,#`P,#4R,#<U(#`P,#`P(&X-
M"C`P,#`P-3(S,C0@,#`P,#`@;@T*,#`P,#`U,C4T."`P,#`P,"!N#0HP,#`P
M,#4R.#@S(#`P,#`P(&X-"C`P,#`P-3,R-S,@,#`P,#`@;@T*,#`P,#`U,S8R
M."`P,#`P,"!N#0HP,#`P,#4S.3$V(#`P,#`P(&X-"C`P,#`P-30R-C4@,#`P
M,#`@;@T*,#`P,#`U-#4X,"`P,#`P,"!N#0HP,#`P,#4T.#8V(#`P,#`P(&X-
M"C`P,#`P-34Q,C(@,#`P,#`@;@T*,#`P,#`U-3,Y-R`P,#`P,"!N#0HP,#`P
M,#4U-C8S(#`P,#`P(&X-"C`P,#`P-34Y-SD@,#`P,#`@;@T*,#`P,#`U-C$U
M.2`P,#`P,"!N#0HP,#`P,#4V-38S(#`P,#`P(&X-"C`P,#`P-38X-#8@,#`P
M,#`@;@T*,#`P,#`U-S`Y-R`P,#`P,"!N#0HP,#`P,#4W,S`Q(#`P,#`P(&X-
M"C`P,#`P-3<T-S,@,#`P,#`@;@T*,#`P,#`U-S<S-2`P,#`P,"!N#0HP,#`P
M,#4X,#8Y(#`P,#`P(&X-"C`P,#`P-3@S-#D@,#`P,#`@;@T*,#`P,#`U.#8S
M-"`P,#`P,"!N#0HP,#`P,#4X.#0X(#`P,#`P(&X-"C`P,#`P-3DQ,C8@,#`P
M,#`@;@T*,#`P,#`U.3,Y-R`P,#`P,"!N#0HP,#`P,#4Y-C8X(#`P,#`P(&X-
M"C`P,#`P-3DX-S4@,#`P,#`@;@T*,#`P,#`V,#(R,B`P,#`P,"!N#0HP,#`P
M,#8P-#4T(#`P,#`P(&X-"C`P,#`P-C`V-3<@,#`P,#`@;@T*,#`P,#`V,#DW
M-2`P,#`P,"!N#0HP,#`P,#8Q,3DS(#`P,#`P(&X-"C`P,#`P-C$T,C$@,#`P
M,#`@;@T*,#`P,#`V,38X,B`P,#`P,"!N#0HP,#`P,#8Q.3<Y(#`P,#`P(&X-
M"C`P,#`P-C(S-34@,#`P,#`@;@T*,#`P,#`V,C8T,B`P,#`P,"!N#0HP,#`P
M,#8R.3<Q(#`P,#`P(&X-"C`P,#`P-C,R.#$@,#`P,#`@;@T*,#`P,#`V,S4V
M-"`P,#`P,"!N#0HP,#`P,#8S-S(X(#`P,#`P(&X-"C`P,#`P-C0P-3(@,#`P
M,#`@;@T*,#`P,#`V-#0W.2`P,#`P,"!N#0HP,#`P,#8T-S8S(#`P,#`P(&X-
M"C`P,#`P-C4P-#8@,#`P,#`@;@T*,#`P,#`V-3,R,B`P,#`P,"!N#0HP,#`P
M,#8U-C(S(#`P,#`P(&X-"C`P,#`P-C8P,#@@,#`P,#`@;@T*,#`P,#`V-C(Q
M-R`P,#`P,"!N#0HP,#`P,#8V-3`R(#`P,#`P(&X-"C`P,#`P-C<Q,3<@,#`P
M,#`@;@T*,#`P,#`V-S$U.2`P,#`P,"!N#0HP,#`P,#8W-#4V(#`P,#`P(&X-
M"C`P,#`P-C<W,S8@,#`P,#`@;@T*,#`P,#`V-SDV,2`P,#`P,"!N#0HP,#`P
M,#8X,S(Q(#`P,#`P(&X-"C`P,#`P-C@U.#<@,#`P,#`@;@T*,#`P,#`V.#@U
M,R`P,#`P,"!N#0HP,#`P,#8Y,#4U(#`P,#`P(&X-"C`P,#`P-CDR,S4@,#`P
M,#`@;@T*,#`P,#`W,3@R,B`P,#`P,"!N#0HP,#`P,#<Q.#8T(#`P,#`P(&X-
M"C`P,#`P-S$Y-3`@,#`P,#`@;@T*,#`P,#`W,C,R."`P,#`P,"!N#0HP,#`P
M,#<R.#4W(#`P,#`P(&X-"C`P,#`P-S,R,SD@,#`P,#`@;@T*,#`P,#`W,S8T
M."`P,#`P,"!N#0HP,#`P,#<S.3$W(#`P,#`P(&X-"C`P,#`P-S0S,38@,#`P
M,#`@;@T*,#`P,#`W-#<Q-"`P,#`P,"!N#0HP,#`P,#<U,#<P(#`P,#`P(&X-
M"C`P,#`P-S4R.3`@,#`P,#`@;@T*,#`P,#`W-3<V-2`P,#`P,"!N#0HP,#`P
M,#<V,#8P(#`P,#`P(&X-"C`P,#`P-S8R-SD@,#`P,#`@;@T*,#`P,#`W-C0S
M,B`P,#`P,"!N#0HP,#`P,#<V-#<T(#`P,#`P(&X-"C`P,#`P-S8U-S4@,#`P
M,#`@;@T*,#`P,#`W-C@X-B`P,#`P,"!N#0HP,#`P,#<W,S0U(#`P,#`P(&X-
M"C`P,#`P-S<V.34@,#`P,#`@;@T*,#`P,#`W.#`V,2`P,#`P,"!N#0HP,#`P
M,#<X,S$S(#`P,#`P(&X-"C`P,#`P-S@V-S0@,#`P,#`@;@T*,#`P,#`W.3`S
M-R`P,#`P,"!N#0HP,#`P,#<Y,S`U(#`P,#`P(&X-"C`P,#`P-SDU,#<@,#`P
M,#`@;@T*,#`P,#`W.3DS-B`P,#`P,"!N#0HP,#`P,#@P,30U(#`P,#`P(&X-
M"C`P,#`P.#`T,C4@,#`P,#`@;@T*,#`P,#`X,#8V,B`P,#`P,"!N#0HP,#`P
M,#@Q,#$X(#`P,#`P(&X-"C`P,#`P.#$R.30@,#`P,#`@;@T*,#`P,#`X,38T
M-B`P,#`P,"!N#0HP,#`P,#@Q.#(Y(#`P,#`P(&X-"C`P,#`P.#(P,S<@,#`P
M,#`@;@T*,#`P,#`X,C`W.2`P,#`P,"!N#0HP,#`P,#@R,34Y(#`P,#`P(&X-
M"C`P,#`P.#(T-#`@,#`P,#`@;@T*,#`P,#`X,C8U.2`P,#`P,"!N#0HP,#`P
M,#@R.38Q(#`P,#`P(&X-"C`P,#`P.#,R-38@,#`P,#`@;@T*,#`P,#`X,S0T
M,B`P,#`P,"!N#0HP,#`P,#@S-C<V(#`P,#`P(&X-"C`P,#`P.#,Y-3<@,#`P
M,#`@;@T*,#`P,#`X-#,Q-2`P,#`P,"!N#0HP,#`P,#@T-3,X(#`P,#`P(&X-
M"C`P,#`P.#0V.3,@,#`P,#`@;@T*,#`P,#`X-#@R-"`P,#`P,"!N#0HP,#`P
M,#@T.#8V(#`P,#`P(&X-"C`P,#`P.#0Y-C$@,#`P,#`@;@T*,#`P,#`X-3(S
M."`P,#`P,"!N#0HP,#`P,#@U-C$Y(#`P,#`P(&X-"C`P,#`P.#4X.#D@,#`P
M,#`@;@T*,#`P,#`X-C$P,"`P,#`P,"!N#0HP,#`P,#@V,S<X(#`P,#`P(&X-
M"C`P,#`P.#8V-C<@,#`P,#`@;@T*,#`P,#`X-C@W."`P,#`P,"!N#0HP,#`P
M,#@W,#DY(#`P,#`P(&X-"C`P,#`P.#<S,#D@,#`P,#`@;@T*,#`P,#`X-S4Y
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
M.3`@,"!2+T-4(#0Y,2`P(%(O0T0@-#DR(#`@4B]"6B`T.3,@,"!2+T-8(#0Y
M-"`P(%(O0E0@-#DU(#`@4B]#-"`T.38@,"!2+T0R(#0Y-R`P(%(O0E@@-#DX
M(#`@4B]$."`T.3D@,"!2+T0S(#0U,2`P(%(O1#`@-#4R(#`@4B]"1"`T-3,@
M,"!2+T-:(#0U-"`P(%(O0U4@-#4U(#`@4B]#5B`T-38@,"!2+T)%(#0U-R`P
M(%(O0D8@-#4X(#`@4B]#-B`T-3D@,"!2+T,W(#0V,"`P(%(O0E<@-#8Q(#`@
M4B]"5B`T-C(@,"!2+T,X(#0V,R`P(%(O0S4@-#8T(#`@4B]"2"`T-C4@,"!2
M+T)9(#0V-B`P(%(O0E4@-#8W(#`@4B]#2"`T-C@@,"!2+T))(#0V.2`P(%(O
M0DH@-#<P(#`@4B]"2R`T-S$@,"!2+T0Q(#0W,B`P(%(O1$(@-#<S(#`@4CX^
M#65N9&]B:@TT-S4@,"!O8FH\/"]#4R`U.3(@,"!2+T-#(#4Y,R`P(%(O0T<@
M-3DT(#`@4B]#4B`U.34@,"!2+T)'(#4Y-B`P(%(O0S`@-3DW(#`@4B]#,2`U
M.3@@,"!2+T)#(#4T.2`P(%(O0T$@-34P(#`@4B]"32`U-3$@,"!2+T-&(#4U
M,B`P(%(O044@-34S(#`@4B]!0R`U-30@,"!2+T-/(#4U-2`P(%(O0TP@-34V
M(#`@4B]$02`U-3<@,"!2+T-"(#4U."`P(%(O1#0@-34Y(#`@4B]#4"`U-C`@
M,"!2+T0V(#4V,2`P(%(O1#<@-38R(#`@4B]#5"`U-C,@,"!2+T-$(#4V-"`P
M(%(O0C,@-38U(#`@4B]"6B`U-C8@,"!2+T0Y(#4V-R`P(%(O0U@@-38X(#`@
M4B]"5"`U-CD@,"!2+T,T(#4W,"`P(%(O1#(@-3<Q(#`@4B]"6"`U-S(@,"!2
M+T0U(#4W,R`P(%(O1#@@-#(V(#`@4B]$,R`T,C<@,"!2+T0P(#0R."`P(%(O
M0T4@-#(Y(#`@4B]"1"`T,S`@,"!2+T)!(#0S,2`P(%(O0S,@-#,R(#`@4B]#
M6B`T,S,@,"!2+T-5(#0S-"`P(%(O0U8@-#,U(#`@4B]#,B`T,S8@,"!2+T)%
M(#0S-R`P(%(O0D8@-#,X(#`@4B]#-B`T,SD@,"!2+T,W(#0T,"`P(%(O0E<@
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
M(#@Q(#<U(#4S(#8Q(#<S(#@S(#,W(#@Q(#DR(#@Q(#@Q(#4X(#<Y(#,W(#<R
M73X^#65N9&]B:@TU,C8@,"!O8FH\/"]4>7!E+T9O;G0O4F5S;W5R8V5S(#8S
M-2`P(%(O3F%M92]4,R]%;F-O9&EN9R`V,S8@,"!2+T9I<G-T0VAA<B`P+TQA
M<W1#:&%R(#DO0VAA<E!R;V-S(#8T-R`P(%(O4W5B='EP92]4>7!E,R]&;VYT
M0D)O>%LS("TQ(#8Y(#<Q72]&;VYT36%T<FEX6S$@,"`P("TQ(#`@,%TO5VED
M=&AS6S<S(#4Q(#,W(#0R(#(U(#4U(#4V(#4U(#,P(#4U73X^#65N9&]B:@TU
M,C<@,"!O8FH\/"]4>7!E+T9O;G0O4F5S;W5R8V5S(#8T."`P(%(O3F%M92]4
M-"]%;F-O9&EN9R`V-#D@,"!2+T9I<G-T0VAA<B`P+TQA<W1#:&%R(#$T+T-H
M87)0<F]C<R`V-C4@,"!2+U-U8G1Y<&4O5'EP93,O1F]N=$)";WA;,B`M,C$@
M-C(@-S!=+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-C<@-#,@
M-3`@-3`@-3`@,S,@,S4@-#<@-C4@,S<@,C<@-#D@-#,@,S`@-#E=/CX-96YD
M;V)J#34R."`P(&]B:CP\+U1Y<&4O1F]N="]297-O=7)C97,@-C8V(#`@4B].
M86UE+U0U+T5N8V]D:6YG(#8V-R`P(%(O1FER<W1#:&%R(#`O3&%S=$-H87(@
M-B]#:&%R4')O8W,@-C<U(#`@4B]3=6)T>7!E+U1Y<&4S+T9O;G1"0F]X6S,@
M+3(@-3`@-CA=+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-3`@
M-30@-30@-#,@-#D@-#D@-#E=/CX-96YD;V)J#34R.2`P(&]B:CP\+U1Y<&4O
M1F]N="]297-O=7)C97,@-#<X(#`@4B].86UE+U0V+T5N8V]D:6YG(#0W.2`P
M(%(O1FER<W1#:&%R(#`O3&%S=$-H87(@-#(O0VAA<E!R;V-S(#0W-"`P(%(O
M4W5B='EP92]4>7!E,R]&;VYT0D)O>%LR("TR-2`Q,C,@.#1=+T9O;G1-871R
M:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-C<@-3`@,3`U(#DT(#$P,"`Q,#$@
M,3`S(#$P,R`Y-R`V-R`Y,B`Q,C@@.#@@-C<@,3`U(#<U(#$P,B`V-R`V-R`X
M-2`Y-B`X,2`Q,#(@-C<@,3`V(#8W(#8W(#8W(#4U(#8Q(#<U(#0Q(#$Q,R`V
M-2`U,B`S."`V,"`W,2`Y-R`S."`W-2`V-R`U,UT^/@UE;F1O8FH--3,P(#`@
M;V)J/#PO5'EP92]&;VYT+U)E<V]U<F-E<R`U,S(@,"!2+TYA;64O5#<O16YC
M;V1I;F<@-3,S(#`@4B]&:7)S=$-H87(@,"],87-T0VAA<B`U,R]#:&%R4')O
M8W,@-3@Y(#`@4B]3=6)T>7!E+U1Y<&4S+T9O;G1"0F]X6RTS("TR,B`Q,#$@
M-CA=+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-3$@-#8@-#8@
M,S@@,S<@-#(@-#8@,C@@-#8@-#8@.#(@,S`@,C@@-#(@-#8@,C,@-#D@-3$@
M-C8@-C@@-3D@-#(@-#(@-S`@-C(@-S0@-C4@-S`@-#8@-C@@,S,@-CD@-#0@
M-3<@-#(@-C@@-C(@-C`@-S`@,S4@,S<@,C@@-C@@-C4@-C@@-3$@-#8@,S<@
M,S<@.3$@-#8@-38@,C@@-#)=/CX-96YD;V)J#34S,2`P(&]B:CP\+U1Y<&4O
M1F]N="]297-O=7)C97,@-3DP(#`@4B].86UE+U0X+T5N8V]D:6YG(#4Y,2`P
M(%(O1FER<W1#:&%R(#`O3&%S=$-H87(@,3DX+T-H87)0<F]C<R`T-S4@,"!2
M+U-U8G1Y<&4O5'EP93,O1F]N=$)";WA;+34@+3(S(#DP(#8X72]&;VYT36%T
M<FEX6S$@,"`P("TQ(#`@,%TO5&]5;FEC;V1E(#0W-B`P(%(O5VED=&AS6S(V
M(#,V(#0U(#4Q(#0P(#0X(#4Q(#(V(#4Q(#0P(#0X(#0U(#0U(#(X(#4Q(#,V
M(#,U(#4Q(#8V(#8V(#4Q(#4Q(#0X(#0X(#0X(#<V(#(U(#8V(#8T(#(U(#4Q
M(#,P(#,S(#8X(#(U(#4S(#8X(#0P(#8X(#(U(#(X(#@S(#0U(#0U(#8R(#8Y
M(#,U(#,U(#DS(#<Q(#4Q(#<Q(#4Y(#8X(#8W(#0U(#0U(#0U(#(U(#<Q(#4W
M(#8X(#<Q(#(U(#0U(#(U(#0U(#0U(#<Q(#8X(#8R(#0U(#0U(#0U(#0U(#(U
M(#0W(#<Q(#0U(#8X(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@
M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P
M(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@
M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P
M(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@
M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@-S9=/CX-96YD;V)J#34S,B`P(&]B
M:CP\+U!R;V-3971;+U!$1B]);6%G94)=/CX-96YD;V)J#34S,R`P(&]B:CP\
M+U1Y<&4O16YC;V1I;F<O1&EF9F5R96YC97-;,"]#0B]$-"]#4"]$-B]$-R]#
M5"]"1"]"02]"1R]"1B]#-2]$."]#6"]$0R]$,R]$,"]$.2]$,B]#02]#,"]"
M62]#4B]$02]"6B]"6"]$,2]"5B]#-R]#4R]"5"]".2]"5R]$1"]#-"]#5B]#
M-B]#."]$0B]#.2]#,2]$12]#52]#12]#0R]#1"]!0R]"12]"-"]"-2]#1B]#
M5R]!0B]"."]#45T^/@UE;F1O8FH--3,T(#`@;V)J/#PO3&5N9W1H(#(S-"]&
M:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(EDSL%*PT`0!N`M.13FDJN'
MTIT7L$GH$@P4`K4%<Q#LR0?0'@NM*'BR*3WH8Z7T11;Z`CGF$#+^JT74G6&_
MR_`OOTDYYHPO$S89IV-^3&A#)F:WJ>%LE.`VBC/,%3^L:%I0=,\FIN@&=XJF
M=]><4%3<\O/3RY**&0FFQ+,*5'^1GD\7^+1]GR;TJ?69'>C46DNC.)=ZHG*Q
M`@Z.O91;"4#7!VT(D"[E"P3/6(T^-@?5#\@$_U&NCT<3GGK@^)M:O^^^L8Y*
MAP=')1]#;;N+H:Y?)X.\46]JVRK\@9)[H7E!"_H48`"$@N4.#0IE;F1S=')E
M86T-96YD;V)J#34S-2`P(&]B:CP\+TQE;F=T:"`Q.3@O1FEL=&5R+T9L871E
M1&5C;V1E/CYS=')E86T-"DB)=-`Q#H(P%`9@B(/)6SB"[P("':@ZD:`F=C#1
MR0.HHX-&9W3B6A@N@C=@9"`\'U6)&/L/_?(G'?I7!NBC:(Z10"EP)^`(@>3N
M-U4$KL"A[_H3SABW!X@4>!L,)'@+O@!>M)HBHY9X/EWVH&9`ED[]HOJ!\D%E
MEWV&['+0<"M#2D.Z%W$'TN1$UYBR1X>LQ:*6Y)LDH=IFG`ZDX50],_PV(X5C
MAI<8X25&>(D1BXR\E_SELT2WE+\]-@!S!6MX"C``<F)/)0T*96YD<W1R96%M
M#65N9&]B:@TU,S8@,"!O8FH\/"],96YG=&@@,3@Y+T9I;'1E<B]&;&%T941E
M8V]D93X^<W1R96%M#0I(B62./PK"8`S%O]*AD.4[0G,!^W^PDU`5["#HY`'4
MT4'1N2T.7JO@1=H;=*Q8^DQ1$#'DEY#W2$@4L,<QCWR.)#W>^72D<!"]08D=
M7SS'BR7&O#U0DI*[X3`@=R$^N<EJRM+2)9]/ESVE,P*J":`T.F6AU5<9:Y2H
M4$@UD?<F5&<)&D:K838V;@(J^[U9?LBS7Q3^,;X\"^`A-#E0E\!=L*JLUTW6
MVJU=9IU2Z.6EX3C-4UK32X`!`':?@^`-"F5N9'-T<F5A;0UE;F1O8FH--3,W
M(#`@;V)J/#PO3&5N9W1H(#(U."]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A
M;0T*2(ELT$%*Q#`4!N"4$0)ODR/T7<!IXY2Q`T)A5+`+P5EY`'7I0M%U*Q[`
M(UE77J/@!>(NB]+G>X5D+!KH!TV;__5OL<8<"SRT)19'N+9X:^$!5B7OYGB\
MP6)IY>$RW_`J\>8>MC5DU[@J(;O@%R#;7IVBA:R^Q*?'YSNHSX!X?0JOPH*O
M\1\&/<.;.2GC]E1,OZ=AN@D9T0HOD44<JP.#"4S!/F:Z)L3U%.(^IF__EA#9
MU#QH-,R0\B!?!5S3RJE$#B12EM&"X7YCROB*<0G3JQ--K3K0I)32I$>EWPQU
M2K^3XWOR*A7FG2._BD>ZYB]M_!E3A2\B.*]A!S\"#`#/$$1C#0IE;F1S=')E
M86T-96YD;V)J#34S."`P(&]B:CP\+TQE;F=T:"`Q-SDO1FEL=&5R+T9L871E
M1&5C;V1E/CYS=')E86T-"DB)S-"Q"L(P$(#A*P["+3Z"]P(V::%-G82J8`9!
M)Q]`'1T4G=-'\U%\!$>'TIAXG41N-O#!?\F4*RO25`3&4)G3(<,SFCS,.HY%
MFM%$IWH:3D7[$]86U8Y,CFH5WE'5FSEEJ.R:KI?;$>T"?0>01#$@\FV8VOZ&
MGWS;\^V`_8C7D$GQ'#$I'F,FQ7W&I&@<DP+B\6)T"9-"V,K_KP<<:P!<%'_N
MX#L^/"XM;O$MP`#R1)+"#0IE;F1S=')E86T-96YD;V)J#34S.2`P(&]B:CP\
M+TQE;F=T:"`Q-30O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB),C95
M,%``81-3!3,CA11#KD(N$P,%$`1R3?4,%70-]`PL@<!"(3F7R\F32S]<P<2`
M2]\#*,^E[Q3@K&#(I>_IJU!25)K*Y>G"]?\?`P/C_S\,#`P0`LS]_P>(__]A
M1B%^L&,2'_@QB0?RF,0!>TRBH1Z38/B/0?QCQ"307$8[YS$`B08&(,F`3/S_
MS^7JR17(!1!@`"Y0]KX-"F5N9'-T<F5A;0UE;F1O8FH--30P(#`@;V)J/#PO
M3&5N9W1H(#(V-2]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(E\T;U.
MPS`0!_!8'B+=DD?(O0!-4I&(3)8*2&1`@HD'H(P,()B;1^-1X`TZ>K!\W#].
M45651(I^\L>=[^RNXYI;OEAS=\G=FK<-O5';ZV2-F7;5Z-JJ[O6[XN=7V@Q4
M/7';4W6GZU1M'JZYH6JXYX_WSQ<:;DABEF569#+;B018S.-<%X*5O4G&+"D'
M1PWPNNG+_6,ILB^6_=9_=.=%0<CUITQ&DT0)J`%'0:2$"(4H3V,"MLO<#BQG
M'?HV*4P->3+:(W&&.?'X&G#VDIH\'C1GU%K#DMJF-^(F;2Q/=.@QV.!P17#4
M1PS6[_"8T7B9'M7\0+T2-(2<>=(70K<#/=*O``,`?-=O]PT*96YD<W1R96%M
M#65N9&]B:@TU-#$@,"!O8FH\/"],96YG=&@@,S(P+T9I;'1E<B]&;&%T941E
M8V]D93X^<W1R96%M#0I(B63204K$,!0&X)0N"D'H!83F`DZ;&1DZ(`1&!;L0
MG)4'4)<N%-T)54;HM1QZD>D-NNPB)/[MJ\W$"3SR\1+"'Y*5%)F0N3B;"YE)
ML9R+1\E?>+Y`.Q/+<ZS-)%9GV0HC%P_/?%WP]%[D"Y[>8`-/UW>70O*TN!5O
MK^]/O+CBGRRPC$4H!1K&0E3"!D9FZ(9_-*RT76#M/K0&4Q>B$F*$4JY;_J<&
M6SMU#]@06T<<;^LC_H"58T3\!N.)9N0)F$S4:J`Y]8A@/?6%1P3KV7V,9`,;
M8JN)EMD]6!,;QQU8$6LP(F[!F%CIT(R,P62B)IH$5!/[8*!6APSZ8&!7'M`$
M#;&U'FMBX[@#*V+MN`5C8H6KCHS!Y(AX<J8<2Z+R:8FEQV"D]1@2`\<O,")N
M?5*PX2,0^77!-_Q7@`$`:`L&'PT*96YD<W1R96%M#65N9&]B:@TU-#(@,"!O
M8FH\/"],96YG=&@@,C@U+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(
MB8S2L4[#,!``4%<9(MV`/R'W`VT2VD3-%*F`1`8DF/H!P-@!!'."&#KR2ZGZ
M(^X?A"V#E>-L1U4;@H0'/^DNEYS/26*,<#K':9QA,L=T@4\QO$"2<CC")2<N
M9YG)SJ*,UQ(?-[`J(%QCDD)XRT]`N+J_PAC"X@[?7M^?H;@&XJ6%V:D6@4$(
MG_?.(\^D).V8-B?%-#E5C"K)5-0]9.'$Q&'J/HBVY")#.N^_:/\W6O`*J!V#
M6DF-0^5'.'(.]SV`$SWV>&-P?O(WMN&*1M'^M^-@)G!.*_<#N*B5VQ.T_')(
M0W<1V$&(W%*5EOHX)#[S",$)A\92\UV:]ARB*2VJQUV7P]]9/O?N)W'?4?V;
M;37!30$/\"/``'43RPL-"F5N9'-T<F5A;0UE;F1O8FH--30S(#`@;V)J/#PO
M3&5N9W1H(#(Q."]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(E4S+U*
M`T$4!>"5+19N<Q]A[@LDNVL&UE0#4<$M!*U\`&-I88B0;B,6EKY2P"*OL2$O
M,'93#'.\:_PAM_@NG`/'GDHEC8QJL59L)?.:GFC2:%B)K:49U]J-JZG>F=P_
MTJRE\DXF#957VE,YNSD7?>VU+!?/#]1>$%X17<H03,PZSV'E//O@>MX%T_,^
M&%]\>!-XZTWDMQ\2<^]^V72)C6+PS1K_1(>3(U*.T!WA$8L#GP.[/_8#VP.I
MP/L`(^4ZC%SG\!(Z8),!Z',E,D"7+=W2EP`#`%QDF(\-"F5N9'-T<F5A;0UE
M;F1O8FH--30T(#`@;V)J/#PO3&5N9W1H(#(W.2]&:6QT97(O1FQA=&5$96-O
M9&4^/G-T<F5A;0T*2(ETT;%.A$`0!N`A%"33\`@[+^`!AN.D(CDUD<)$*UL3
MM;30:`UJX6OMH_`(E%N0'6=G*3QS4O"%V=W)SL^VHI)V=')*VX::FAXK?,&Z
ME6))34.[325KF[*5YXP>GG'?8W%'=8O%E:QCL;\YIPJ+_IK>7M^?L+]`9IZ,
MES>/Z3(P>TB<?#B`69B-O0\[!@>"Y241OM@'4L5GD3P4>%DQBEOIF#/I=8Q)
MR(]A(GJ]`S)E3B)@(BG'2\L$O(!6/4`>J@!Z9(Q[IL@"L8&-N(@'A0\9_^)6
M!B7D]/$/D^;TFTR1U"1-3<T.&I<0XK*=QC5V/(?N1L]\9J$7?X,/=\]''2BW
M.J69(<34Z2]AO.SQ%G\$&``%\'0?#0IE;F1S=')E86T-96YD;V)J#34T-2`P
M(&]B:CP\+TQE;F=T:"`R-#4O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-
M"DB);,_!2L0P$`;@EAP"<\DC)"_@MH6N=$^%5<$>!#UY%=2CH(O>A-;3'GVE
M++Y(?8,><PC]G5F+"VL3^!@FF62F/'4Y[Y.B<N72E;E[*.B%.)3LLG+YHI##
M1;[B5;G[)UHWE-WR9<HN^0)EZ^LS5U#67+G7S=LC->>$:$<-!!U28%!#`GSO
M=D.++[\--;;>!,M:]M/7T<!,MM&,ML.D/ACT6*<L<*3!J##,&35Z^\]:2ORO
M[<&.^[3X@!2F>Y4H4_2&6T.OHQ6Y??2J;P%_QV/!/ROQW8J<A3PU:SKOJ(Z-
M>[O$_)E,L7Q"%PW=T(\``P"3[@4*#0IE;F1S=')E86T-96YD;V)J#34T-B`P
M(&]B:CP\+TQE;F=T:"`R,38O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-
M"DB)9,ZQ:L)@$`?P3QR$6]+1H?C="V@2##6!0$!;:`:A3CZ`.CJTM.!D#!GT
ML1)\D0]\@8P90OZ]*"VEWO`[N#]WG/?$#@<\=-F;L.?PVJ5W&OLR=-AS.1BY
MDHV<0,KGU9:F,=E+'OMDOTI.]O1MQM+B.7]^?&TH?B8@!="H!*B4#Y3A0P(#
M%:%HR7!(T!6:GE!;0B7@2JE_,!H=F$C(?Y&=[G\4ZMX]E77I".>_E/J8WC`M
MN;:*EARG@39-?Z#+7?@856JODEK)#7DR`[W$M*!O`08`$\^,;0T*96YD<W1R
M96%M#65N9&]B:@TU-#<@,"!O8FH\/"],96YG=&@@,3@V+T9I;'1E<B]&;&%T
M941E8V]D93X^<W1R96%M#0I(B6S-,0K",!0&8$N'PEMRA+P+V":VI74*M`IV
M$'3R`.KHH.@<-Z]5</`:$2^0,4-I3.EF_(?OP?L?O+1$A@5..68SS!@>.)PA
MS=V28<:QB+GK8C9W*7%_@JJ!9(=I#LG*]9!4FQK=:-9XO=R.T"R@)S:T76@F
MU@1Z(K521KQ5W=&/B@Q]*J+I2U%%'R-""=(*+4DKC778$7JW+C\$/GWHTT4^
MAOAH^@<Q((>3X04L&]C"5X`!`%:BJ:0-"F5N9'-T<F5A;0UE;F1O8FH--30X
M(#`@;V)J/#PO3&5N9W1H(#(P-2]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A
M;0T*2(DLS3%JPT`0!=`5*@33[!$T%XBD1<9V*H&2@%4$XLH'L%VZ2'!J;4BA
M,E=2R$5T!$$:%4+??\$+;Q9VV/_+C1:ZU@>GY497A9Z<O$OI^%CHRNDZ<]QE
MQ2//5H\7J1O)#UHZR7?<2UZ_/2FOYE6O'Y]G:9X%\"T6DV(R%F.58,`??NF+
M\YLS1A0L,6)*Z(?X);`4`<8$+;RIT#-KX"+DP=-(D_VGGCQFZ]O9&DQI$&&J
M8A9W&-ON7CZP8#0)(U+F`O+2R%YN`@P`A4%V^@T*96YD<W1R96%M#65N9&]B
M:@TU-#D@,"!O8FH\/"],96YG=&@@,3DV+T9I;'1E<B]&;&%T941E8V]D93X^
M<W1R96%M#0I(B;20,0Z"4`R&,0PD73@"O8#`\R'!B00UD<%$)P^@C@X:G<&;
M<12.P,A`^*W/`6-TM$V^H1W:_XNF'++F\80CQ;'B@Z(SZ42&(<>:M:]DYX<S
MJ83W)\IR"G:L$PI6LJ<@V\Q949"O^7JY'2E?$/H1@,9*@<IR@;)S`%NZ=W!'
MYZ)"ZZ$NVA1-T0C2NI#)@$K@#BB!SOD)2V#_&5^/RVO.QZ=O.2269[(9F+PF
MN7%@;+R\&$/&U=,:+7/:TD.``0"]6=]Z#0IE;F1S=')E86T-96YD;V)J#34U
M,"`P(&]B:CP\+TQE;F=T:"`R-#8O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E
M86T-"DB)G-&];L(P$`!@(X9(M^01?"]0DI#*M),E?B0R5*)3'P`8&4!T3K:^
M5K:^!A(O$#8D$%>?SZ"F76@M69]TISO[;#/`%'-\Z*,Q:/JXR&`-)G?!%,TC
MYKW,Y7KILUM/.%_!L(#D#4T.R=3E(1G.1IA!4KS@=O.^A&(,RBU+1&PWJ,J@
MYH"F*G96EIJN>.Z(%R42%["_MA;KJ_$_U>U^MUVVSK_>YQSNV40BEU$E<[&<
M9CM>>Y&XI=J*.QWJP]S'J-WW-O^/=_B[Y;V>@@?1'F3N;RK_-GO_:[46=_K3
MV\0?WJ/BB<@UT%ZJ2Y@4\`I?`@P`Q1M8&`T*96YD<W1R96%M#65N9&]B:@TU
M-3$@,"!O8FH\/"],96YG=&@@,3$P+T9I;'1E<B]&;&%T941E8V]D93X^<W1R
M96%M#0I(B3(R53!0,`=B0W,%8TN%%$.N0BY#`P40!'+-]0P5=`WT#"R!P$(A
M.9?+R9-+/US!T(!+WP,HSZ7O%."L8,BE[^FK4%)4FLKEZ<+U\/^!_PWU#/80
MV%!_X/_#_\0!;#JY7#VY`KD``@P`(V=+@`T*96YD<W1R96%M#65N9&]B:@TU
M-3(@,"!O8FH\/"],96YG=&@@,S,T+T9I;'1E<B]&;&%T941E8V]D93X^<W1R
M96%M#0I(B831,4O#0!3`\1<#!F[)ZI;[`C9-%$FA<%`5S"#4R0^@C@Z*KDW`
MH6._4L6A7R.E7R#=,AQYOGLO+9@,!H[\[BX9_G>3"SW6J3Y/]62LKU+]G*@W
ME66T2--+G8X2VAN-)_1D^NE5S7(5/^HL4_$=[:MX-K_6B8KS>_WQ_OFB\AL%
M`%@"F`;@7UHPB!`BEF$+!;UH6AD\L"Z$$6)#W]'*FEC+IN.^8RB,CEQWW'4,
MCBR%52C<#'CF,^M`N.JSG7I"7TB_-!TCIIV"T$.[`&R)MJ-A-@LHF$!9PE9H
MBP--QST%.M*F(QU#CSNJ8I;&<3_@AJJ$D>/6<<W<"9=8!<)P18$_CA5S(PRI
M51A$%,BLF:LC/>&IH4!F<^(8]4GWV0+3,LV`*#?]ARVSZ--S54QD8I^^JQ)^
MT?@><$EC*W19[AC4;:X>U*\``P`(W@8*#0IE;F1S=')E86T-96YD;V)J#34U
M,R`P(&]B:CP\+TQE;F=T:"`R,3,O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E
M86T-"DB)Y-`["L)`$`;@65($ILD1,A<P#Q6CE>`#3"%HY0'4TD+1.BD\6,3"
M:W@$2XNPOQ,?B(V=E0,+WS#[[[*;M"22NJZD(:VF+&)><Q)K'U5M/8BE%@51
M1ZLM\Q7W4@YGDL0<CG3.86_2%VW2L6PWNR6G`P9*`Q"TSM2]D*\@\G/R`&M*
MC^`"5P][%T?@XD,'!]V;6>I"DP5*RJI\7L$JC`(?<.YW&%A'CWRBRIY>P,^0
MZV,>]0V/S?8%T#O^ARCO7P'*B-R<G(+,%_`PY2G?!!@`PQU_70T*96YD<W1R
M96%M#65N9&]B:@TU-30@,"!O8FH\/"],96YG=&@@,3@Q+T9I;'1E<B]&;&%T
M941E8V]D93X^<W1R96%M#0I(B3(U5#!0,`)B$PL%,Q.%%$.N0BX3,R#?`,0U
MTC-4T#70,[`$`@N%Y%PN)T\N_7`%$S,N?0^@/)>^4X"S@B&7OJ>O0DE1:2J7
MIPO7____&/\#P0,&>R#)P"`/$OC'____#_[_[?__?Y#_WPR4K/_'_/__`;#2
MAO]_@"0C$LG\_Q\2^M\/)O]30#("W<'`@(T$ROX!D_\8H2H'/PER,`/0_>P-
M#,R8))>K)U<@%T"``0!"[029#0IE;F1S=')E86T-96YD;V)J#34U-2`P(&]B
M:CP\+TQE;F=T:"`Q,S0O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB)
M,C)5,%`P4S`V53`T5S`S5D@QY"KD,C0$"AHH&%DHF.D9*AB;Z%D:`(&10G(N
MEY,GEWZX@J$AE[X'4)Y+WRG`60'(\?15*"DJ3>7R=.'Z7__/_D_]C_\?@?#Q
M_\/_CP-A/QC*PZ'`?X9Z!GL&^08P/&#_H/[#?RY73ZY`+H```P#0,33C#0IE
M;F1S=')E86T-96YD;V)J#34U-B`P(&]B:CP\+TQE;F=T:"`Q,#(O1FEL=&5R
M+T9L871E1&5C;V1E/CYS=')E86T-"DB),C)5,%`P5-`U,E8P-%4PLU!(,>0J
MY#(T`8H:*%@:*ACJ@27U#"R!P$(A.9?+R9-+/US!T(1+WP.H@$O?*<!9`4AY
M^BJ4%)6F<GFZ<#$P0^#_PT,!PES+Y>K)%<@%$&``G6VCPPT*96YD<W1R96%M
M#65N9&]B:@TU-3<@,"!O8FH\/"],96YG=&@@,3DR+T9I;'1E<B]&;&%T941E
M8V]D93X^<W1R96%M#0I(B63-,0Z"0!`%T"44)M-PA)T+R(*L"50DJ(D4)EIY
M`+6TT&@-G:57HO,:&"^`'05A'$Q@$YWB%?-_\G6('DYP[*.>8A#AWH<3Z("?
M'FI.7)\SUXOX0MP=(4E!;5$'H):<@TK6,_1!I2N\G*\'2.<@A*R$_+>QJ!'4
MVD3V5X=:JY-8V<L%-J<V[BVR)AN,:[:,:^JMY-OH/-G:>0TVHX?1OK&M?3=:
M/,[#TIC'OQ:9L:1?NUE8I+"!CP`#`'=@P"X-"F5N9'-T<F5A;0UE;F1O8FH-
M-34X(#`@;V)J/#PO3&5N9W1H(#(V-"]&:6QT97(O1FQA=&5$96-O9&4^/G-T
M<F5A;0T*2(E<S[%.A$`0!N`YM]ADFGT$Y@4\P`#1BN341`H3K7P`M;30:`U7
M\1B^"MV]!ITM)<7FQG].,>8@^3+#SN[^E+ED4LKIF12E5(4\Y?S*12;V5I64
MZQQKZ^P"S[D\OO"FX?1!BHS3&ZQSNKF[E)S3YE;>WSZ>N;EBC4Z_=*1VIQTE
M_9XH]-%%Y^>@G9]J'?W8ZF3,?E"-QMYO?]$?5J`_@L#N'RWH:I1=8@0PV.!`
MZ$=".1'*F<AI)/3(@DV@1C2LC,AF'X.->P3`(+8;DQT4_]C;C4J?1K+0'1$6
MM@?\@K,#W<I^D`ZT&H,%2TZ\3C7ZH0T(I,%")S.B(&"M?-WP/7\+,`"=F-H>
M#0IE;F1S=')E86T-96YD;V)J#34U.2`P(&]B:CP\+TQE;F=T:"`R,3`O1FEL
M=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB)K,^Q#H(P$`;@U@Y-;N$1N!<0
MJ"D1)Q+41`83G7P`=730Z`R/QJ/P"(P,I/4*)ACC9.SP#;U>[[]8880SG*H$
M]1QUA"<%5]`QW488)S@+E"L&T8).@L<+9#F$!]0QA!MZ`&&V6Z*",-_B_?8X
M0[X"(SIA+1,U*\B*^:1HI&43GPHMW7+;,6M+:SA9.*O"4$^=]OJCS:`WV@[*
MG_0^?VO>9@W3J_25A_<)*2<G73Q#^:4U0C8>6;*4=#L.^[K>?]AQ)V/RJ[#.
M80]/`08`2YGW]`T*96YD<W1R96%M#65N9&]B:@TU-C`@,"!O8FH\/"],96YG
M=&@@,C$U+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(B73-L6[",!`&
M8%L,2+?D$7PO`$G`E<H4E+92,R#1J0_0,C*T`HDM>;0\BGD#CQFL7'^;(C'`
MV?HLZ\Z_[1,7O.19R=:R+?F[I!_"66#9!2_G)7KS8H5ZYJ\]U0WEGQBD_!U]
MRNOM"^/2;/CP>]Q1\TKBIH)2&@2E6I'!."/BJR&#)J#MLG$2E8OZJC?28;Z*
MAC:*>J!2P"?[I*KB*YT2IM%+FDMI?4J[W?BN"^U=U=7NWQ'V;5B?D#:XD_CL
M[+0,:N(U>AF^D[X*1NBMH0_Z$V``&7;##PT*96YD<W1R96%M#65N9&]B:@TU
M-C$@,"!O8FH\/"],96YG=&@@,30T+T9I;'1E<B]&;&%T941E8V]D93X^<W1R
M96%M#0I(B3(V4S!0,`)B8V,%$P.%%$.N0BYC0R#?`,0UTC-4T#70,[`$`@N%
MY%PN)T\N_7`%8T,N?0^@/)>^4X"S`I#CZ:M04E2:RN7IPO6/_8,]`_L!?@;V
M!G8&=CYF!C8;QA\L-8Q_@/@?PQ\@_L?\C_$_.Q#W`_%_,&:F#?X#-)N!@1$%
M<[EZ<@5R`008`,`1;VX-"F5N9'-T<F5A;0UE;F1O8FH--38R(#`@;V)J/#PO
M3&5N9W1H(#(P."]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(D\S#%J
MPU`,!F`E#CS04!]!ND!C/SN$>'J0ME`/@63J`=J.'5K:V8$,.4:N8LA%W!MX
M]&">^C>!"#X0^L5?+C774N^]EH4NO+YY_N2BPC'71:'EW".;YQ5FI:\?O*XY
M>]&BXNP9.6?K[8-ZSNJ-?G_]O'/]R-:&4R0G`TVE#ZW\6B]G&^4`1XOB+NPF
M@0E08[9/`4M+SCI*K">R@:B)1`&!V`C6XFM(3S8ZL7B!PXV[2A.+_]`]HGL(
M,^F:._0)>D,GQD\U[_A/@`$`4]QH*@T*96YD<W1R96%M#65N9&]B:@TU-C,@
M,"!O8FH\/"],96YG=&@@,C`Q+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M
M#0I(B73./0K"0!`%X(B%,(U'V+F`)IM$U&K!'S"%H)4'4$L+1>N->+$<)=X@
M98HES\E*P,89^(H9=N>E$4<<\TAS,N54\TG3E9()M^,TYGBL93>.YE(S/EYH
MD5%XX&1"X4;V%"YV2]849EN^WQYGRE:$I@>@"@Q0!$,@=P.@+^V&>,(I%*A;
M*H/2EAZ+TA16)IY<4#DZ`H_4+W(!?\D]MJ/H4'+-TYA*"1+#64GE;#-`#?3P
MEB?F!91M\#I0WQ]IG=&>/@(,`'"%G?T-"F5N9'-T<F5A;0UE;F1O8FH--38T
M(#`@;V)J/#PO3&5N9W1H(#(P,2]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A
M;0T*2(GLT;$*PC`0`-`3A\(M_83>#]@V54*=A*I@!D$G/T`='12=6_#'!'^D
M_D%'A]+STE#HXN!N(#QREUS@3J<4TYA&">D)Z80."L^HE01C&QF'2G)A/)65
MTOZ$F<%H1UIAM)(\1MEF3G(P:[I>;D<T"P2`H`'POLD0,%?`7,R8ZZ&S\9SL
M__W5A^U?T#-PECUKR56=\N:=R^Z4WE?L9O$2&_$ILLSH;BUR.QXI[-L2=GA@
MO^8:(.?VXJ"%2ZG(N#2XQ8\``P`%.'@X#0IE;F1S=')E86T-96YD;V)J#34V
M-2`P(&]B:CP\+TQE;F=T:"`Q,S<O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E
M86T-"DB),C)5,%`P5S`V53"T4#`S5D@QY"KD,C0$"AHH&%DHF.L9*AB;Z%D:
M`(&10G(NEY,GEWZX@J$AE[X'4)Y+WRG`60'(\?15*"DJ3>7R=.%Z^/_`_X9Z
M!GLPE&^0/R#_4/X_'/ZS!\$_]7_J?]3_^/\1"!__/_Z____]_URNGER!7``!
M!@"&83/P#0IE;F1S=')E86T-96YD;V)J#34V-B`P(&]B:CP\+TQE;F=T:"`R
M-S<O1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB)M-&Q2L1`$`#0#5L<
M3+.?L/,#7A(QJU:!4\$4@E9^P&EYQ8G6%PCX7='[D8`_$+!)<62<V4W.$&Q-
M,CS(;#8S.^<I)ICAR2FZ#-T9/J6P!9>@W,YAMDPYMTPN^;K`]096!<2/Z!*(
M;SD/\>K^"E.(BSM\?7E[AN(:B*BV],T<E*8OME&*]FRI5"XJT]I*TM0;3=1Q
MO'.TANB3;2P'6^?\CBUW88V2+37U49`?HE[[E'?!DJ9VU`0;;W64B_O#/95S
M\ZG\^W^T5LJ4<^VOU$:A3F[VJ`DV,WW_$[M1'3Q$P7[0GVLW.>?QW&4.HFPD
M\^CX@P\M<]N1KJ1RTRV&N=IASGF8>Q1:\R7"30$/\"/``--!CM4-"F5N9'-T
M<F5A;0UE;F1O8FH--38W(#`@;V)J/#PO3&5N9W1H(#$V,B]&:6QT97(O1FQA
M=&5$96-O9&4^/G-T<F5A;0T*2(DR-50P4#!6T#54,+%4,#%02#'D*N0R,0,*
M&BB8&"H8ZQD"Y?0,+('`0B$YE\O)DTL_7,'$C$O?`RC/I>\4X*P`I#Q]%4J*
M2E.Y/%VX_C'__\_XGX'Y?P,V\@?S_S^,__\P___'^!^B<L#)?Q@DT(7_8>0/
MAO__&_]_9*@'DH^!?CA0WPXD'S#P,X#DY('D?P:@.5RNGER!7``!!@",ZZE.
M#0IE;F1S=')E86T-96YD;V)J#34V."`P(&]B:CP\+TQE;F=T:"`Q,S,O1FEL
M=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB),C)3,%`P!F(C8P4S(X440ZY"
M+B,#!1`$<HWU#!5T#?0,+('`0B$YE\O)DTL_7,'(@$O?`RC/I>\4X*Q@R*7O
MZ:M04E2:RN7IPO5/_O\?_O\_V/]_8$8@(!<H")0B!OQC_M^`A'XP___##!*D
M.OK#^)^!@1^.N%P]N0*Y``(,`#"*CT8-"F5N9'-T<F5A;0UE;F1O8FH--38Y
M(#`@;V)J/#PO3&5N9W1H(#(T."]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A
M;0T*2(ETT+%JPS`0@&&9#(%;O';SO4!CFS0B@4`@;:$>"NV4!V@[9FA)UMB0
MH:^5T!=1WT"CAJ#KG5R#752!]'$(Q(_T'`N<\M8WJ&?X6L([Z)+G0L;II,3K
M8E(L>,WQ90OK"O(-ZA+R![Z'?/UTBSQ4C[C[V+]!=0=$9&L*ZZ]F%?>4Q6W2
MN&H<U5^-HEZ6251W4%'M085@2T,-J1#\3<W`,S4A^.LWO/-(IQ#\26;@F$P(
M3LGV]:P$^XQ<WXM2*HGH6`EV-?F^5JPEFZBO$5>232&\\RQFDMW^?.=13%LY
MW">M3MYJ1J3XUPT?_PGW%3S#CP`#`*H<E;\-"F5N9'-T<F5A;0UE;F1O8FH-
M-3<P(#`@;V)J/#PO3&5N9W1H(#$T."]&:6QT97(O1FQA=&5$96-O9&4^/G-T
M<F5A;0T*2(DR-5<P4#`&8E,C!3,CA11#KD(N$TL@WP#$-=8S5-`UT#.P!`(+
MA>1<+B=/+OUP!1-++GT/H#R7OE.`LX(AE[ZGKT))46DJEZ<+%P,#`_/___^Q
M4O\9Y$'D_P;[X4_]J2=(_4"E_F.A/F"C'J!0!R!4`X1B`%/_(-0/1G"0'V`$
M10`#`PZ*R]63*Y`+(,``US=,+0T*96YD<W1R96%M#65N9&]B:@TU-S$@,"!O
M8FH\/"],96YG=&@@,34X+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(
MB3(U5#!0,`9B$TL%$P.%%$.N0BX3,R#?`,0UUC-4T#70,[`$`@N%Y%PN)T\N
M_7`%$S,N?0^@/)>^4X"S@B&7OJ>O0DE1:2J7IPO7/_9_C/__,[!_8+`'D@<8
MY(%D\P]^(,G_A_W_#S;[?\S__[#4`\E_+/7_@23#__^,_T%ZT$CFP4+^800Y
MDH&!O8&!&9/D<O7D"N0""#``#ZJ:*PT*96YD<W1R96%M#65N9&]B:@TU-S(@
M,"!O8FH\/"],96YG=&@@,3DQ+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M
M#0I(B3(S4C!0,`9B4PL%,R.%%$.N0BY34R#?`,0UUC-4T#70,[`$`@N%Y%PN
M)T\N_7`%4U,N?0^@/)>^4X"S@B&7OJ>O0DE1:2J7IPL7`QC(8Z7^`]$_(&ZP
M____`83ZP`^F_D"H?RC4?ZQ4/T[J.!`2I/Z#J'9L%#N8^@&F&!AP4U`E,`W8
M#3O^_R,VZC$F]1^-.@RACJ-0[=@H=DA@L2.'&30@H<%Z@!\2Y/R0".#'&BM<
MKIY<@5P``08`V%,<WPT*96YD<W1R96%M#65N9&]B:@TU-S,@,"!O8FH\/"],
M96YG=&@@,C(W+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(B:S/O6K"
M4!0'\!ON$#A#?0,]+Z!),($X!6*%9BC4R0>P'3M8ZAJ%@,\5</`UI+Y`W#($
M_SW'ZR!TDUXNO^'<\W7CE$,>\S!*.98;\GM$*XH3B8:<I#P>1?HX"B=R4EY^
M4EY0L.`XH>!%$BC(WZ8<45"\\O?7^H.*9P(\G(#69'O@:`;B=M/;:_A0X6)Q
MJM#Y.%NT/;06S0"=Q=&9J76F:?5&W=X+U3RDJ[WOYOK?9EUUT]T^;C>QL;KM
MC\7%P\[*7\HGL39]L3&EU;Y2BVO_?['S5&/\O]*LH#G]"C``,4L"0`T*96YD
M<W1R96%M#65N9&]B:@TU-S0@,"!O8FH\/"],96YG=&@@,S`V+T9I;'1E<B]&
M;&%T941E8V]D93X^<W1R96%M#0I(B6S2P4Z$,!`&X!*,F%[J&]`7<(%-EK`G
MS*J)'$STY-5$/7K0Z!D2#[S6)KS(\@8]<F@Z3J?`KL`D;;]I>^F?9FL9RPV.
M;2+3M7Q+^"?/4NQCVVY6B;R*5_$6*Y.O'WQ7\.A99BF/[O&<1[O'&YGPJ'B0
MWU\_[[RXY6`8`RS%`LN2Z(-V/!QW]TC<)J)Z5F*)%Y;=-=)<AA.^Y'@KGE`=
M\KYWI&G&EDASNR\'-D?64S:6HK(/;%1X2A..U#FQ)GH#NW*)"H@"V1I_@4W/
M3O0T(;+6P0+%2!,2=6[9B9YVS-F51+LH4!1DJ8,3MC,JT$$#+DADO4CAV!)=
MD*#/PY%G^8P-?HX27)#_"8Z_8+R>/M&C/P+&=5"Q`,D8FB$#,U(,Q)B0F"2_
M*_@3_Q-@`#HW^/D-"F5N9'-T<F5A;0UE;F1O8FH--3<U(#`@;V)J/#PO3&5N
M9W1H(#(Q-R]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(E\S[T*PC`0
M!_"(@W!+'R'W`MI4:-"IX`?80=#)!U!'!T7G=G/TE?HH%5^@8X?2,XD1J[6]
M(_QRY(;\_3$*]-61/LHA[CPX@A2H6XW^P,.^&(BQJA%N#S`)P=V@%.`NU#NX
MD]44/7##)9Y/ESV$,Z"2Z7(:I:)+%%M3:\X_YCUU;S%S*@9U4U[S9KWF$5$2
MD/.VL!)I2V,<E?S;PIH;&:6!D;%_ZIR1MD.)-:NJ8F;4HHIY;_"AS<PGFTUY
MNTG0;AR]?(6BF#%NT_UJ%F`>PAJ>`@P`)C]]$0T*96YD<W1R96%M#65N9&]B
M:@TU-S8@,"!O8FH\/"],96YG=&@@,C4Y+T9I;'1E<B]&;&%T941E8V]D93X^
M<W1R96%M#0I(B7S.L4[#,!`&X$09(MWB1_"]`$TBA29,%@4D,B#!Q(H$C`P@
MV)#B3!UYI58,O(;[!F;+8.7G0HL*5.#A]Z<[G^VJY)PKWBNXVN<RYYN"[FE:
M2S'G4HJ30GJ3_$!6S==W-&LHN^1I3=FI]"F;G1^Q;,T9/SX\W5)S3(/"PL`"
M(4&D0F30QR%*?:3AG3>)>U98N2MTRR'%JSM$-_]$"JN&!&].P6K!?`L-:P1J
MO+?]B59>^@XM#\<(*?`/XO%DK_Z$UV/*R5TXLX6DC#CSLL:B5;N0E%D[Z-\(
M9HTN&$FYK>O;+V`#O\%R!6_@6CCYFR3@%7K@'>@UZ*2A"_H08`#;`0+C#0IE
M;F1S=')E86T-96YD;V)J#34W-R`P(&]B:CP\+TQE;F=T:"`R-#`O1FEL=&5R
M+T9L871E1&5C;V1E/CYS=')E86T-"DB);,^Q2@-!$`;@/;8XF&8?8><%S-U)
M+M'&A:C@%8)6/H!:"BH*=GN0XDI?Z2"%KY&0%[ARBV5_YX*(D4SSP?S\##,K
MN>0Y'U4\.^9IR0\5O5!=\[B>5CR?5))-RE.9$[Y_HD5#Q1W7-157DE.QN#EG
MH;GFM]?W1VHN"$O(F*2`SY1'Y9%''3Y<TE$/00AZ$^S(-MB8QVPU"$E_C4!W
MOP2#I5F[O_1^Q/9^L.CP0XM]U@X&V0&2EDJR!XA.;K;XA]\1]A@@*"&-;`1Y
M=`OHI/Q*B.P[H`W/9P;H55`6&+*H'+#K@RX;NJ5O`08`.03%M@T*96YD<W1R
M96%M#65N9&]B:@TU-S@@,"!O8FH\/"],96YG=&@@,C$S+T9I;'1E<B]&;&%T
M941E8V]D93X^<W1R96%M#0I(B63/L6K#,!`&8!L-@EOT"+H7:&P'&Y))D"90
M#X5VZ@,D'3NT)+,5,OBU%#SD-53\`AXU&%]/AB[)'7S_\-]RY1)SK/"IP++"
M,L=#`=_`&;<LL%H4W"WR-<\*]U^PJ2'[X$/(7KB';//VC!SU*QY_3I]0;X&"
M"9J<&B19X03)\^4ZZ:ORHW'*A<9K.Y`WR<PO.9,RS:5C;A&:N9$EGCO21R;Q
MR"BICW0S/=.>@Z(V^4<E@YIT&A%>C4;V,C1M)SQ9:5-RVDL:XANPJ^$=_@08
M`($(F9T-"F5N9'-T<F5A;0UE;F1O8FH--3<Y(#`@;V)J/#PO3&5N9W1H(#DU
M+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(B3(V5C!0L%`P-%<PLE0P
M,E9(,>0JY#(R!`H:*)@I6.@9*AB:Z5DJ).=R.7ERZ8<K&!ERZ7LHF''I.P4X
M*P#9GKX*)46EJ5R>+EP-#.P,*(B?R]63*Y`+(,``D7X0K`T*96YD<W1R96%M
M#65N9&]B:@TU.#`@,"!O8FH\/"],96YG=&@@,C4T+T9I;'1E<B]&;&%T941E
M8V]D93X^<W1R96%M#0I(B5S0L4[#,!`&8(<,D6X@CY![`9I$#91,D0I(9$"B
M$P\`'3N`0&)SH@Q]K2"&OD80+V`V#Y%_SA41:CU\@^_\V^>BX(P7?):77%QP
MD?%33L\T+V4WX_.2%[/<%V=9*>N2'S>TK"E]X'E)Z:TT4+J\O^*<TOJ.7U_>
MUE1?$SH`3@&[46ET]KU"8*SP91,$WS9QX:<1=I[M'V,4#]5$K\<HZ;6-L:?!
M/T8B#G`AANJ(,8*/.*;!`0HND@@7N0`(1Z$U0J]"8#@1[&GH)_%(^T2,'_^4
M'C)-H\V>2ABTQ`JME.0+6F`+.=K))?B07@RJ`HR:@NBFIA7]"C``&Q#3@0T*
M96YD<W1R96%M#65N9&]B:@TU.#$@,"!O8FH\/"],96YG=&@@,S4W+T9I;'1E
M<B]&;&%T941E8V]D93X^<W1R96%M#0I(B732P4K#0!``T,2`@3V83]C]`9M$
MK:D7%ZJ".0AZ\@/4HX>*GA/P`_I+"_V1A?[`]I9`R#BSLRE4--`\FIW-[,RD
M*E2ARG-U6BY45:C+"_5:BI685XH6%F>X-BMI=59<X;50+^]B68O\6<TKD=]C
MA,B7CS>J%'G]H#X_OMY$?2L`KTC3';HH]9HH]D9-1`P)F(:6,[`4B#<G*:RA
M1P`MAM#&V(?"&'[T;(R!8U"_![4DOMCH8,.V#;_+Y\0_P3%FA\F$[1(^8I>R
M[K<9:P\%0^G'_VWI6)CL;Q,6D_OC[DTQ`^HF,]9.2HXSDSJ4VQSJVS!(:I/!
M"JAVHVU*-1N]V5*M5J]WU%(KUSVUU$G9TUA<)GMJ97>B>VK=<*Q]B\8C'5HD
M_02@E3X56)SRX*?.0K1B80>]U^W=!;=>"QNV^6:O^;NQT606E`>Z\)TYWQ/*
M[`$>+1Z5MHN[6CR)'P$&`&04_#L-"F5N9'-T<F5A;0UE;F1O8FH--3@R(#`@
M;V)J/#PO3&5N9W1H(#(Q-"]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*
M2(F,CDV*PD`4A%]P(;Q-CI"^@"8AX@\,!!P%LQ!TY0'4I0ME9COM,`N77LDA
M%TEND&4O0LIJ\``VS=?=5?6:RB8F,2,S2,TH\?N0ZEFS,44^*0Y3>L-DQC4U
M^Y/."XUW)AMKO**O\7SS:7@4:_-U^3YJL5"@CSO:'D*X@&BDBU#)3X2'?.2X
MBEC\.O$Q(D0-^B60XP9X`5X`VIQPEFB\7GN4'N_$.O];^P*+6&:=Y;VQ+/5@
MJ3P@)$#EI(>RE3[^.@DY(!$'KI;X!W19Z%:?`@P`4FBD^PT*96YD<W1R96%M
M#65N9&]B:@TU.#,@,"!O8FH\/"],96YG=&@@,C$S+T9I;'1E<B]&;&%T941E
M8V]D93X^<W1R96%M#0I(B930.PK"0!`&X,)"F,8C9"Y@GCZK@`\PA:"5!U!+
M"T5K%0NO9<A%X@UBER)D_8<,Q$(+%[YFYM]9=H(^N^P%W/9][G2Y-^"-1WL*
M?)1='DK/]J1KNT.<`:]W-(K(67'@DS-#@IS18LP>.=&<CX?3EJ()&6,*R.$%
M"=RA94QIH16B)<[&9"@_(88;-"LEHH6P-`H9XJE`Y*%7KJJAY*HJ6K7<JF5A
M+0UUI'J<J]&?+A_/7+\\^:_;#XE^*=:-B$S)(F5;!91AQ0!-(UK26X`!`'(X
M0-8-"F5N9'-T<F5A;0UE;F1O8FH--3@T(#`@;V)J/#PO3&5N9W1H(#(P-B]&
M:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(F<T+$*PC`0!F#$H7!+'Z'W
M`C9M`]I.A:I@!T$G'T`='12=BW3PM2Q]D?H&CAU*XYV)5$0<#'Q#<I<+^>4(
M/?1Q$`0H)0Y#W/BP!QG0J8<1E=QGT?4B6B&N=Y"D(%8H`Q`S:@"1+,;H@TCG
M>#R<MI!.0*E&D4RI-B8.;9AM7(R<E$;QYD:J/UQ_.'_1(_U.RZQ.PVRM9HYV
M9[%699W/IW(S^C621SE:S=<SK3(_+LP52Z?$J3745G.;:2E-<!PBE11,4UC"
M0X`!`*/V2`$-"F5N9'-T<F5A;0UE;F1O8FH--3@U(#`@;V)J/#PO3&5N9W1H
M(#(S,2]&:6QT97(O1FQA=&5$96-O9&4^/G-T<F5A;0T*2(ELS[UNPC`0!W!;
M&9!N\2-P+P#!JI66"8D6B0Q([=0'*!T[%-'9WAAY)20&7B.\04:&R,<_D:H$
MB(>?Y#O[/ES&$\YX9-D]<_;$:TN_Y"R""#O.QA:Y\62*\\)?/S3/*?UD9RE=
M(D_I_/V5<<E7O-W\?5/^1E(-!$?5Q@?E8OHMA_T6LWX/OM\@'9M10J&A#JHV
M*?!*F1(UU`Q&Y=$G*FG5M572<="*8='_4:30_\[0#-M5_XL'NO(''Y/+C0%]
M2FD]UYHSOE3FV'AJW,%HC"388RA8,WC9HZP(+7+ZH*L``P#,KB@'#0IE;F1S
M=')E86T-96YD;V)J#34X-B`P(&]B:CP\+TQE;F=T:"`S,34O1FEL=&5R+T9L
M871E1&5C;V1E/CYS=')E86T-"DB)K)+-2L0P%(539A'()F]@\@(S;?WI#Y0I
MC`IV,:`KMX*Z=*$HN+*5>;$.OLCU#>(NBS`Q]W9P9:4+;Q;Y("?WYAQRDNE$
MSX_T/"UUENOL6-^EXE'DB<95A(/#18FGBZ0,5>C;![%J1'RM\T3$%T$AXM7E
MJ4Y%W*SU\]/+O6C.A`]EI(<6H8M\IQ`8\TR&W7%XDSR`5;92&]36IE"S`-!"
M<3!`GU0(_0_X_J;"6YT'6$J"+VBQ\SO*<$+T)W2X[V;3(/+TTC%PC"IX&`=O
M);4:`6P5K*M)8-&PAWH2&(H[^)X"04]93H(I,?][WA28DWOX/53*R>X#^[1*
MHM[W9LD).E-QAXZ9*;@=X)5;M,7`<H-/CL!*P#9\Z^HMPN;#T:_T/=\QF@#2
M,PHN7!U\BO-&7(EO`08`(;$]IPT*96YD<W1R96%M#65N9&]B:@TU.#<@,"!O
M8FH\/"],96YG=&@@,3,Y+T9I;'1E<B]&;&%T941E8V]D93X^<W1R96%M#0I(
MB3*R4#!0,%/0-;10,#)0,#102#'D*N0R-`&*&B@862B8Z1F")(%D<BZ7DR>7
M?KB"H0F7O@=0CDO?*<!9P9!+W]-7H:2H-)7+TX7KG_P?_A_L']@?,(,AD/7#
M_?]Q(.P'0OG_\O_L_]G_J?]3_^/_Q_^/_Q_^W_Z?'RA<_Y_+U9,KD`L@P`#&
M_#6A#0IE;F1S=')E86T-96YD;V)J#34X."`P(&]B:CP\+TQE;F=T:"`R,34O
M1FEL=&5R+T9L871E1&5C;V1E/CYS=')E86T-"DB)5,\]:L-`$`7@%0O>,!AT
M!,T%8FDE82(("/P#41&PJQP@3IG"QH%TEO#%E)OX"%MN(?0RQ@EX![YF7C'S
MRIPSKOC1<FEY7O#.TIZ*ZS+C><G5S$HVRRJ9)W[_I$5#Z1L7.:4ODE.ZV"S9
M4MJ\\O'P]4'-BG"IX50(_2G4(A2%1AT:S+\>PT35?JH2__`<>S4:KV&<@19G
M%Z-S"3IYX:K]H^3DO:C%&(@PZ#LF@C<:/KYQB:C/4DR<.O3X02<T+J.!^X[A
MI>.@I)?\2NN&MO0KP`!,M;42#0IE;F1S=')E86T-96YD;V)J#34X.2`P(&]B
M:CP\+T-3(#4S-"`P(%(O0T,@-3,U(#`@4B]#4B`U,S8@,"!2+T)'(#4S-R`P
M(%(O0S`@-3,X(#`@4B]#,2`U,SD@,"!2+T-!(#4T,"`P(%(O0T8@-30Q(#`@
M4B]!0R`U-#(@,"!2+T1!(#4T,R`P(%(O0T(@-30T(#`@4B]$-"`U-#4@,"!2
M+T-0(#4T-B`P(%(O1#8@-30W(#`@4B]$-R`U-#@@,"!2+T-4(#4P,"`P(%(O
M0T0@-3`Q(#`@4B]"6B`U,#(@,"!2+T0Y(#4P,R`P(%(O0U@@-3`T(#`@4B]"
M5"`U,#4@,"!2+T,T(#4P-B`P(%(O1#(@-3`W(#`@4B]"6"`U,#@@,"!2+T0X
M(#4P.2`P(%(O1#,@-3$P(#`@4B]$,"`U,3$@,"!2+T-%(#4Q,B`P(%(O0D0@
M-3$S(#`@4B]"02`U,30@,"!2+T-5(#4Q-2`P(%(O0U8@-3$V(#`@4B]"12`U
M,3<@,"!2+T)&(#4Q."`P(%(O0S8@-3$Y(#`@4B]#-R`U,C`@,"!2+T)7(#4R
M,2`P(%(O0E8@-3(R(#`@4B]#."`U,C,@,"!2+T,U(#4W-"`P(%(O0ED@-3<U
M(#`@4B]$,2`U-S8@,"!2+T1"(#4W-R`P(%(O1$,@-3<X(#`@4B]".2`U-SD@
M,"!2+T1$(#4X,"`P(%(O0SD@-3@Q(#`@4B]$12`U.#(@,"!2+T(T(#4X,R`P
M(%(O0C4@-3@T(#`@4B]#5R`U.#4@,"!2+T%"(#4X-B`P(%(O0C@@-3@W(#`@
M4B]#42`U.#@@,"!2/CX-96YD;V)J#34Y,"`P(&]B:CP\+U!R;V-3971;+U!$
M1B]);6%G94)=/CX-96YD;V)J#34Y,2`P(&]B:CP\+U1Y<&4O16YC;V1I;F<O
M1&EF9F5R96YC97-;,"]#6"]$-R]#4"]!1"]#5"]$0R]#42]$,"]$-"]#4B]#
M6B]#5B]$,R]#52]$.2]$-B]$."]$,B]$0B]"5B]#5R]#4R]$-2]$1"]$02]$
M,2]"02]#0R]"52]"."]!0R]".2]#,2]#-B]",R]!0B]"5"]$12]#,"]"32]#
M62]#-2]"1"]"2R]"6"]"5R]"-"]"-2]#1B]#-R]#0B]"-R]"62]#2"]#02]"
M0B]#2R]!62]"3B]"4"]#-"]#1"]#,R]#2B]"22]#3"]"0R]"12]"6B]#1R]#
M."]"1B]"2"]"2B]"1R]#3R]#,B]#.2]"3"]#12`Q.3@O045=/CX-96YD;V)J
M#34Y,B`P(&]B:CP\+TQE;F=T:"`R,3`O1FEL=&5R+T9L871E1&5C;V1E/CYS
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
M+T)&+T)'+T)(+T))+T)*+T)++T),+T)$+T)#73X^#65N9&]B:@TQ,#$@,"!O
M8FH\/"]#4R`Y,R`P(%(O0D<@.30@,"!2+T)#(#DU(#`@4B]#0B`Q,3`@,"!2
M+T0T(#$Q,2`P(%(O0U`@,3$R(#`@4B]$-B`Q,3,@,"!2+T0W(#$Q-"`P(%(O
M0U0@,3$U(#`@4B]#1"`Q,C@@,"!2+T(S(#$R.2`P(%(O0EH@,3,P(#`@4B]$
M.2`Q,S$@,"!2+T-8(#$S,B`P(%(O0D0@,3,S(#`@4B]"12`Q,S0@,"!2+T)&
M(#$S-2`P(%(O0D@@,3,V(#`@4B]"22`Q,S<@,"!2+T)*(#$S."`P(%(O0DL@
M,3,Y(#`@4B]"3"`Q-#`@,"!2/CX-96YD;V)J#3$P,B`P(&]B:CP\+U1Y<&4O
M1F]N="]297-O=7)C97,@,3`S(#`@4B].86UE+U0Q,2]%;F-O9&EN9R`Q,#0@
M,"!2+T9I<G-T0VAA<B`P+TQA<W1#:&%R(#0T+T-H87)0<F]C<R`Q,#4@,"!2
M+U-U8G1Y<&4O5'EP93,O1F]N=$)";WA;,B`M,C$@,3`Q(#<P72]&;VYT36%T
M<FEX6S$@,"`P("TQ(#`@,%TO5VED=&AS6S4V(#,Q(#<P(#4Q(#4T(#0T(#8R
M(#0V(#0T(#4V(#,T(#8R(#8R(#4V(#4V(#<T(#8R(#8R(#4P(#DS(#4Y(#4V
M(#8W(#,Q(#0R(#,Q(#4V(#$P-B`U.2`U.2`X,2`X,"`V,B`U,"`U-B`U-B`V
M,B`W-R`X-B`V,B`U-B`U-B`X."`U-B`X-%T^/@UE;F1O8FH-,3`S(#`@;V)J
M/#PO4')O8U-E=%LO4$1&+TEM86=E0ET^/@UE;F1O8FH-,3`T(#`@;V)J/#PO
M5'EP92]%;F-O9&EN9R]$:69F97)E;F-E<ULP+T)$+T)!+T)9+T-4+T-0+T0X
M+T0Y+T0V+T0W+T0S+T-5+T-"+T0T+T)'+T)%+T)8+T0R+T-7+T-2+T0Q+T1!
M+T)&+T,T+T-8+T,Q+T0P+T-6+T,U+T1#+T0U+T)6+T)5+T-3+T1%+T)(+T))
M+T%#+T,X+T)7+T%$+T)*+T)++T,V+T),+T,W73X^#65N9&]B:@TQ,#4@,"!O
M8FH\/"]#4R`Q-#0@,"!2+T-2(#$T-2`P(%(O0D<@,30V(#`@4B]#,2`Q-#<@
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
M!&?81+"O3:0J)T0T6]5F=YL.XY11VA1TH(\``P#9`@DF#0IE;F1S=')E86T-
M96YD;V)J#3$R,2`P(&]B:CP\+U!R;V-3971;+U!$1B]);6%G94)=/CX-96YD
M;V)J#3$R,B`P(&]B:CP\+U1Y<&4O16YC;V1I;F<O1&EF9F5R96YC97-;,"]"
M1"]"02]"62]#5"]#4"]$."]$.2]$-B]$-R]$,R]#52]#0B]$-"]"1R]"12]"
M6"]$,B]#5R]#4B]$,2]$02]"1B]#."]#02]#,2]#-2]"5B]$,"]"52]#6"]#
M4R]#5B]$0R]$12]"2"]"22]!0R]"5R]"3"]#-R]"5"]#1"]#0R]#-B]#-"]#
M2"]"6B]"2B]"2UT^/@UE;F1O8FH-,3(S(#`@;V)J/#PO0U,@.38@,"!2+T-#
M(#DW(#`@4B]#4B`Q,38@,"!2+T)'(#$Q-R`P(%(O0S$@,3$X(#`@4B]#02`Q
M,3D@,"!2+T%#(#$R,"`P(%(O1$$@,3@R(#`@4B]#0B`Q.#,@,"!2+T0T(#$X
M-"`P(%(O0U`@,3@U(#`@4B]$-B`Q.#8@,"!2+T0W(#$X-R`P(%(O0U0@,3@X
M(#`@4B]#1"`Q.#D@,"!2+T):(#$Y,"`P(%(O1#D@,3DQ(#`@4B]#6"`Q.3(@
M,"!2+T)4(#$Y,R`P(%(O0S0@,3DT(#`@4B]$,B`Q.34@,"!2+T)8(#$Y-B`P
M(%(O1#@@,3DW(#`@4B]$,R`Q.3@@,"!2+T0P(#$Y.2`P(%(O0D0@,C`P(#`@
M4B]"02`R,#$@,"!2+T-5(#(P,B`P(%(O0U8@,C`S(#`@4B]"12`R,#0@,"!2
M+T)&(#(P-2`P(%(O0S8@,C`V(#`@4B]#-R`R,#<@,"!2+T)7(#(P."`P(%(O
M0E8@,C`Y(#`@4B]#."`R,3`@,"!2+T,U(#(Q,2`P(%(O0D@@,C$R(#`@4B]"
M62`R,3,@,"!2+T)5(#(Q-"`P(%(O0T@@,C$U(#`@4B]"22`R,38@,"!2+T)*
M(#(Q-R`P(%(O0DL@,C$X(#`@4B]$,2`R,3D@,"!2+T1#(#(R,"`P(%(O1$4@
M,C(Q(#`@4B]#5R`Q,C8@,"!2+T),(#$R-R`P(%(^/@UE;F1O8FH-,3(T(#`@
M;V)J/#PO5'EP92]&;VYT+U)E<V]U<F-E<R`Y.2`P(%(O3F%M92]4,3`O16YC
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
M."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T
M."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T
M."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T
M."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T
M."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T."`T
M.%T^/@UE;F1O8FH-,C,P(#`@;V)J/#PO4')O8U-E=%LO4$1&+TEM86=E0ET^
M/@UE;F1O8FH-,C,Q(#`@;V)J/#PO5'EP92]%;F-O9&EN9R]$:69F97)E;F-E
M<ULP+T0W+T0S+T0Y+T0V+T-2+T-5+T-6+T-4+T)!+T0R+T0X+T)"+T(V+T-"
M+T-8+T0Q+T0T+T0P+T1#+T-0+T-#+T-7+T-1+T-3+T1"+T-:+T)4+T)6+T1$
M+T1!+T0U+T)8+T,X+T-!+T)7+T-.+T,W+T,U+T,T+T-'+T-%+T,V+T%:+T)/
M+T)1+T%9+T(T+T(X+T(U+T1&+T).+T-*+T)&+T-,+T1(+T)0+T)%+T)$+T(R
M+T)9+T)#+T):+T(W+T,Q+T,Y+T-$+T)(+T(Y+T))+T(Q+T-++T)'+T)*+T)+
M+T),+T)373X^#65N9&]B:@TR,S(@,"!O8FH\/"]#4R`R,S,@,"!2+T)3(#(S
M-"`P(%(O0T,@,C,U(#`@4B]#1R`R,S8@,"!2+T-2(#(T,R`P(%(O0D<@,C0T
M(#`@4B]#,2`R-#4@,"!2+T)#(#(T-B`P(%(O0T$@,C0W(#`@4B]#3"`R-#@@
M,"!2+T1!(#(T.2`P(%(O0T(@,C4P(#`@4B]$-"`R-3$@,"!2+T-0(#(U,B`P
M(%(O1#8@,C4S(#`@4B]$-R`R-30@,"!2+T-4(#(U-2`P(%(O0T0@,C4V(#`@
M4B]"6B`R-3<@,"!2+T0Y(#(U."`P(%(O0U@@,C4Y(#`@4B]"5"`R-C`@,"!2
M+T,T(#(V,2`P(%(O1#(@,C8R(#`@4B]"6"`R-C,@,"!2+T0U(#(V-"`P(%(O
M1#@@,C8U(#`@4B]$,R`R-C8@,"!2+T0P(#(V-R`P(%(O0T4@,C8X(#`@4B]"
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
MB`3Z%T@]8&!@!Y-`-I>K)U<@%T"``0`*.]K-#0IE;F1S=')E86T-96YD;V)J
M#3,X,B`P(&]B:CP\+U1Y<&4O1F]N="]297-O=7)C97,@,S@S(#`@4B].86UE
M+U0Q-R]%;F-O9&EN9R`S.#0@,"!2+T9I<G-T0VAA<B`P+TQA<W1#:&%R(#`O
M0VAA<E!R;V-S(#,X-2`P(%(O4W5B='EP92]4>7!E,R]&;VYT0D)O>%LQ(#`@
M-#D@-#5=+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-#%=/CX-
M96YD;V)J#3,X,R`P(&]B:CP\+U!R;V-3971;+U!$1B]);6%G94)=/CX-96YD
M;V)J#3,X-"`P(&]B:CP\+U1Y<&4O16YC;V1I;F<O1&EF9F5R96YC97-;,"]#
M0UT^/@UE;F1O8FH-,S@U(#`@;V)J/#PO0T,@,S@Q(#`@4CX^#65N9&]B:@TS
M.#8@,"!O8FH\/"]4>7!E+T9O;G0O4F5S;W5R8V5S(#8T(#`@4B].86UE+U0Q
M.2]%;F-O9&EN9R`V-2`P(%(O1FER<W1#:&%R(#`O3&%S=$-H87(@,2]#:&%R
M4')O8W,@-C@@,"!2+U-U8G1Y<&4O5'EP93,O1F]N=$)";WA;-B`M,2`V,2`T
M,5TO1F]N=$UA=')I>%LQ(#`@,"`M,2`P(#!=+U=I9'1H<ULU,2`U.5T^/@UE
M;F1O8FH-,S@W(#`@;V)J/#PO5'EP92]&;VYT+U)E<V]U<F-E<R`U-R`P(%(O
M3F%M92]4,3@O16YC;V1I;F<@-3@@,"!2+T9I<G-T0VAA<B`P+TQA<W1#:&%R
M(#,O0VAA<E!R;V-S(#8S(#`@4B]3=6)T>7!E+U1Y<&4S+T9O;G1"0F]X6S,@
M+3(@-C@@-C)=+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P72]7:61T:'-;-S0@
M-38@,C<@-39=/CX-96YD;V)J#3,X."`P(&]B:CP\+U1Y<&4O1F]N="]297-O
M=7)C97,@-S@@,"!2+TYA;64O5#(P+T5N8V]D:6YG(#<Y(#`@4B]&:7)S=$-H
M87(@,"],87-T0VAA<B`P+T-H87)0<F]C<R`X,2`P(%(O4W5B='EP92]4>7!E
M,R]&;VYT0D)O>%LR(#`@-3`@-#==+T9O;G1-871R:7A;,2`P(#`@+3$@,"`P
M72]7:61T:'-;-3-=/CX-96YD;V)J#3,X.2`P(&]B:CP\+TYU;7-;,"`S.3`@
M,"!273X^#65N9&]B:@TS.3`@,"!O8FH\/"]3+T0^/@UE;F1O8FH-,SDQ(#`@
M;V)J/#PO0V]U;G0@,C0O2VED<ULS.3(@,"!2(#,Y,R`P(%(@,SDT(#`@4ETO
M5'EP92]086=E<SX^#65N9&]B:@TS.3(@,"!O8FH\/"]#;W5N="`Q,"]+:61S
M6S0P,"`P(%(@,2`P(%(@-"`P(%(@-R`P(%(@,3`@,"!2(#$X(#`@4B`R,2`P
M(%(@,C0@,"!2(#(W(#`@4B`S,"`P(%)=+U1Y<&4O4&%G97,O4&%R96YT(#,Y
M,2`P(%(^/@UE;F1O8FH-,SDS(#`@;V)J/#PO0V]U;G0@,3`O2VED<ULS,R`P
M(%(@,S8@,"!2(#,Y(#`@4B`T,B`P(%(@-#4@,"!2(#0X(#`@4B`U,2`P(%(@
M-30@,"!2(#8Y(#`@4B`W,B`P(%)=+U1Y<&4O4&%G97,O4&%R96YT(#,Y,2`P
M(%(^/@UE;F1O8FH-,SDT(#`@;V)J/#PO0V]U;G0@-"]+:61S6S<U(#`@4B`X
M,B`P(%(@.#4@,"!2(#@X(#`@4ETO5'EP92]086=E<R]087)E;G0@,SDQ(#`@
M4CX^#65N9&]B:@TS.34@,"!O8FH\/"],96YG=&@@,S(X,R]4>7!E+TUE=&%D
M871A+U-U8G1Y<&4O6$U,/CYS=')E86T-"CP_>'!A8VME="!B96=I;CTG[[N_
M)R!I9#TG5S5-,$UP0V5H:4AZ<F53>DY48WIK8SED)S\^"CP_861O8F4M>&%P
M+69I;'1E<G,@97-C/2)#4DQ&(C\^#0H\>#IX;7!M971A('AM;&YS.G@])V%D
M;V)E.FYS.FUE=&$O)R!X.GAM<'1K/2=835`@=&]O;&MI="`R+CDN,2TQ,RP@
M9G)A;65W;W)K(#$N-B<^#0H\<F1F.E)$1B!X;6QN<SIR9&8])VAT='`Z+R]W
M=W<N=S,N;W)G+S$Y.3DO,#(O,C(M<F1F+7-Y;G1A>"UN<R,G('AM;&YS.FE8
M/2=H='1P.B\O;G,N861O8F4N8V]M+VE8+S$N,"\G/@T*/')D9CI$97-C<FEP
M=&EO;B!R9&8Z86)O=70])W5U:60Z9#(W9C`W-&(M.#0U,2TT.61E+6$X9C4M
M,#`V-60W8F-E9C,W)R!X;6QN<SIP9&8])VAT='`Z+R]N<RYA9&]B92YC;VTO
M<&1F+S$N,R\G('!D9CI0<F]D=6-E<CTG06-R;V)A="!$:7-T:6QL97(@-BXP
M("A7:6YD;W=S*2<^/"]R9&8Z1&5S8W)I<'1I;VX^#0H\<F1F.D1E<V-R:7!T
M:6]N(')D9CIA8F]U=#TG=75I9#ID,C=F,#<T8BTX-#4Q+30Y9&4M83AF-2TP
M,#8U9#=B8V5F,S<G('AM;&YS.GAA<#TG:'1T<#HO+VYS+F%D;V)E+F-O;2]X
M87`O,2XP+R<@>&%P.D-R96%T941A=&4])S(P,#4M,#0M,3)4,3`Z,3`Z,C(M
M,#<Z,#`G('AA<#I-;V1I9GE$871E/2<R,#`U+3`T+3$R5#$P.C$P.C(R+3`W
M.C`P)SX\>&%P.D-R96%T;W)4;V]L/F1V:7!S*&LI(#4N.#8@0V]P>7)I9VAT
M(#$Y.3D@4F%D:6-A;"!%>64@4V]F='=A<F4\+WAA<#I#<F5A=&]R5&]O;#X\
M+W)D9CI$97-C<FEP=&EO;CX-"CQR9&8Z1&5S8W)I<'1I;VX@<F1F.F%B;W5T
M/2=U=6ED.F0R-V8P-S1B+3@T-3$M-#ED92UA.&8U+3`P-C5D-V)C968S-R<@
M>&UL;G,Z>&%P34T])VAT='`Z+R]N<RYA9&]B92YC;VTO>&%P+S$N,"]M;2\G
M('AA<$U-.D1O8W5M96YT240])W5U:60Z960T.&(R-&$M9&-C92TT.#`Y+3@S
M,#`M,#<Y-C,Q-#-A,C(T)R\^#0H\<F1F.D1E<V-R:7!T:6]N(')D9CIA8F]U
M=#TG=75I9#ID,C=F,#<T8BTX-#4Q+30Y9&4M83AF-2TP,#8U9#=B8V5F,S<G
M('AM;&YS.F1C/2=H='1P.B\O<'5R;"YO<F<O9&,O96QE;65N=',O,2XQ+R<@
M9&,Z9F]R;6%T/2=A<'!L:6-A=&EO;B]P9&8G/CQD8SIT:71L93X\<F1F.D%L
M=#X\<F1F.FQI('AM;#IL86YG/2=X+61E9F%U;'0G/G-P1&]C+F1V:3PO<F1F
M.FQI/CPO<F1F.D%L=#X\+V1C.G1I=&QE/CPO<F1F.D1E<V-R:7!T:6]N/@T*
M/"]R9&8Z4D1&/@T*/"]X.GAM<&UE=&$^#0H@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@"B`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@(`H@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@"B`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`*("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M(`H@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`*("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@(`H@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`*("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@(`H@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@"B`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`*
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@(`H@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@"B`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`*("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@(`H@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@"B`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@("`@
M("`@("`@("`@("`@("`@("`@("`*("`@("`@("`@("`@("`@("`@("`@("`@
M("`@"CP_>'!A8VME="!E;F0])W<G/SX-"F5N9'-T<F5A;0UE;F1O8FH-,SDV
M(#`@;V)J/#PO36]D1&%T92A$.C(P,#4P-#$R,3`Q,#(R+3`W)S`P)RDO0W)E
M871I;VY$871E*$0Z,C`P-3`T,3(Q,#$P,C(M,#<G,#`G*2]4:71L92AS<$1O
M8RYD=FDI+T-R96%T;W(H9'9I<'-<*&M<*2`U+C@V($-O<'ER:6=H="`Q.3DY
M(%)A9&EC86P@17EE(%-O9G1W87)E*2]0<F]D=6-E<BA!8W)O8F%T($1I<W1I
M;&QE<B`V+C`@7"A7:6YD;W=S7"DI/CX-96YD;V)J#7AR968-"C`@,SDW#0HP
M,#`P,#`P,#`P(#8U-3,U(&8-"C`P,#`P.3$R-3,@,#`P,#`@;@T*,#`P,#`Y
M,3,X,"`P,#`P,"!N#0HP,#`P,#DQ-34R(#`P,#`P(&X-"C`P,#`P.30T.#@@
M,#`P,#`@;@T*,#`P,#`Y-#8Q-2`P,#`P,"!N#0HP,#`P,#DT-SDY(#`P,#`P
M(&X-"C`P,#`P.3@Y,C@@,#`P,#`@;@T*,#`P,#`Y.3`U-2`P,#`P,"!N#0HP
M,#`P,#DY,C4P(#`P,#`P(&X-"C`P,#`Q,#,U-C0@,#`P,#`@;@T*,#`P,#$P
M,S8Y-"`P,#`P,"!N#0HP,#`P,3`S.#DQ(#`P,#`P(&X-"C`P,#`Q,#@T,C$@
M,#`P,#`@;@T*,#`P,#$P.#0V,B`P,#`P,"!N#0HP,#`P,3`X-3$W(#`P,#`P
M(&X-"C`P,#`Q,#@X.3`@,#`P,#`@;@T*,#`P,#$P.3(U.2`P,#`P,"!N#0HP
M,#`P,3`Y,CDY(#`P,#`P(&X-"C`P,#`Q,#DT,CD@,#`P,#`@;@T*,#`P,#$P
M.34Y,"`P,#`P,"!N#0HP,#`P,3$T-#@T(#`P,#`P(&X-"C`P,#`Q,30V,30@
M,#`P,#`@;@T*,#`P,#$Q-#<W-2`P,#`P,"!N#0HP,#`P,3$Y-#(X(#`P,#`P
M(&X-"C`P,#`Q,3DU-3@@,#`P,#`@;@T*,#`P,#$Q.3<Q.2`P,#`P,"!N#0HP
M,#`P,3(T,SDU(#`P,#`P(&X-"C`P,#`Q,C0U,C4@,#`P,#`@;@T*,#`P,#$R
M-#<P.2`P,#`P,"!N#0HP,#`P,3(X-#<T(#`P,#`P(&X-"C`P,#`Q,C@V,#0@
M,#`P,#`@;@T*,#`P,#$R.#<W-R`P,#`P,"!N#0HP,#`P,3,P.#<X(#`P,#`P
M(&X-"C`P,#`Q,S$P,#@@,#`P,#`@;@T*,#`P,#$S,3$X,2`P,#`P,"!N#0HP
M,#`P,3,T,#$Y(#`P,#`P(&X-"C`P,#`Q,S0Q-#D@,#`P,#`@;@T*,#`P,#$S
M-#,T-B`P,#`P,"!N#0HP,#`P,3,V-S$Q(#`P,#`P(&X-"C`P,#`Q,S8X-#$@
M,#`P,#`@;@T*,#`P,#$S-S`U,"`P,#`P,"!N#0HP,#`P,3,Y-C0S(#`P,#`P
M(&X-"C`P,#`Q,SDW-S,@,#`P,#`@;@T*,#`P,#$S.3DU-R`P,#`P,"!N#0HP
M,#`P,30R-C`W(#`P,#`P(&X-"C`P,#`Q-#(W,S<@,#`P,#`@;@T*,#`P,#$T
M,C@W-B`P,#`P,"!N#0HP,#`P,30T,S`W(#`P,#`P(&X-"C`P,#`Q-#0T,S<@
M,#`P,#`@;@T*,#`P,#$T-#8R,2`P,#`P,"!N#0HP,#`P,30W,SDW(#`P,#`P
M(&X-"C`P,#`Q-#<U,C<@,#`P,#`@;@T*,#`P,#$T-S8W."`P,#`P,"!N#0HP
M,#`P,30X-C,S(#`P,#`P(&X-"C`P,#`Q-#@W-C,@,#`P,#`@;@T*,#`P,#$T
M.#DW,2`P,#`P,"!N#0HP,#`P,34Q,#(Q(#`P,#`P(&X-"C`P,#`Q-3$P-C(@
M,#`P,#`@;@T*,#`P,#$U,3$R,R`P,#`P,"!N#0HP,#`P,34Q,S@Y(#`P,#`P
M(&X-"C`P,#`Q-3$U-C,@,#`P,#`@;@T*,#`P,#$U,3@T.2`P,#`P,"!N#0HP
M,#`P,34R,3<P(#`P,#`P(&X-"C`P,#`Q-3(R,S`@,#`P,#`@;@T*,#`P,#$U
M,C(W,2`P,#`P,"!N#0HP,#`P,34R,S(V(#`P,#`P(&X-"C`P,#`Q-3(V,S(@
M,#`P,#`@;@T*,#`P,#$U,CDS."`P,#`P,"!N#0HP,#`P,34R.3<X(#`P,#`P
M(&X-"C`P,#`Q-3,Q,#@@,#`P,#`@;@T*,#`P,#$U,S(Y,R`P,#`P,"!N#0HP
M,#`P,34U-3DV(#`P,#`P(&X-"C`P,#`Q-34W,C8@,#`P,#`@;@T*,#`P,#$U
M-3DQ,"`P,#`P,"!N#0HP,#`P,34W-#8U(#`P,#`P(&X-"C`P,#`Q-3<U.34@
M,#`P,#`@;@T*,#`P,#$U-S<V."`P,#`P,"!N#0HP,#`P,38P,3<U(#`P,#`P
M(&X-"C`P,#`Q-C`R,38@,#`P,#`@;@T*,#`P,#$V,#(V."`P,#`P,"!N#0HP
M,#`P,38P-3,W(#`P,#`P(&X-"C`P,#`Q-C`U-C<@,#`P,#`@;@T*,#`P,#$V
M,#8Y-R`P,#`P,"!N#0HP,#`P,38P.#4X(#`P,#`P(&X-"C`P,#`Q-C(Q,#@@
M,#`P,#`@;@T*,#`P,#$V,C(S."`P,#`P,"!N#0HP,#`P,38R,SDY(#`P,#`P
M(&X-"C`P,#`Q-C0T.#<@,#`P,#`@;@T*,#`P,#$V-#8Q-R`P,#`P,"!N#0HP
M,#`P,38T.#`Q(#`P,#`P(&X-"C`P,#`Q-C<P-S<@,#`P,#`@;@T*,#`P,#$V
M-S,P,B`P,#`P,"!N#0HP,#`P,38W-#<Q(#`P,#`P(&X-"C`P,#`Q-C<W,S`@
M,#`P,#`@;@T*,#`P,#$V-SDX,"`P,#`P,"!N#0HP,#`P,38X,C0Y(#`P,#`P
M(&X-"C`P,#`Q-C@U,S,@,#`P,#`@;@T*,#`P,#$V.#<U,"`P,#`P,"!N#0HP
M,#`P,38Y,#@Q(#`P,#`P(&X-"C`P,#`Q-CDQ,C(@,#`P,#`@;@T*,#`P,#$V
M.3(S."`P,#`P,"!N#0HP,#`P,38Y-#DX(#`P,#`P(&X-"C`P,#`Q-CDX,C$@
M,#`P,#`@;@T*,#`P,#$V.3@V,R`P,#`P,"!N#0HP,#`P,3<P,#0X(#`P,#`P
M(&X-"C`P,#`Q-S`U-C0@,#`P,#`@;@T*,#`P,#$W,#8Y,R`P,#`P,"!N#0HP
M,#`P,3<P-S,U(#`P,#`P(&X-"C`P,#`Q-S`X,#`@,#`P,#`@;@T*,#`P,#$W
M,#@W-"`P,#`P,"!N#0HP,#`P,3<Q,3DV(#`P,#`P(&X-"C`P,#`Q-S$T-3,@
M,#`P,#`@;@T*,#`P,#$W,3<Q,R`P,#`P,"!N#0HP,#`P,3<Q.3$V(#`P,#`P
M(&X-"C`P,#`Q-S(Q.#(@,#`P,#`@;@T*,#`P,#$W,C0T,R`P,#`P,"!N#0HP
M,#`P,3<R-S$Q(#`P,#`P(&X-"C`P,#`Q-S(Y.3(@,#`P,#`@;@T*,#`P,#$W
M,S$Y,2`P,#`P,"!N#0HP,#`P,3<S-#DP(#`P,#`P(&X-"C`P,#`Q-S,W-3(@
M,#`P,#`@;@T*,#`P,#$W,S<Y-"`P,#`P,"!N#0HP,#`P,3<S.3DQ(#`P,#`P
M(&X-"C`P,#`Q-S0U-#D@,#`P,#`@;@T*,#`P,#$W-#@P,"`P,#`P,"!N#0HP
M,#`P,3<U,#`P(#`P,#`P(&X-"C`P,#`Q-S4R-3<@,#`P,#`@;@T*,#`P,#$W
M-34X,"`P,#`P,"!N#0HP,#`P,3<U.#$W(#`P,#`P(&X-"C`P,#`Q-S8P,#`@
M,#`P,#`@;@T*,#`P,#$W-C,P,B`P,#`P,"!N#0HP,#`P,3<V-3`T(#`P,#`P
M(&X-"C`P,#`Q-S8V-CD@,#`P,#`@;@T*,#`P,#$W-C@U.2`P,#`P,"!N#0HP
M,#`P,3<W,30X(#`P,#`P(&X-"C`P,#`Q-S<T-3D@,#`P,#`@;@T*,#`P,#$W
M-S<S,R`P,#`P,"!N#0HP,#`P,3<X,#0U(#`P,#`P(&X-"C`P,#`Q-S@R.#<@
M,#`P,#`@;@T*,#`P,#$W.#4X-"`P,#`P,"!N#0HP,#`P,3<X.3`Q(#`P,#`P
M(&X-"C`P,#`Q-SDP-S4@,#`P,#`@;@T*,#`P,#$W.3,Q,"`P,#`P,"!N#0HP
M,#`P,3<Y-3DR(#`P,#`P(&X-"C`P,#`Q-SDX.#4@,#`P,#`@;@T*,#`P,#$X
M,#$W,2`P,#`P,"!N#0HP,#`P,3@P-#4P(#`P,#`P(&X-"C`P,#`Q.#`V,C8@
M,#`P,#`@;@T*,#`P,#$X,#@X-R`P,#`P,"!N#0HP,#`P,3@Q,3<R(#`P,#`P
M(&X-"C`P,#`Q.#$U-#4@,#`P,#`@;@T*,#`P,#$X,3@T,2`P,#`P,"!N#0HP
M,#`P,3@R,34Q(#`P,#`P(&X-"C`P,#`Q.#(S-SD@,#`P,#`@;@T*,#`P,#$X
M,C8W-"`P,#`P,"!N#0HP,#`P,3@R.38U(#`P,#`P(&X-"C`P,#`Q.#,R,3$@
M,#`P,#`@;@T*,#`P,#$X,S0R,2`P,#`P,"!N#0HP,#`P,3@S-C0S(#`P,#`P
M(&X-"C`P,#`Q.#,X.#$@,#`P,#`@;@T*,#`P,#$X-#$V,"`P,#`P,"!N#0HP
M,#`P,3@T-#4V(#`P,#`P(&X-"C`P,#`Q.#0W,#(@,#`P,#`@;@T*,#`P,#$X
M-#DX-B`P,#`P,"!N#0HP,#`P,3@U,38U(#`P,#`P(&X-"C`P,#`Q.#4S-C,@
M,#`P,#`@;@T*,#`P,#$X-34S-B`P,#`P,"!N#0HP,#`P,3@U-S<X(#`P,#`P
M(&X-"C`P,#`Q.#8Q,S4@,#`P,#`@;@T*,#`P,#$X-C0V.2`P,#`P,"!N#0HP
M,#`P,3@V.#`T(#`P,#`P(&X-"C`P,#`Q.#<Q-#<@,#`P,#`@;@T*,#`P,#$X
M-S4P,2`P,#`P,"!N#0HP,#`P,3@W-SDW(#`P,#`P(&X-"C`P,#`Q.#@Q-S$@
M,#`P,#`@;@T*,#`P,#$X.#0R-2`P,#`P,"!N#0HP,#`P,3@X-S8V(#`P,#`P
M(&X-"C`P,#`Q.#DP.3`@,#`P,#`@;@T*,#`P,#$X.3,S-"`P,#`P,"!N#0HP
M,#`P,3@Y-C,Y(#`P,#`P(&X-"C`P,#`Q.#DY-S4@,#`P,#`@;@T*,#`P,#$Y
M,#(V,"`P,#`P,"!N#0HP,#`P,3DP-3`V(#`P,#`P(&X-"C`P,#`Q.3`X,S<@
M,#`P,#`@;@T*,#`P,#$Y,3$Q.2`P,#`P,"!N#0HP,#`P,3DQ,SDQ(#`P,#`P
M(&X-"C`P,#`Q.3$V,3@@,#`P,#`@;@T*,#`P,#$Y,3@X.2`P,#`P,"!N#0HP
M,#`P,3DR,34T(#`P,#`P(&X-"C`P,#`Q.3(T,S8@,#`P,#`@;@T*,#`P,#$Y
M,C<U-R`P,#`P,"!N#0HP,#`P,3DS,#`P(#`P,#`P(&X-"C`P,#`Q.3,R,#(@
M,#`P,#`@;@T*,#`P,#$Y,S4P-R`P,#`P,"!N#0HP,#`P,3DS-S(Q(#`P,#`P
M(&X-"C`P,#`Q.3,Y-C8@,#`P,#`@;@T*,#`P,#$Y-#$Y-2`P,#`P,"!N#0HP
M,#`P,3DT-#(T(#`P,#`P(&X-"C`P,#`Q.30W,#8@,#`P,#`@;@T*,#`P,#$Y
M-#DP-"`P,#`P,"!N#0HP,#`P,3DU,3,V(#`P,#`P(&X-"C`P,#`Q.34R.3D@
M,#`P,#`@;@T*,#`P,#$Y-34S.2`P,#`P,"!N#0HP,#`P,3DU.#8Q(#`P,#`P
M(&X-"C`P,#`Q.38Q-3(@,#`P,#`@;@T*,#`P,#$Y-C0V."`P,#`P,"!N#0HP
M,#`P,3DV-S8P(#`P,#`P(&X-"C`P,#`Q.3<Q,#4@,#`P,#`@;@T*,#`P,#$Y
M-S0Q,2`P,#`P,"!N#0HP,#`P,3DW-S(Y(#`P,#`P(&X-"C`P,#`Q.3@P,#D@
M,#`P,#`@;@T*,#`P,#$Y.#,V-2`P,#`P,"!N#0HP,#`P,3DX-C8R(#`P,#`P
M(&X-"C`P,#`Q.3@X-SD@,#`P,#`@;@T*,#`P,#$Y.3$Y-R`P,#`P,"!N#0HP
M,#`P,3DY-3$W(#`P,#`P(&X-"C`P,#`Q.3DX-#`@,#`P,#`@;@T*,#`P,#(P
M,#`X-2`P,#`P,"!N#0HP,#`P,C`P-#`U(#`P,#`P(&X-"C`P,#`R,#`V-S`@
M,#`P,#`@;@T*,#`P,#(P,#DV,R`P,#`P,"!N#0HP,#`P,C`Q,3<W(#`P,#`P
M(&X-"C`P,#`R,#$U,S0@,#`P,#`@;@T*,#`P,#(P,3@Q,B`P,#`P,"!N#0HP
M,#`P,C`R,3$V(#`P,#`P(&X-"C`P,#`R,#(T,#$@,#`P,#`@;@T*,#`P,#(P
M,C8T,R`P,#`P,"!N#0HP,#`P,C`R.#@W(#`P,#`P(&X-"C`P,#`R,#,R,C(@
M,#`P,#`@;@T*,#`P,#(P,S8S-R`P,#`P,"!N#0HP,#`P,C`S-C<Y(#`P,#`P
M(&X-"C`P,#`R,#,Y-3<@,#`P,#`@;@T*,#`P,#(P-#@Q-"`P,#`P,"!N#0HP
M,#`P,C`U,3$U(#`P,#`P(&X-"C`P,#`R,#4T-#(@,#`P,#`@;@T*,#`P,#(P
M-38T-R`P,#`P,"!N#0HP,#`P,C`U.34Y(#`P,#`P(&X-"C`P,#`R,#8R,C4@
M,#`P,#`@;@T*,#`P,#(P-C0X-"`P,#`P,"!N#0HP,#`P,C`V-S,Y(#`P,#`P
M(&X-"C`P,#`R,#8Y.#D@,#`P,#`@;@T*,#`P,#(P-S,R-R`P,#`P,"!N#0HP
M,#`P,C`W-C8X(#`P,#`P(&X-"C`P,#`R,#<Y-#`@,#`P,#`@;@T*,#`P,#(P
M.#$Y."`P,#`P,"!N#0HP,#`P,C`X,S<X(#`P,#`P(&X-"C`P,#`R,#@V-C<@
M,#`P,#`@;@T*,#`P,#(P.#DV,2`P,#`P,"!N#0HP,#`P,C`Y,30Y(#`P,#`P
M(&X-"C`P,#`R,#DT,#D@,#`P,#`@;@T*,#`P,#(P.3<S,2`P,#`P,"!N#0HP
M,#`P,C$P,#(T(#`P,#`P(&X-"C`P,#`R,3`S,#8@,#`P,#`@;@T*,#`P,#(Q
M,#4U,R`P,#`P,"!N#0HP,#`P,C$P.#0P(#`P,#`P(&X-"C`P,#`R,3$Q,C4@
M,#`P,#`@;@T*,#`P,#(Q,3,V."`P,#`P,"!N#0HP,#`P,C$Q-C<V(#`P,#`P
M(&X-"C`P,#`R,3$X.3@@,#`P,#`@;@T*,#`P,#(Q,C$R,2`P,#`P,"!N#0HP
M,#`P,C$R,S@T(#`P,#`P(&X-"C`P,#`R,3(U.3$@,#`P,#`@;@T*,#`P,#(Q
M,C@R-R`P,#`P,"!N#0HP,#`P,C$S,#4P(#`P,#`P(&X-"C`P,#`R,3,S-#0@
M,#`P,#`@;@T*,#`P,#(Q,S4X-R`P,#`P,"!N#0HP,#`P,C$S.#4Y(#`P,#`P
M(&X-"C`P,#`R,30P-#D@,#`P,#`@;@T*,#`P,#(Q-#,Q."`P,#`P,"!N#0HP
M,#`P,C$T-30P(#`P,#`P(&X-"C`P,#`R,30W,3`@,#`P,#`@;@T*,#`P,#(Q
M-3`P,R`P,#`P,"!N#0HP,#`P,C$U,C4R(#`P,#`P(&X-"C`P,#`R,34U.#@@
M,#`P,#`@;@T*,#`P,#(Q-3@Y,B`P,#`P,"!N#0HP,#`P,C$V,C`X(#`P,#`P
M(&X-"C`P,#`R,38T.#4@,#`P,#`@;@T*,#`P,#(Q-C<S-"`P,#`P,"!N#0HP
M,#`P,C$W,#`U(#`P,#`P(&X-"C`P,#`R,3<S,#@@,#`P,#`@;@T*,#`P,#(Q
M-S4V-2`P,#`P,"!N#0HP,#`P,C$W.#,W(#`P,#`P(&X-"C`P,#`R,3@Q,CD@
M,#`P,#`@;@T*,#`P,#(Q.#,U-2`P,#`P,"!N#0HP,#`P,C$X-C@S(#`P,#`P
M(&X-"C`P,#`R,3@Y-#0@,#`P,#`@;@T*,#`P,#(Q.3(T-B`P,#`P,"!N#0HP
M,#`P,C$Y-#DU(#`P,#`P(&X-"C`P,#`R,3DW-34@,#`P,#`@;@T*,#`P,#(R
M,#`T,"`P,#`P,"!N#0HP,#`P,C(P,C$V(#`P,#`P(&X-"C`P,#`R,C`U,S(@
M,#`P,#`@;@T*,#`P,#(R,#@R-2`P,#`P,"!N#0HP,#`P,C(Q,#DQ(#`P,#`P
M(&X-"C`P,#`R,C$S-3(@,#`P,#`@;@T*,#`P,#(R,34Y-R`P,#`P,"!N#0HP
M,#`P,C(Q.#`S(#`P,#`P(&X-"C`P,#`R,C(P.#8@,#`P,#`@;@T*,#`P,#(R
M,C(X,B`P,#`P,"!N#0HP,#`P,C(R-3$S(#`P,#`P(&X-"C`P,#`R,C(W-#$@
M,#`P,#`@;@T*,#`P,#(R,CDT,R`P,#`P,"!N#0HP,#`P,C(S,3<T(#`P,#`P
M(&X-"C`P,#`R,C,S-C(@,#`P,#`@;@T*,#`P,#(R,S4U,2`P,#`P,"!N#0HP
M,#`P,C(S.#@Q(#`P,#`P(&X-"C`P,#`R,C0Q-#$@,#`P,#`@;@T*,#`P,#(R
M-#,Q-2`P,#`P,"!N#0HP,#`P,C(T-3<R(#`P,#`P(&X-"C`P,#`R,C0V,30@
M,#`P,#`@;@T*,#`P,#(R-#8Y-2`P,#`P,"!N#0HP,#`P,C(U,S`V(#`P,#`P
M(&X-"C`P,#`R,C4T,C8@,#`P,#`@;@T*,#`P,#(R-3<Q,2`P,#`P,"!N#0HP
M,#`P,C(V,#,S(#`P,#`P(&X-"C`P,#`R,C8S-3`@,#`P,#`@;@T*,#`P,#(R
M-C8V-B`P,#`P,"!N#0HP,#`P,C(V.30Q(#`P,#`P(&X-"C`P,#`R,C<R,S`@
M,#`P,#`@;@T*,#`P,#(R-S4U-B`P,#`P,"!N#0HP,#`P,C(W.#4Y(#`P,#`P
M(&X-"C`P,#`R,C@Q-30@,#`P,#`@;@T*,#`P,#(R.#0U,B`P,#`P,"!N#0HP
M,#`P,C(X-C0P(#`P,#`P(&X-"C`P,#`R,C@Y,C(@,#`P,#`@;@T*,#`P,#(R
M.3$T-R`P,#`P,"!N#0HP,#`P,C(Y-3$X(#`P,#`P(&X-"C`P,#`R,CDW.3,@
M,#`P,#`@;@T*,#`P,#(R.3DV."`P,#`P,"!N#0HP,#`P,C,P,CDS(#`P,#`P
M(&X-"C`P,#`R,S`T.#`@,#`P,#`@;@T*,#`P,#(S,#DQ-R`P,#`P,"!N#0HP
M,#`P,C,Q,3<X(#`P,#`P(&X-"C`P,#`R,S$T-3`@,#`P,#`@;@T*,#`P,#(S
M,3<Y-"`P,#`P,"!N#0HP,#`P,C,R,#<X(#`P,#`P(&X-"C`P,#`R,S(S-S8@
M,#`P,#`@;@T*,#`P,#(S,C8P,B`P,#`P,"!N#0HP,#`P,C,R.#DR(#`P,#`P
M(&X-"C`P,#`R,S,Q-S@@,#`P,#`@;@T*,#`P,#(S,S0T,R`P,#`P,"!N#0HP
M,#`P,C,S-#@U(#`P,#`P(&X-"C`P,#`R,S,V.30@,#`P,#`@;@T*,#`P,#(S
M-#`T.2`P,#`P,"!N#0HP,#`P,C,T,C@Q(#`P,#`P(&X-"C`P,#`R,S0T.#,@
M,#`P,#`@;@T*,#`P,#(S-#@Q-B`P,#`P,"!N#0HP,#`P,C,U,#,R(#`P,#`P
M(&X-"C`P,#`R,S4R-C(@,#`P,#`@;@T*,#`P,#(S-34R."`P,#`P,"!N#0HP
M,#`P,C,U-S8S(#`P,#`P(&X-"C`P,#`R,S8P,S,@,#`P,#`@;@T*,#`P,#(S
M-C(Q,"`P,#`P,"!N#0HP,#`P,C,V-34W(#`P,#`P(&X-"C`P,#`R,S8W,S`@
M,#`P,#`@;@T*,#`P,#(S-S`P-R`P,#`P,"!N#0HP,#`P,C,W,C0S(#`P,#`P
M(&X-"C`P,#`R,S<U-S8@,#`P,#`@;@T*,#`P,#(S-SDP-R`P,#`P,"!N#0HP
M,#`P,C,X,C4Q(#`P,#`P(&X-"C`P,#`R,S@U-#4@,#`P,#`@;@T*,#`P,#(S
M.#@Y,2`P,#`P,"!N#0HP,#`P,C,Y,3,Y(#`P,#`P(&X-"C`P,#`R,SDT-S`@
M,#`P,#`@;@T*,#`P,#(S.3<P-R`P,#`P,"!N#0HP,#`P,C0P,#`V(#`P,#`P
M(&X-"C`P,#`R-#`R-S(@,#`P,#`@;@T*,#`P,#(T,#4Y-B`P,#`P,"!N#0HP
M,#`P,C0P.#@W(#`P,#`P(&X-"C`P,#`R-#$P-3`@,#`P,#`@;@T*,#`P,#(T
M,3,X,"`P,#`P,"!N#0HP,#`P,C0Q-S@T(#`P,#`P(&X-"C`P,#`R-#(P-#8@
M,#`P,#`@;@T*,#`P,#(T,C,S,B`P,#`P,"!N#0HP,#`P,C0R-C$W(#`P,#`P
M(&X-"C`P,#`R-#(X-3,@,#`P,#`@;@T*,#`P,#(T,S$R,R`P,#`P,"!N#0HP
M,#`P,C0S-#`R(#`P,#`P(&X-"C`P,#`R-#,V-#4@,#`P,#`@;@T*,#`P,#(T
M-#(T.2`P,#`P,"!N#0HP,#`P,C0T-3DV(#`P,#`P(&X-"C`P,#`R-#0X-#8@
M,#`P,#`@;@T*,#`P,#(T-3`S,B`P,#`P,"!N#0HP,#`P,C0U,#<T(#`P,#`P
M(&X-"C`P,#`R-#4Q,C<@,#`P,#`@;@T*,#`P,#(T-3$U.2`P,#`P,"!N#0HP
M,#`P,C0U,S0V(#`P,#`P(&X-"C`P,#`R-#4U,SD@,#`P,#`@;@T*,#`P,#(T
M-3<R,B`P,#`P,"!N#0HP,#`P,C0U-S4Y(#`P,#`P(&X-"C`P,#`R-#4W.#0@
M,#`P,#`@;@T*,#`P,#(T-3@U-2`P,#`P,"!N#0HP,#`P,C0U.3@U(#`P,#`P
M(&X-"C`P,#`R-#8Q,3<@,#`P,#`@;@T*,#`P,#(T-C(P-B`P,#`P,"!N#0HP
M,#`P,C0Y-38W(#`P,#`P(&X-"G1R86EL97(-"CP\+U-I>F4@,SDW/CX-"G-T
587)T>')E9@T*,3$V#0HE)45/1@T*
`
end
SHAR_EOF
  (set 20 05 04 12 14 30 03 'sparse/spDoc.pdf'; eval "$shar_touch") &&
  chmod 0600 'sparse/spDoc.pdf'
if test $? -ne 0
then ${echo} 'restore of sparse/spDoc.pdf failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spDoc.pdf: MD5 check failed'
       ) << \SHAR_EOF
c027ba9d27cf1ec4aa8a94dc8edb203e  sparse/spDoc.pdf
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spDoc.pdf'` -ne 257781 && \
  ${echo} 'restoration warning:  size of sparse/spDoc.pdf is not 257781'
  fi
fi
# ============= sparse/spFactor.c ==============
if test -f 'sparse/spFactor.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spFactor.c (file already exists)'
else
${echo} 'x - extracting sparse/spFactor.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spFactor.c' &&
/*
X *  MATRIX FACTORIZATION MODULE
X *
X *  Author:                     Advising Professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X */
/*! \file
X *  This file contains the routines to factor the matrix into LU form.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spOrderAndFactor
X *  spFactor
X *  spPartition
X *
X *  >>> Other functions contained in this file:
X *  FactorComplexMatrix         spcCreateInternalVectors
X *  CountMarkowitz              MarkowitzProducts
X *  SearchForPivot              SearchForSingleton
X *  QuicklySearchDiagonal       SearchDiagonal
X *  SearchEntireMatrix          FindLargestInCol
X *  FindBiggestInColExclude     ExchangeRowsAndCols
X *  spcRowExchange              spcColExchange
X *  ExchangeColElements         ExchangeRowElements
X *  RealRowColElimination       ComplexRowColElimination
X *  UpdateMarkowitzNumbers      MatrixIsSingular
X *  ZeroPivot			WriteStatus
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2004
X *  by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spFactor.c,v 1.3 2003/06/29 04:19:52 kundert Exp $";
#endif
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *    Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *    Macros and declarations to be imported by the user.
X *  spDefs.h
X *    Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
X
/*
X * Function declarations
X */
X
static int  FactorComplexMatrix( MatrixPtr );
static void CreateInternalVectors( MatrixPtr );
static void CountMarkowitz( MatrixPtr, RealVector, int );
static void MarkowitzProducts( MatrixPtr, int );
static ElementPtr SearchForPivot( MatrixPtr, int, int );
static ElementPtr SearchForSingleton( MatrixPtr, int );
static ElementPtr QuicklySearchDiagonal( MatrixPtr, int );
static ElementPtr SearchDiagonal( MatrixPtr, int );
static ElementPtr SearchEntireMatrix( MatrixPtr, int );
static RealNumber FindLargestInCol( ElementPtr );
static RealNumber FindBiggestInColExclude( MatrixPtr, ElementPtr, int );
static void ExchangeRowsAndCols( MatrixPtr, ElementPtr, int );
static void ExchangeColElements( MatrixPtr, int, ElementPtr, int,
X					  ElementPtr, int );
static void ExchangeRowElements( MatrixPtr, int, ElementPtr, int,
X					  ElementPtr, int );
static void RealRowColElimination( MatrixPtr, ElementPtr );
static void ComplexRowColElimination( MatrixPtr, ElementPtr );
static void UpdateMarkowitzNumbers( MatrixPtr, ElementPtr );
static int  MatrixIsSingular( MatrixPtr, int );
static int  ZeroPivot( MatrixPtr, int );
static void WriteStatus( MatrixPtr, int );
X
X
X
X
X
/*!
X *  This routine chooses a pivot order for the matrix and factors it
X *  into \a LU form.  It handles both the initial factorization and subsequent
X *  factorizations when a reordering is desired.  This is handled in a manner
X *  that is transparent to the user.  The routine uses a variation of
X *  Gauss's method where the pivots are associated with \a L and the
X *  diagonal terms of \a U are one.
X *
X *  \return
X *  The error code is returned.  Possible errors are \a spNO_MEMORY, 
X *  \a spSINGULAR and \a spSMALL_PIVOT.
X *  Error is cleared upon entering this function.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X *  \param RHS
X *      Representative right-hand side vector that is used to determine
X *      pivoting order when the right hand side vector is sparse.  If
X *      RHS is a NULL pointer then the RHS vector is assumed to
X *      be full and it is not used when determining the pivoting
X *      order.
X *  \param RelThreshold
X *      This number determines what the pivot relative threshold will
X *      be.  It should be between zero and one.  If it is one then the
X *      pivoting method becomes complete pivoting, which is very slow
X *      and tends to fill up the matrix.  If it is set close to zero
X *      the pivoting method becomes strict Markowitz with no
X *      threshold.  The pivot threshold is used to eliminate pivot
X *      candidates that would cause excessive element growth if they
X *      were used.  Element growth is the cause of roundoff error.
X *      Element growth occurs even in well-conditioned matrices.
X *      Setting the \a RelThreshold large will reduce element growth and
X *      roundoff error, but setting it too large will cause execution
X *      time to be excessive and will result in a large number of
X *      fill-ins.  If this occurs, accuracy can actually be degraded
X *      because of the large number of operations required on the
X *      matrix due to the large number of fill-ins.  A good value seems
X *      to be 0.001.  The default is chosen by giving a value larger
X *      than one or less than or equal to zero.  This value should be
X *      increased and the matrix resolved if growth is found to be
X *      excessive.  Changing the pivot threshold does not improve
X *      performance on matrices where growth is low, as is often the
X *      case with ill-conditioned matrices.  Once a valid threshold is
X *      given, it becomes the new default.  The default value of
X *      \a RelThreshold was choosen for use with nearly diagonally
X *      dominant matrices such as node- and modified-node admittance
X *      matrices.  For these matrices it is usually best to use
X *      diagonal pivoting.  For matrices without a strong diagonal, it
X *      is usually best to use a larger threshold, such as 0.01 or
X *      0.1.
X *  \param AbsThreshold
X *      The absolute magnitude an element must have to be considered
X *      as a pivot candidate, except as a last resort.  This number
X *      should be set significantly smaller than the smallest diagonal
X *      element that is is expected to be placed in the matrix.  If
X *      there is no reasonable prediction for the lower bound on these
X *      elements, then \a AbsThreshold should be set to zero.
X *      \a AbsThreshold is used to reduce the possibility of choosing as a
X *      pivot an element that has suffered heavy cancellation and as a
X *      result mainly consists of roundoff error.  Once a valid
X *      threshold is given, it becomes the new default.
X *  \param DiagPivoting
X *      A flag indicating that pivot selection should be confined to the
X *      diagonal if possible.  If \a DiagPivoting is nonzero and if
X *      \a DIAGONAL_PIVOTING is enabled pivots will be chosen only from
X *      the diagonal unless there are no diagonal elements that satisfy
X *      the threshold criteria.  Otherwise, the entire reduced
X *      submatrix is searched when looking for a pivot.  The diagonal
X *      pivoting in Sparse is efficient and well refined, while the
X *      off-diagonal pivoting is not.  For symmetric and near symmetric
X *      matrices, it is best to use diagonal pivoting because it
X *      results in the best performance when reordering the matrix and
X *      when factoring the matrix without ordering.  If there is a
X *      considerable amount of nonsymmetry in the matrix, then
X *      off-diagonal pivoting may result in a better equation ordering
X *      simply because there are more pivot candidates to choose from.
X *      A better ordering results in faster subsequent factorizations.
X *      However, the initial pivot selection process takes considerably
X *      longer for off-diagonal pivoting.
X *
X *  \see spFactor()
X */
/*  >>> Local variables:
X *  pPivot  (ElementPtr)
X *      Pointer to the element being used as a pivot.
X *
X */
X
spError
spOrderAndFactor(
X    spMatrix eMatrix,
X    spREAL RHS[],
X    spREAL RelThreshold,
X    spREAL AbsThreshold,
X    int DiagPivoting
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
ElementPtr  pPivot;
int  Step, Size;
ElementPtr SearchForPivot();
RealNumber LargestInCol, FindLargestInCol();
X
/* Begin `spOrderAndFactor'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X
X    Matrix->Error = spOKAY;
X    Size = Matrix->Size;
X    if (RelThreshold <= 0.0) RelThreshold = Matrix->RelThreshold;
X    if (RelThreshold > 1.0) RelThreshold = Matrix->RelThreshold;
X    Matrix->RelThreshold = RelThreshold;
X    if (AbsThreshold < 0.0) AbsThreshold = Matrix->AbsThreshold;
X    Matrix->AbsThreshold = AbsThreshold;
X
X    if (NOT Matrix->NeedsOrdering)
X    {
/* Matrix has been factored before and reordering is not required. */
X        for (Step = 1; Step <= Size; Step++)
X        {   pPivot = Matrix->Diag[Step];
X            LargestInCol = FindLargestInCol(pPivot->NextInCol);
X            if ((LargestInCol * RelThreshold < ELEMENT_MAG(pPivot)))
X            {   if (Matrix->Complex)
X                    ComplexRowColElimination( Matrix, pPivot );
X                else
X                    RealRowColElimination( Matrix, pPivot );
X            }
X            else
X            {   Matrix->NeedsOrdering = YES;
X                break; /* for loop */
X            }
X        }
X        if (NOT Matrix->NeedsOrdering)
X            goto Done;
X        else
X        {
/*
X * A pivot was not large enough to maintain accuracy,
X * so a partial reordering is required.
X */
X
#if (ANNOTATE >= ON_STRANGE_BEHAVIOR)
X            printf("Reordering,  Step = %1d\n", Step);
#endif
X        }
X    } /* End of if(NOT Matrix->NeedsOrdering) */
X    else
X    {
/*
X * This is the first time the matrix has been factored.  These few statements
X * indicate to the rest of the code that a full reodering is required rather
X * than a partial reordering, which occurs during a failure of a fast
X * factorization.
X */
X        Step = 1;
X        if (NOT Matrix->RowsLinked)
X            spcLinkRows( Matrix );
X        if (NOT Matrix->InternalVectorsAllocated)
X            spcCreateInternalVectors( Matrix );
X        if (Matrix->Error >= spFATAL)
X            return Matrix->Error;
X    }
X
/* Form initial Markowitz products. */
X    CountMarkowitz( Matrix, RHS, Step );
X    MarkowitzProducts( Matrix, Step );
X    Matrix->MaxRowCountInLowerTri = -1;
X
/* Perform reordering and factorization. */
X    for (; Step <= Size; Step++)
X    {   pPivot = SearchForPivot( Matrix, Step, DiagPivoting );
X        if (pPivot == NULL) return MatrixIsSingular( Matrix, Step );
X        ExchangeRowsAndCols( Matrix, pPivot, Step );
X
X        if (Matrix->Complex)
X            ComplexRowColElimination( Matrix, pPivot );
X        else
X            RealRowColElimination( Matrix, pPivot );
X
X        if (Matrix->Error >= spFATAL) return Matrix->Error;
X        UpdateMarkowitzNumbers( Matrix, pPivot );
X
#if (ANNOTATE == FULL)
X        WriteStatus( Matrix, Step );
#endif
X    }
X
Done:
X    Matrix->NeedsOrdering = NO;
X    Matrix->Reordered = YES;
X    Matrix->Factored = YES;
X
X    return Matrix->Error;
}
X
X
X
X
X
X
X
/*!
X *  This routine is the companion routine to spOrderAndFactor().
X *  Unlike spOrderAndFactor(), spFactor() cannot change the ordering.
X *  It is also faster than spOrderAndFactor().  The standard way of
X *  using these two routines is to first use spOrderAndFactor() for the
X *  initial factorization.  For subsequent factorizations, spFactor()
X *  is used if there is some assurance that little growth will occur
X *  (say for example, that the matrix is diagonally dominant).  If
X *  spFactor() is called for the initial factorization of the matrix,
X *  then spOrderAndFactor() is automatically called with the default
X *  threshold.  This routine uses "row at a time" \a LU factorization.
X *  Pivots are associated with the lower triangular matrix and the
X *  diagonals of the upper triangular matrix are ones.
X *
X *  \return
X *  The error code is returned.  Possible errors are
X *  \a spNO_MEMORY, \a spSINGULAR, \a spZERO_DIAG and \a spSMALL_PIVOT.
X *  Error is cleared upon entering this function.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \see spOrderAndFactor()
X */
X
spError
spFactor( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement;
register  ElementPtr  pColumn;
register  int  Step, Size;
RealNumber Mult;
X
/* Begin `spFactor'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X
X    if (Matrix->NeedsOrdering)
X    {   return spOrderAndFactor( eMatrix, (RealVector)NULL,
X                                 0.0, 0.0, DIAG_PIVOTING_AS_DEFAULT );
X    }
X    if (NOT Matrix->Partitioned) spPartition( eMatrix, spDEFAULT_PARTITION );
#if spCOMPLEX
X    if (Matrix->Complex) return FactorComplexMatrix( Matrix );
#endif
X
#if REAL
X    Size = Matrix->Size;
X
X    if (Matrix->Diag[1]->Real == 0.0) return ZeroPivot( Matrix, 1 );
X    Matrix->Diag[1]->Real = 1.0 / Matrix->Diag[1]->Real;
X
/* Start factorization. */
X    for (Step = 2; Step <= Size; Step++)
X    {   if (Matrix->DoRealDirect[Step])
X        {   /* Update column using direct addressing scatter-gather. */
X            register RealNumber *Dest = (RealNumber *)Matrix->Intermediate;
X
/* Scatter. */
X            pElement = Matrix->FirstInCol[Step];
X            while (pElement != NULL)
X            {   Dest[pElement->Row] = pElement->Real;
X                pElement = pElement->NextInCol;
X            }
X
/* Update column. */
X            pColumn = Matrix->FirstInCol[Step];
X            while (pColumn->Row < Step)
X            {   pElement = Matrix->Diag[pColumn->Row];
X                pColumn->Real = Dest[pColumn->Row] * pElement->Real;
X                while ((pElement = pElement->NextInCol) != NULL)
X                    Dest[pElement->Row] -= pColumn->Real * pElement->Real;
X                pColumn = pColumn->NextInCol;
X            }
X
/* Gather. */
X            pElement = Matrix->Diag[Step]->NextInCol;
X            while (pElement != NULL)
X            {   pElement->Real = Dest[pElement->Row];
X                pElement = pElement->NextInCol;
X            }
X
/* Check for singular matrix. */
X            if (Dest[Step] == 0.0) return ZeroPivot( Matrix, Step );
X            Matrix->Diag[Step]->Real = 1.0 / Dest[Step];
X        }
X        else
X        {   /* Update column using indirect addressing scatter-gather. */
X            register RealNumber **pDest = (RealNumber **)Matrix->Intermediate;
X
/* Scatter. */
X            pElement = Matrix->FirstInCol[Step];
X            while (pElement != NULL)
X            {   pDest[pElement->Row] = &pElement->Real;
X                pElement = pElement->NextInCol;
X            }
X
/* Update column. */
X            pColumn = Matrix->FirstInCol[Step];
X            while (pColumn->Row < Step)
X            {   pElement = Matrix->Diag[pColumn->Row];
X                Mult = (*pDest[pColumn->Row] *= pElement->Real);
X                while ((pElement = pElement->NextInCol) != NULL)
X                    *pDest[pElement->Row] -= Mult * pElement->Real;
X                pColumn = pColumn->NextInCol;
X            }
X
/* Check for singular matrix. */
X            if (Matrix->Diag[Step]->Real == 0.0)
X                return ZeroPivot( Matrix, Step );
X            Matrix->Diag[Step]->Real = 1.0 / Matrix->Diag[Step]->Real;
X        }
X    }
X
X    Matrix->Factored = YES;
X    return (Matrix->Error = spOKAY);
#endif /* REAL */
}
X
X
X
X
X
X
#if spCOMPLEX
/*
X *  FACTOR COMPLEX MATRIX
X *
X *  This routine is the companion routine to spFactor(), it
X *  handles complex matrices.  It is otherwise identical.
X *
X *  >>> Returned:
X *  The error code is returned.  Possible errors are listed below.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (char *)
X *      Pointer to matrix.
X *
X *  >>> Possible errors:
X *  spSINGULAR
X *  Error is cleared in this function.
X */
X
static int
FactorComplexMatrix( MatrixPtr  Matrix )
{
register  ElementPtr  pElement;
register  ElementPtr  pColumn;
register  int  Step, Size;
ComplexNumber Mult, Pivot;
X
/* Begin `FactorComplexMatrix'. */
X    ASSERT(Matrix->Complex);
X
X    Size = Matrix->Size;
X    pElement = Matrix->Diag[1];
X    if (ELEMENT_MAG(pElement) == 0.0) return ZeroPivot( Matrix, 1 );
/* Cmplx expr: *pPivot = 1.0 / *pPivot. */
X    CMPLX_RECIPROCAL( *pElement, *pElement );
X
/* Start factorization. */
X    for (Step = 2; Step <= Size; Step++)
X    {   if (Matrix->DoCmplxDirect[Step])
X        {   /* Update column using direct addressing scatter-gather. */
X            register  ComplexNumber  *Dest;
X            Dest = (ComplexNumber *)Matrix->Intermediate;
X
/* Scatter. */
X            pElement = Matrix->FirstInCol[Step];
X            while (pElement != NULL)
X            {   Dest[pElement->Row] = *(ComplexNumber *)pElement;
X                pElement = pElement->NextInCol;
X            }
X
/* Update column. */
X            pColumn = Matrix->FirstInCol[Step];
X            while (pColumn->Row < Step)
X            {   pElement = Matrix->Diag[pColumn->Row];
X                /* Cmplx expr: Mult = Dest[pColumn->Row] * (1.0 / *pPivot). */
X                CMPLX_MULT(Mult, Dest[pColumn->Row], *pElement);
X                CMPLX_ASSIGN(*pColumn, Mult);
X                while ((pElement = pElement->NextInCol) != NULL)
X                {   /* Cmplx expr: Dest[pElement->Row] -= Mult * pElement */
X                    CMPLX_MULT_SUBT_ASSIGN(Dest[pElement->Row],Mult,*pElement);
X                }
X                pColumn = pColumn->NextInCol;
X            }
X
/* Gather. */
X            pElement = Matrix->Diag[Step]->NextInCol;
X            while (pElement != NULL)
X            {   *(ComplexNumber *)pElement = Dest[pElement->Row];
X                pElement = pElement->NextInCol;
X            }
X
/* Check for singular matrix. */
X            Pivot = Dest[Step];
X            if (CMPLX_1_NORM(Pivot) == 0.0) return ZeroPivot( Matrix, Step );
X            CMPLX_RECIPROCAL( *Matrix->Diag[Step], Pivot );  
X        }
X        else
X        {   /* Update column using direct addressing scatter-gather. */
X            register  ComplexNumber  **pDest;
X            pDest = (ComplexNumber **)Matrix->Intermediate;
X
/* Scatter. */
X            pElement = Matrix->FirstInCol[Step];
X            while (pElement != NULL)
X            {   pDest[pElement->Row] = (ComplexNumber *)pElement;
X                pElement = pElement->NextInCol;
X            }
X
/* Update column. */
X            pColumn = Matrix->FirstInCol[Step];
X            while (pColumn->Row < Step)
X            {   pElement = Matrix->Diag[pColumn->Row];
X                /* Cmplx expr: Mult = *pDest[pColumn->Row] * (1.0 / *pPivot). */
X                CMPLX_MULT(Mult, *pDest[pColumn->Row], *pElement);
X                CMPLX_ASSIGN(*pDest[pColumn->Row], Mult);
X                while ((pElement = pElement->NextInCol) != NULL)
X                {  /* Cmplx expr: *pDest[pElement->Row] -= Mult * pElement */
X                   CMPLX_MULT_SUBT_ASSIGN(*pDest[pElement->Row],Mult,*pElement);
X                }
X                pColumn = pColumn->NextInCol;
X            }
X
/* Check for singular matrix. */
X            pElement = Matrix->Diag[Step];
X            if (ELEMENT_MAG(pElement) == 0.0) return ZeroPivot( Matrix, Step );
X            CMPLX_RECIPROCAL( *pElement, *pElement );  
X        }
X    }
X
X    Matrix->Factored = YES;
X    return (Matrix->Error = spOKAY);
}
#endif /* spCOMPLEX */
X
X
X
X
X
X
/*!
X *  This routine determines the cost to factor each row using both
X *  direct and indirect addressing and decides, on a row-by-row basis,
X *  which addressing mode is fastest.  This information is used in
X *  spFactor() to speed the factorization.
X *
X *  When factoring a previously ordered matrix using spFactor(), Sparse
X *  operates on a row-at-a-time basis.  For speed, on each step, the
X *  row being updated is copied into a full vector and the operations
X *  are performed on that vector.  This can be done one of two ways,
X *  either using direct addressing or indirect addressing.  Direct
X *  addressing is fastest when the matrix is relatively dense and
X *  indirect addressing is best when the matrix is quite sparse.  The
X *  user selects the type of partition used with \a Mode.  If \a Mode is set
X *  to \a spDIRECT_PARTITION, then the all rows are placed in the direct
X *  addressing partition.  Similarly, if \a Mode is set to
X *  \a spINDIRECT_PARTITION, then the all rows are placed in the indirect
X *  addressing partition.  By setting \a Mode to \a spAUTO_PARTITION, the
X *  user allows Sparse to select the partition for each row
X *  individually.  spFactor() generally runs faster if Sparse is
X *  allowed to choose its own partitioning, however choosing a
X *  partition is expensive.  The time required to choose a partition is
X *  of the same order of the cost to factor the matrix.  If you plan to
X *  factor a large number of matrices with the same structure, it is
X *  best to let Sparse choose the partition.  Otherwise, you should
X *  choose the partition based on the predicted density of the matrix.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param Mode
X *      Mode must be one of three special codes: \a spDIRECT_PARTITION,
X *      \a spINDIRECT_PARTITION, or \a spAUTO_PARTITION.
X */
X
void
spPartition(
X    spMatrix eMatrix,
X    int Mode
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement, pColumn;
register  int  Step, Size;
register  int  *Nc, *No;
register  long  *Nm;
BOOLEAN *DoRealDirect, *DoCmplxDirect;
X
/* Begin `spPartition'. */
X    ASSERT_IS_SPARSE( Matrix );
X
X    if (Matrix->Partitioned) return;
X    Size = Matrix->Size;
X    DoRealDirect = Matrix->DoRealDirect;
X    DoCmplxDirect = Matrix->DoCmplxDirect;
X    Matrix->Partitioned = YES;
X
/* If partition is specified by the user, this is easy. */
X    if (Mode == spDEFAULT_PARTITION) Mode = DEFAULT_PARTITION;
X    if (Mode == spDIRECT_PARTITION)
X    {   for (Step = 1; Step <= Size; Step++)
#if REAL
X            DoRealDirect[Step] = YES;
#endif
#if spCOMPLEX
X            DoCmplxDirect[Step] = YES;
#endif
X        return;
X    }
X    else if (Mode == spINDIRECT_PARTITION)
X    {   for (Step = 1; Step <= Size; Step++)
#if REAL
X            DoRealDirect[Step] = NO;
#endif
#if spCOMPLEX
X            DoCmplxDirect[Step] = NO;
#endif
X        return;
X    }
X    else vASSERT( Mode == spAUTO_PARTITION, "Invalid partition code" );;
X
/* Otherwise, count all operations needed in when factoring matrix. */
X    Nc = (int *)Matrix->MarkowitzRow;
X    No = (int *)Matrix->MarkowitzCol;
X    Nm = (long *)Matrix->MarkowitzProd;
X
/* Start mock-factorization. */
X    for (Step = 1; Step <= Size; Step++)
X    {   Nc[Step] = No[Step] = Nm[Step] = 0;
X
X        pElement = Matrix->FirstInCol[Step];
X        while (pElement != NULL)
X        {   Nc[Step]++;
X            pElement = pElement->NextInCol;
X        }
X
X        pColumn = Matrix->FirstInCol[Step];
X        while (pColumn->Row < Step)
X        {   pElement = Matrix->Diag[pColumn->Row];
X            Nm[Step]++;
X            while ((pElement = pElement->NextInCol) != NULL)
X                No[Step]++;
X            pColumn = pColumn->NextInCol;
X        }
X    }
X
X    for (Step = 1; Step <= Size; Step++)
X    {
/*
X * The following are just estimates based on a count on the number of
X * machine instructions used on each machine to perform the various
X * tasks.  It was assumed that each machine instruction required the
X * same amount of time (I don't believe this is true for the VAX, and
X * have no idea if this is true for the 68000 family).  For optimum
X * performance, these numbers should be tuned to the machine.
X *   Nc is the number of nonzero elements in the column.
X *   Nm is the number of multipliers in the column.
X *   No is the number of operations in the inner loop.
X */
X
#define generic
#ifdef hp9000s300
#if REAL
X        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
X        /* On the hp350, it is never profitable to use direct for complex. */
X        DoCmplxDirect[Step] = NO;
#endif
#undef generic
#endif
X
#ifdef vax
#if REAL
X        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
X        DoCmplxDirect[Step] = (Nm[Step] + No[Step] > 7*Nc[Step] - 4*Nm[Step]);
#endif
#undef generic
#endif
X
#ifdef generic
#if REAL
X        DoRealDirect[Step] = (Nm[Step] + No[Step] > 3*Nc[Step] - 2*Nm[Step]);
#endif
#if spCOMPLEX
X        DoCmplxDirect[Step] = (Nm[Step] + No[Step] > 7*Nc[Step] - 4*Nm[Step]);
#endif
#undef generic
#endif
X    }
X
#if (ANNOTATE == FULL)
X    {   int Ops = 0;
X        for (Step = 1; Step <= Size; Step++)
X            Ops += No[Step];
X        printf("Operation count for inner loop of factorization = %d.\n", Ops);
X    }
#endif
X    return;
}
X
X
X
X
X
X
X
/*
X *  CREATE INTERNAL VECTORS
X *
X *  Creates the Markowitz and Intermediate vectors.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
void
spcCreateInternalVectors( MatrixPtr Matrix )
{
int  Size;
X
/* Begin `spcCreateInternalVectors'. */
/* Create Markowitz arrays. */
X    Size= Matrix->Size;
X
X    if (Matrix->MarkowitzRow == NULL)
X    {   if (( Matrix->MarkowitzRow = ALLOC(int, Size+1)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
X    if (Matrix->MarkowitzCol == NULL)
X    {   if (( Matrix->MarkowitzCol = ALLOC(int, Size+1)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
X    if (Matrix->MarkowitzProd == NULL)
X    {   if (( Matrix->MarkowitzProd = ALLOC(long, Size+2)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
X
/* Create DoDirect vectors for use in spFactor(). */
#if REAL
X    if (Matrix->DoRealDirect == NULL)
X    {   if (( Matrix->DoRealDirect = ALLOC(BOOLEAN, Size+1)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
#endif
#if spCOMPLEX
X    if (Matrix->DoCmplxDirect == NULL)
X    {   if (( Matrix->DoCmplxDirect = ALLOC(BOOLEAN, Size+1)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
#endif
X
/* Create Intermediate vectors for use in MatrixSolve. */
#if spCOMPLEX
X    if (Matrix->Intermediate == NULL)
X    {   if ((Matrix->Intermediate = ALLOC(RealNumber,2*(Size+1))) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
#else
X    if (Matrix->Intermediate == NULL)
X    {   if ((Matrix->Intermediate = ALLOC(RealNumber, Size+1)) == NULL)
X            Matrix->Error = spNO_MEMORY;
X    }
#endif
X
X    if (Matrix->Error != spNO_MEMORY)
X        Matrix->InternalVectorsAllocated = YES;
X    return;
}
X
X
X
X
X
X
X
/*
X *  COUNT MARKOWITZ
X *
X *  Scans Matrix to determine the Markowitz counts for each row and column.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  RHS  <input>  (RealVector)
X *      Representative right-hand side vector that is used to determine
X *      pivoting order when the right hand side vector is sparse.  If
X *      RHS is a NULL pointer then the RHS vector is assumed to be full
X *      and it is not used when determining the pivoting order.
X *  Step  <input>  (int)
X *     Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  Count  (int)
X *     Temporary counting variable.
X *  ExtRow  (int)
X *     The external row number that corresponds to I.
X *  pElement  (ElementPtr)
X *     Pointer to matrix elements.
X *  Size  (int)
X *     The size of the matrix.
X */
X
static void
CountMarkowitz(
X    MatrixPtr Matrix,
X    register RealVector  RHS,
X    int Step
)
{
register int  Count, I, Size = Matrix->Size;
register ElementPtr  pElement;
int  ExtRow;
X
/* Begin `CountMarkowitz'. */
X
/* Correct array pointer for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spSEPARATED_COMPLEX_VECTORS OR NOT spCOMPLEX
X        if (RHS != NULL) --RHS;
#else
X        if (RHS != NULL)
X        {   if (Matrix->Complex) RHS -= 2;
X            else --RHS;
X        }
#endif
#endif
X
/* Generate MarkowitzRow Count for each row. */
X    for (I = Step; I <= Size; I++)
X    {
/* Set Count to -1 initially to remove count due to pivot element. */
X        Count = -1;
X        pElement = Matrix->FirstInRow[I];
X        while (pElement != NULL AND pElement->Col < Step)
X            pElement = pElement->NextInRow;
X        while (pElement != NULL)
X        {   Count++;
X            pElement = pElement->NextInRow;
X        }
X
/* Include nonzero elements in the RHS vector. */
X        ExtRow = Matrix->IntToExtRowMap[I];
X
#if spSEPARATED_COMPLEX_VECTORS OR NOT spCOMPLEX
X        if (RHS != NULL)
X            if (RHS[ExtRow] != 0.0)  Count++;
#else
X        if (RHS != NULL)
X        {   if (Matrix->Complex)
X            {   if ((RHS[2*ExtRow] != 0.0) OR (RHS[2*ExtRow+1] != 0.0))
X                    Count++;
X            }
X            else if (RHS[I] != 0.0) Count++;
X        }
#endif
X        Matrix->MarkowitzRow[I] = Count;
X    }
X
/* Generate the MarkowitzCol count for each column. */
X    for (I = Step; I <= Size; I++)
X    {
/* Set Count to -1 initially to remove count due to pivot element. */
X        Count = -1;
X        pElement = Matrix->FirstInCol[I];
X        while (pElement != NULL AND pElement->Row < Step)
X            pElement = pElement->NextInCol;
X        while (pElement != NULL)
X        {   Count++;
X            pElement = pElement->NextInCol;
X        }
X        Matrix->MarkowitzCol[I] = Count;
X    }
X    return;
}
X
X
X
X
X
X
X
X
X
X
/*
X *  MARKOWITZ PRODUCTS
X *
X *  Calculates MarkowitzProduct for each diagonal element from the Markowitz
X *  counts.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local Variables:
X *  pMarkowitzProduct  (long *)
X *      Pointer that points into MarkowitzProduct array. Is used to
X *      sequentially access entries quickly.
X *  pMarkowitzRow  (int *)
X *      Pointer that points into MarkowitzRow array. Is used to sequentially
X *      access entries quickly.
X *  pMarkowitzCol  (int *)
X *      Pointer that points into MarkowitzCol array. Is used to sequentially
X *      access entries quickly.
X *  Product  (long)
X *      Temporary storage for Markowitz product./
X *  Size  (int)
X *      The size of the matrix.
X */
X
static void
MarkowitzProducts( 
X    MatrixPtr Matrix,
X    int Step
)
{
register  int  I, *pMarkowitzRow, *pMarkowitzCol;
register  long  Product, *pMarkowitzProduct;
register  int  Size = Matrix->Size;
double fProduct;
X
/* Begin `MarkowitzProducts'. */
X    Matrix->Singletons = 0;
X
X    pMarkowitzProduct = &(Matrix->MarkowitzProd[Step]);
X    pMarkowitzRow = &(Matrix->MarkowitzRow[Step]);
X    pMarkowitzCol = &(Matrix->MarkowitzCol[Step]);
X
X    for (I = Step; I <= Size; I++)
X    {
/* If chance of overflow, use real numbers. */
X        if ((*pMarkowitzRow > LARGEST_SHORT_INTEGER AND *pMarkowitzCol != 0) OR
X            (*pMarkowitzCol > LARGEST_SHORT_INTEGER AND *pMarkowitzRow != 0))
X        {   fProduct = (double)(*pMarkowitzRow++) * (double)(*pMarkowitzCol++);
X            if (fProduct >= LARGEST_LONG_INTEGER)
X                *pMarkowitzProduct++ = LARGEST_LONG_INTEGER;
X            else
X                *pMarkowitzProduct++ = (long)fProduct;
X        }
X        else
X        {   Product = *pMarkowitzRow++ * *pMarkowitzCol++;
X            if ((*pMarkowitzProduct++ = Product) == 0)
X                Matrix->Singletons++;
X        }
X    }
X    return;
}
X
X
X
X
X
X
X
X
X
X
X
/*
X *  SEARCH FOR BEST PIVOT
X *
X *  Performs a search to determine the element with the lowest Markowitz
X *  Product that is also acceptable.  An acceptable element is one that is
X *  larger than the AbsThreshold and at least as large as RelThreshold times
X *  the largest element in the same column.  The first step is to look for
X *  singletons if any exist.  If none are found, then all the diagonals are
X *  searched. The diagonal is searched once quickly using the assumption that
X *  elements on the diagonal are large compared to other elements in their
X *  column, and so the pivot can be chosen only on the basis of the Markowitz
X *  criterion.  After a element has been chosen to be pivot on the basis of
X *  its Markowitz product, it is checked to see if it is large enough.
X *  Waiting to the end of the Markowitz search to check the size of a pivot
X *  candidate saves considerable time, but is not guaranteed to find an
X *  acceptable pivot.  Thus if unsuccessful a second pass of the diagonal is
X *  made.  This second pass checks to see if an element is large enough during
X *  the search, not after it.  If still no acceptable pivot candidate has
X *  been found, the search expands to cover the entire matrix.
X *
X *  >>> Returned:
X *  A pointer to the element chosen to be pivot.  If every element in the
X *  matrix is zero, then NULL is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      The row and column number of the beginning of the reduced submatrix.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to element that has been chosen to be the pivot.
X *
X *  >>> Possible errors:
X *  spSINGULAR
X *  spSMALL_PIVOT
X */
X
static ElementPtr
SearchForPivot(
X    MatrixPtr Matrix,
X    int Step,
X    BOOLEAN DiagPivoting
)
{
register ElementPtr  ChosenPivot;
ElementPtr  SearchForSingleton();
ElementPtr  QuicklySearchDiagonal();
ElementPtr  SearchDiagonal();
ElementPtr  SearchEntireMatrix();
X
/* Begin `SearchForPivot'. */
X
/* If singletons exist, look for an acceptable one to use as pivot. */
X    if (Matrix->Singletons)
X    {   ChosenPivot = SearchForSingleton( Matrix, Step );
X        if (ChosenPivot != NULL)
X        {   Matrix->PivotSelectionMethod = 's';
X            return ChosenPivot;
X        }
X    }
X
#if DIAGONAL_PIVOTING
X    if (DiagPivoting)
X    {
/*
X * Either no singletons exist or they weren't acceptable.  Take quick first
X * pass at searching diagonal.  First search for element on diagonal of 
X * remaining submatrix with smallest Markowitz product, then check to see
X * if it okay numerically.  If not, QuicklySearchDiagonal fails.
X */
X        ChosenPivot = QuicklySearchDiagonal( Matrix, Step );
X        if (ChosenPivot != NULL)
X        {   Matrix->PivotSelectionMethod = 'q';
X            return ChosenPivot;
X        }
X
/*
X * Quick search of diagonal failed, carefully search diagonal and check each
X * pivot candidate numerically before even tentatively accepting it.
X */
X        ChosenPivot = SearchDiagonal( Matrix, Step );
X        if (ChosenPivot != NULL)
X        {   Matrix->PivotSelectionMethod = 'd';
X            return ChosenPivot;
X        }
X    }
#endif /* DIAGONAL_PIVOTING */
X
/* No acceptable pivot found yet, search entire matrix. */
X    ChosenPivot = SearchEntireMatrix( Matrix, Step );
X    Matrix->PivotSelectionMethod = 'e';
X
X    return ChosenPivot;
}
X
X
X
X
X
X
X
X
X
/*
X *  SEARCH FOR SINGLETON TO USE AS PIVOT
X *
X *  Performs a search to find a singleton to use as the pivot.  The
X *  first acceptable singleton is used.  A singleton is acceptable if
X *  it is larger in magnitude than the AbsThreshold and larger
X *  than RelThreshold times the largest of any other elements in the same
X *  column.  It may seem that a singleton need not satisfy the
X *  relative threshold criterion, however it is necessary to prevent
X *  excessive growth in the RHS from resulting in overflow during the
X *  forward and backward substitution.  A singleton does not need to
X *  be on the diagonal to be selected.
X *
X *  >>> Returned:
X *  A pointer to the singleton chosen to be pivot.  In no singleton is
X *  acceptable, return NULL.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to element that has been chosen to be the pivot.
X *  PivotMag  (RealNumber)
X *      Magnitude of ChosenPivot.
X *  Singletons  (int)
X *      The count of the number of singletons that can be used as pivots.
X *      A local version of Matrix->Singletons.
X *  pMarkowitzProduct  (long *)
X *      Pointer that points into MarkowitzProduct array. It is used to quickly
X *      access successive Markowitz products.
X */
X
static ElementPtr
SearchForSingleton( 
X    MatrixPtr Matrix,
X    int Step
)
{
register  ElementPtr  ChosenPivot;
register  int  I;
register  long  *pMarkowitzProduct;
int  Singletons;
RealNumber  PivotMag, FindBiggestInColExclude();
X
/* Begin `SearchForSingleton'. */
/* Initialize pointer that is to scan through MarkowitzProduct vector. */
X    pMarkowitzProduct = &(Matrix->MarkowitzProd[Matrix->Size+1]);
X    Matrix->MarkowitzProd[Matrix->Size+1] = Matrix->MarkowitzProd[Step];
X
/* Decrement the count of available singletons, on the assumption that an
X * acceptable one will be found. */
X    Singletons = Matrix->Singletons--;
X
/*
X * Assure that following while loop will always terminate, this is just
X * preventive medicine, if things are working right this should never
X * be needed.
X */
X    Matrix->MarkowitzProd[Step-1] = 0;
X
X    while (Singletons-- > 0)
X    {
/* Singletons exist, find them. */
X
/*
X * This is tricky.  Am using a pointer to sequentially step through the
X * MarkowitzProduct array.  Search terminates when singleton (Product = 0)
X * is found.  Note that the conditional in the while statement
X * ( *pMarkowitzProduct ) is true as long as the MarkowitzProduct is not
X * equal to zero.  The row (and column) index on the diagonal is then
X * calculated by subtracting the pointer to the Markowitz product of
X * the first diagonal from the pointer to the Markowitz product of the
X * desired element, the singleton.
X *
X * Search proceeds from the end (high row and column numbers) to the
X * beginning (low row and column numbers) so that rows and columns with
X * large Markowitz products will tend to be move to the bottom of the
X * matrix.  However, choosing Diag[Step] is desirable because it would
X * require no row and column interchanges, so inspect it first by
X * putting its Markowitz product at the end of the MarkowitzProd
X * vector.
X */
X
X        while ( *pMarkowitzProduct-- )
X        {   /*
X             * N bottles of beer on the wall;
X             * N bottles of beer.
X             * you take one down and pass it around;
X             * N-1 bottles of beer on the wall.
X             */
X        }
X        I = pMarkowitzProduct - Matrix->MarkowitzProd + 1;
X
/* Assure that I is valid. */
X        if (I < Step) break;  /* while (Singletons-- > 0) */
X        if (I > Matrix->Size) I = Step;
X
/* Singleton has been found in either/both row or/and column I. */
X        if ((ChosenPivot = Matrix->Diag[I]) != NULL)
X        {
/* Singleton lies on the diagonal. */
X            PivotMag = ELEMENT_MAG(ChosenPivot);
X            if
X            (    PivotMag > Matrix->AbsThreshold AND
X                 PivotMag > Matrix->RelThreshold *
X                            FindBiggestInColExclude( Matrix, ChosenPivot, Step )
X            ) return ChosenPivot;
X        }
X        else
X        {
/* Singleton does not lie on diagonal, find it. */
X            if (Matrix->MarkowitzCol[I] == 0)
X            {   ChosenPivot = Matrix->FirstInCol[I];
X                while ((ChosenPivot != NULL) AND (ChosenPivot->Row < Step))
X                    ChosenPivot = ChosenPivot->NextInCol;
X		if (ChosenPivot == NULL)
X		{   /* Reduced column has no elements, matrix is singular. */
X		    break;
X		}
X                PivotMag = ELEMENT_MAG( ChosenPivot );
X                if
X                (    PivotMag > Matrix->AbsThreshold AND
X                     PivotMag > Matrix->RelThreshold *
X                                FindBiggestInColExclude( Matrix, ChosenPivot,
X                                                         Step )
X                ) return ChosenPivot;
X                else
X                {   if (Matrix->MarkowitzRow[I] == 0)
X                    {   ChosenPivot = Matrix->FirstInRow[I];
X                        while((ChosenPivot != NULL) AND (ChosenPivot->Col<Step))
X                            ChosenPivot = ChosenPivot->NextInRow;
X			if (ChosenPivot == NULL)
X			{/* Reduced row has no elements, matrix is singular. */
X			    break;
X			}
X                        PivotMag = ELEMENT_MAG(ChosenPivot);
X                        if
X                        (    PivotMag > Matrix->AbsThreshold AND
X                             PivotMag > Matrix->RelThreshold *
X                                        FindBiggestInColExclude( Matrix,
X                                                                 ChosenPivot,
X                                                                 Step )
X                        ) return ChosenPivot;
X                    }
X                }
X            }
X            else
X            {   ChosenPivot = Matrix->FirstInRow[I];
X                while ((ChosenPivot != NULL) AND (ChosenPivot->Col < Step))
X                    ChosenPivot = ChosenPivot->NextInRow;
X		if (ChosenPivot == NULL)
X		{   /* Reduced row has no elements, matrix is singular. */
X		    break;
X		}
X                PivotMag = ELEMENT_MAG(ChosenPivot);
X                if
X                (    PivotMag > Matrix->AbsThreshold AND
X                     PivotMag > Matrix->RelThreshold *
X                                FindBiggestInColExclude( Matrix, ChosenPivot,
X                                                         Step )
X                ) return ChosenPivot;
X            }
X        }
/* Singleton not acceptable (too small), try another. */
X    } /* end of while(lSingletons>0) */
X
/*
X * All singletons were unacceptable.  Restore Matrix->Singletons count.
X * Initial assumption that an acceptable singleton would be found was wrong.
X */
X    Matrix->Singletons++;
X    return NULL;
}
X
X
X
X
X
X
X
X
X
X
X
X
#if DIAGONAL_PIVOTING
#if MODIFIED_MARKOWITZ
/*
X *  QUICK SEARCH OF DIAGONAL FOR PIVOT WITH MODIFIED MARKOWITZ CRITERION
X *
X *  Searches the diagonal looking for the best pivot.  For a pivot to be
X *  acceptable it must be larger than the pivot RelThreshold times the largest
X *  element in its reduced column.  Among the acceptable diagonals, the
X *  one with the smallest MarkowitzProduct is sought.  Search terminates
X *  early if a diagonal is found with a MarkowitzProduct of one and its
X *  magnitude is larger than the other elements in its row and column.
X *  Since its MarkowitzProduct is one, there is only one other element in
X *  both its row and column, and, as a condition for early termination,
X *  these elements must be located symmetricly in the matrix.  If a tie
X *  occurs between elements of equal MarkowitzProduct, then the element with
X *  the largest ratio between its magnitude and the largest element in its
X *  column is used.  The search will be terminated after a given number of
X *  ties have occurred and the best (largest ratio) of the tied element will
X *  be used as the pivot.  The number of ties that will trigger an early
X *  termination is MinMarkowitzProduct * TIES_MULTIPLIER.
X *
X *  >>> Returned:
X *  A pointer to the diagonal element chosen to be pivot.  If no diagonal is
X *  acceptable, a NULL is returned.
X *
X *  >>> Arguments:
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to the element that has been chosen to be the pivot.
X *  LargestOffDiagonal  (RealNumber)
X *      Magnitude of the largest of the off-diagonal terms associated with
X *      a diagonal with MarkowitzProduct equal to one.
X *  Magnitude  (RealNumber)
X *      Absolute value of diagonal element.
X *  MaxRatio  (RealNumber)
X *      Among the elements tied with the smallest Markowitz product, MaxRatio
X *      is the best (smallest) ratio of LargestInCol to the diagonal Magnitude
X *      found so far.  The smaller the ratio, the better numerically the
X *      element will be as pivot.
X *  MinMarkowitzProduct  (long)
X *      Smallest Markowitz product found of pivot candidates that lie along
X *      diagonal.
X *  NumberOfTies  (int)
X *      A count of the number of Markowitz ties that have occurred at current
X *      MarkowitzProduct.
X *  pDiag  (ElementPtr)
X *      Pointer to current diagonal element.
X *  pMarkowitzProduct  (long *)
X *      Pointer that points into MarkowitzProduct array. It is used to quickly
X *      access successive Markowitz products.
X *  Ratio  (RealNumber)
X *      For the current pivot candidate, Ratio is the ratio of the largest
X *      element in its column (excluding itself) to its magnitude.
X *  TiedElements  (ElementPtr[])
X *      Array of pointers to the elements with the minimum Markowitz
X *      product.
X *  pOtherInCol  (ElementPtr)
X *      When there is only one other element in a column other than the
X *      diagonal, pOtherInCol is used to point to it.  Used when Markowitz
X *      product is to determine if off diagonals are placed symmetricly.
X *  pOtherInRow  (ElementPtr)
X *      When there is only one other element in a row other than the diagonal,
X *      pOtherInRow is used to point to it.  Used when Markowitz product is
X *      to determine if off diagonals are placed symmetricly.
X */
X
static ElementPtr
QuicklySearchDiagonal( 
X    MatrixPtr Matrix,
X    int Step
)
{
register long  MinMarkowitzProduct, *pMarkowitzProduct;
register  ElementPtr  pDiag, pOtherInRow, pOtherInCol;
int  I, NumberOfTies;
ElementPtr  ChosenPivot, TiedElements[MAX_MARKOWITZ_TIES + 1];
RealNumber  Magnitude, LargestInCol, Ratio, MaxRatio;
RealNumber  LargestOffDiagonal;
RealNumber  FindBiggestInColExclude();
X
/* Begin `QuicklySearchDiagonal'. */
X    NumberOfTies = -1;
X    MinMarkowitzProduct = LARGEST_LONG_INTEGER;
X    pMarkowitzProduct = &(Matrix->MarkowitzProd[Matrix->Size+2]);
X    Matrix->MarkowitzProd[Matrix->Size+1] = Matrix->MarkowitzProd[Step];
X
/* Assure that following while loop will always terminate. */
X    Matrix->MarkowitzProd[Step-1] = -1;
X
/*
X * This is tricky.  Am using a pointer in the inner while loop to
X * sequentially step through the MarkowitzProduct array.  Search
X * terminates when the Markowitz product of zero placed at location
X * Step-1 is found.  The row (and column) index on the diagonal is then
X * calculated by subtracting the pointer to the Markowitz product of
X * the first diagonal from the pointer to the Markowitz product of the
X * desired element. The outer for loop is infinite, broken by using
X * break.
X *
X * Search proceeds from the end (high row and column numbers) to the
X * beginning (low row and column numbers) so that rows and columns with
X * large Markowitz products will tend to be move to the bottom of the
X * matrix.  However, choosing Diag[Step] is desirable because it would
X * require no row and column interchanges, so inspect it first by
X * putting its Markowitz product at the end of the MarkowitzProd
X * vector.
X */
X
X    for(;;)  /* Endless for loop. */
X    {   while (MinMarkowitzProduct < *(--pMarkowitzProduct))
X        {   /*
X             * N bottles of beer on the wall;
X             * N bottles of beer.
X             * You take one down and pass it around;
X             * N-1 bottles of beer on the wall.
X             */
X        }
X
X        I = pMarkowitzProduct - Matrix->MarkowitzProd;
X
/* Assure that I is valid; if I < Step, terminate search. */
X        if (I < Step) break; /* Endless for loop */
X        if (I > Matrix->Size) I = Step;
X
X        if ((pDiag = Matrix->Diag[I]) == NULL)
X            continue; /* Endless for loop */
X        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
X            continue; /* Endless for loop */
X
X        if (*pMarkowitzProduct == 1)
X        {
/* Case where only one element exists in row and column other than diagonal. */
X
/* Find off diagonal elements. */
X            pOtherInRow = pDiag->NextInRow;
X            pOtherInCol = pDiag->NextInCol;
X            if (pOtherInRow == NULL AND pOtherInCol == NULL)
X            {    pOtherInRow = Matrix->FirstInRow[I];
X                 while(pOtherInRow != NULL)
X                 {   if (pOtherInRow->Col >= Step AND pOtherInRow->Col != I)
X                         break;
X                     pOtherInRow = pOtherInRow->NextInRow;
X                 }
X                 pOtherInCol = Matrix->FirstInCol[I];
X                 while(pOtherInCol != NULL)
X                 {   if (pOtherInCol->Row >= Step AND pOtherInCol->Row != I)
X                         break;
X                     pOtherInCol = pOtherInCol->NextInCol;
X                 }
X            }
X
/* Accept diagonal as pivot if diagonal is larger than off diagonals and the
X * off diagonals are placed symmetricly. */
X            if (pOtherInRow != NULL  AND  pOtherInCol != NULL)
X            {   if (pOtherInRow->Col == pOtherInCol->Row)
X                {   LargestOffDiagonal = MAX(ELEMENT_MAG(pOtherInRow),
X                                                      ELEMENT_MAG(pOtherInCol));
X                    if (Magnitude >= LargestOffDiagonal)
X                    {
/* Accept pivot, it is unlikely to contribute excess error. */
X                        return pDiag;
X                    }
X                }
X            }
X        }
X
X        if (*pMarkowitzProduct < MinMarkowitzProduct)
X        {
/* Notice strict inequality in test. This is a new smallest MarkowitzProduct. */
X            TiedElements[0] = pDiag;
X            MinMarkowitzProduct = *pMarkowitzProduct;
X            NumberOfTies = 0;
X        }
X        else
X        {
/* This case handles Markowitz ties. */
X            if (NumberOfTies < MAX_MARKOWITZ_TIES)
X            {   TiedElements[++NumberOfTies] = pDiag;
X                if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
X                    break; /* Endless for loop */
X            }
X        }
X    } /* End of endless for loop. */
X
/* Test to see if any element was chosen as a pivot candidate. */
X    if (NumberOfTies < 0)
X        return NULL;
X
/* Determine which of tied elements is best numerically. */
X    ChosenPivot = NULL;
X    MaxRatio = 1.0 / Matrix->RelThreshold;
X
X    for (I = 0; I <= NumberOfTies; I++)
X    {   pDiag = TiedElements[I];
X        Magnitude = ELEMENT_MAG(pDiag);
X        LargestInCol = FindBiggestInColExclude( Matrix, pDiag, Step );
X        Ratio = LargestInCol / Magnitude;
X        if (Ratio < MaxRatio)
X        {   ChosenPivot = pDiag;
X            MaxRatio = Ratio;
X        }
X    }
X    return ChosenPivot;
}
X
X
X
X
X
X
X
X
X
X
#else /* Not MODIFIED_MARKOWITZ */
/*
X *  QUICK SEARCH OF DIAGONAL FOR PIVOT WITH CONVENTIONAL MARKOWITZ
X *  CRITERION
X *
X *  Searches the diagonal looking for the best pivot.  For a pivot to be
X *  acceptable it must be larger than the pivot RelThreshold times the largest
X *  element in its reduced column.  Among the acceptable diagonals, the
X *  one with the smallest MarkowitzProduct is sought.  Search terminates
X *  early if a diagonal is found with a MarkowitzProduct of one and its
X *  magnitude is larger than the other elements in its row and column.
X *  Since its MarkowitzProduct is one, there is only one other element in
X *  both its row and column, and, as a condition for early termination,
X *  these elements must be located symmetricly in the matrix.
X *
X *  >>> Returned:
X *  A pointer to the diagonal element chosen to be pivot.  If no diagonal is
X *  acceptable, a NULL is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to the element that has been chosen to be the pivot.
X *  LargestOffDiagonal  (RealNumber)
X *      Magnitude of the largest of the off-diagonal terms associated with
X *      a diagonal with MarkowitzProduct equal to one.
X *  Magnitude  (RealNumber)
X *      Absolute value of diagonal element.
X *  MinMarkowitzProduct  (long)
X *      Smallest Markowitz product found of pivot candidates which are
X *      acceptable.
X *  pDiag  (ElementPtr)
X *      Pointer to current diagonal element.
X *  pMarkowitzProduct  (long *)
X *      Pointer that points into MarkowitzProduct array. It is used to quickly
X *      access successive Markowitz products.
X *  pOtherInCol  (ElementPtr)
X *      When there is only one other element in a column other than the
X *      diagonal, pOtherInCol is used to point to it.  Used when Markowitz
X *      product is to determine if off diagonals are placed symmetricly.
X *  pOtherInRow  (ElementPtr)
X *      When there is only one other element in a row other than the diagonal,
X *      pOtherInRow is used to point to it.  Used when Markowitz product is
X *      to determine if off diagonals are placed symmetricly.
X */
X
static ElementPtr
QuicklySearchDiagonal(
X    MatrixPtr Matrix,
X    int Step
)
{
register long  MinMarkowitzProduct, *pMarkowitzProduct;
register  ElementPtr  pDiag;
int  I;
ElementPtr  ChosenPivot, pOtherInRow, pOtherInCol;
RealNumber  Magnitude, LargestInCol, LargestOffDiagonal;
RealNumber  FindBiggestInColExclude();
X
/* Begin `QuicklySearchDiagonal'. */
X    ChosenPivot = NULL;
X    MinMarkowitzProduct = LARGEST_LONG_INTEGER;
X    pMarkowitzProduct = &(Matrix->MarkowitzProd[Matrix->Size+2]);
X    Matrix->MarkowitzProd[Matrix->Size+1] = Matrix->MarkowitzProd[Step];
X
/* Assure that following while loop will always terminate. */
X    Matrix->MarkowitzProd[Step-1] = -1;
X
/*
X * This is tricky.  Am using a pointer in the inner while loop to
X * sequentially step through the MarkowitzProduct array.  Search
X * terminates when the Markowitz product of zero placed at location
X * Step-1 is found.  The row (and column) index on the diagonal is then
X * calculated by subtracting the pointer to the Markowitz product of
X * the first diagonal from the pointer to the Markowitz product of the
X * desired element. The outer for loop is infinite, broken by using
X * break.
X *
X * Search proceeds from the end (high row and column numbers) to the
X * beginning (low row and column numbers) so that rows and columns with
X * large Markowitz products will tend to be move to the bottom of the
X * matrix.  However, choosing Diag[Step] is desirable because it would
X * require no row and column interchanges, so inspect it first by
X * putting its Markowitz product at the end of the MarkowitzProd
X * vector.
X */
X
X    for (;;)  /* Endless for loop. */
X    {   while (*(--pMarkowitzProduct) >= MinMarkowitzProduct)
X        {   /* Just passing through. */
X        }
X
X        I = pMarkowitzProduct - Matrix->MarkowitzProd;
X
/* Assure that I is valid; if I < Step, terminate search. */
X        if (I < Step) break; /* Endless for loop */
X        if (I > Matrix->Size) I = Step;
X
X        if ((pDiag = Matrix->Diag[I]) == NULL)
X            continue; /* Endless for loop */
X        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
X            continue; /* Endless for loop */
X
X        if (*pMarkowitzProduct == 1)
X        {
/* Case where only one element exists in row and column other than diagonal. */
X
/* Find off-diagonal elements. */
X            pOtherInRow = pDiag->NextInRow;
X            pOtherInCol = pDiag->NextInCol;
X            if (pOtherInRow == NULL AND pOtherInCol == NULL)
X            {    pOtherInRow = Matrix->FirstInRow[I];
X                 while(pOtherInRow != NULL)
X                 {   if (pOtherInRow->Col >= Step AND pOtherInRow->Col != I)
X                         break;
X                     pOtherInRow = pOtherInRow->NextInRow;
X                 }
X                 pOtherInCol = Matrix->FirstInCol[I];
X                 while(pOtherInCol != NULL)
X                 {   if (pOtherInCol->Row >= Step AND pOtherInCol->Row != I)
X                         break;
X                     pOtherInCol = pOtherInCol->NextInCol;
X                 }
X            }
X
/* Accept diagonal as pivot if diagonal is larger than off-diagonals and the
X * off-diagonals are placed symmetricly. */
X            if (pOtherInRow != NULL  AND  pOtherInCol != NULL)
X            {   if (pOtherInRow->Col == pOtherInCol->Row)
X                {   LargestOffDiagonal = MAX(ELEMENT_MAG(pOtherInRow),
X                                                      ELEMENT_MAG(pOtherInCol));
X                    if (Magnitude >= LargestOffDiagonal)
X                    {
/* Accept pivot, it is unlikely to contribute excess error. */
X                        return pDiag;
X                    }
X                }
X            }
X        }
X
X        MinMarkowitzProduct = *pMarkowitzProduct;
X        ChosenPivot = pDiag;
X    }  /* End of endless for loop. */
X
X    if (ChosenPivot != NULL)
X    {   LargestInCol = FindBiggestInColExclude( Matrix, ChosenPivot, Step );
X        if( ELEMENT_MAG(ChosenPivot) <= Matrix->RelThreshold * LargestInCol )
X            ChosenPivot = NULL;
X    }
X    return ChosenPivot;
}
#endif /* Not MODIFIED_MARKOWITZ */
X
X
X
X
X
X
X
X
X
/*
X *  SEARCH DIAGONAL FOR PIVOT WITH MODIFIED MARKOWITZ CRITERION
X *
X *  Searches the diagonal looking for the best pivot.  For a pivot to be
X *  acceptable it must be larger than the pivot RelThreshold times the largest
X *  element in its reduced column.  Among the acceptable diagonals, the
X *  one with the smallest MarkowitzProduct is sought.  If a tie occurs
X *  between elements of equal MarkowitzProduct, then the element with
X *  the largest ratio between its magnitude and the largest element in its
X *  column is used.  The search will be terminated after a given number of
X *  ties have occurred and the best (smallest ratio) of the tied element will
X *  be used as the pivot.  The number of ties that will trigger an early
X *  termination is MinMarkowitzProduct * TIES_MULTIPLIER.
X *
X *  >>> Returned:
X *  A pointer to the diagonal element chosen to be pivot.  If no diagonal is
X *  acceptable, a NULL is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to the element that has been chosen to be the pivot.
X *  Size  (int)
X *      Local version of size which is placed in a register to increase speed.
X *  Magnitude  (RealNumber)
X *      Absolute value of diagonal element.
X *  MinMarkowitzProduct  (long)
X *      Smallest Markowitz product found of those pivot candidates which are
X *      acceptable.
X *  NumberOfTies  (int)
X *      A count of the number of Markowitz ties that have occurred at current
X *      MarkowitzProduct.
X *  pDiag  (ElementPtr)
X *      Pointer to current diagonal element.
X *  pMarkowitzProduct  (long*)
X *      Pointer that points into MarkowitzProduct array. It is used to quickly
X *      access successive Markowitz products.
X *  Ratio  (RealNumber)
X *      For the current pivot candidate, Ratio is the
X *      Ratio of the largest element in its column to its magnitude.
X *  RatioOfAccepted  (RealNumber)
X *      For the best pivot candidate found so far, RatioOfAccepted is the
X *      Ratio of the largest element in its column to its magnitude.
X */
X
static ElementPtr
SearchDiagonal( 
X    MatrixPtr Matrix,
X    register int Step
)
{
register  int  J;
register long  MinMarkowitzProduct, *pMarkowitzProduct;
register  int  I;
register  ElementPtr  pDiag;
int  NumberOfTies, Size = Matrix->Size;
ElementPtr  ChosenPivot;
RealNumber  Magnitude, Ratio, RatioOfAccepted, LargestInCol;
RealNumber  FindBiggestInColExclude();
X
/* Begin `SearchDiagonal'. */
X    ChosenPivot = NULL;
X    MinMarkowitzProduct = LARGEST_LONG_INTEGER;
X    pMarkowitzProduct = &(Matrix->MarkowitzProd[Size+2]);
X    Matrix->MarkowitzProd[Size+1] = Matrix->MarkowitzProd[Step];
X
/* Start search of diagonal. */
X    for (J = Size+1; J > Step; J--)
X    {
X        if (*(--pMarkowitzProduct) > MinMarkowitzProduct)
X            continue; /* for loop */
X        if (J > Matrix->Size)
X            I = Step;
X        else
X            I = J;
X        if ((pDiag = Matrix->Diag[I]) == NULL)
X            continue; /* for loop */
X        if ((Magnitude = ELEMENT_MAG(pDiag)) <= Matrix->AbsThreshold)
X            continue; /* for loop */
X
/* Test to see if diagonal's magnitude is acceptable. */
X        LargestInCol = FindBiggestInColExclude( Matrix, pDiag, Step );
X        if (Magnitude <= Matrix->RelThreshold * LargestInCol)
X            continue; /* for loop */
X
X        if (*pMarkowitzProduct < MinMarkowitzProduct)
X        {
/* Notice strict inequality in test. This is a new smallest MarkowitzProduct. */
X            ChosenPivot = pDiag;
X            MinMarkowitzProduct = *pMarkowitzProduct;
X            RatioOfAccepted = LargestInCol / Magnitude;
X            NumberOfTies = 0;
X        }
X        else
X        {
/* This case handles Markowitz ties. */
X            NumberOfTies++;
X            Ratio = LargestInCol / Magnitude;
X            if (Ratio < RatioOfAccepted)
X            {   ChosenPivot = pDiag;
X                RatioOfAccepted = Ratio;
X            }
X            if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
X                return ChosenPivot;
X        }
X    } /* End of for(Step) */
X    return ChosenPivot;
}
#endif /* DIAGONAL_PIVOTING */
X
X
X
X
X
X
X
X
X
X
/*
X *  SEARCH ENTIRE MATRIX FOR BEST PIVOT
X *
X *  Performs a search over the entire matrix looking for the acceptable
X *  element with the lowest MarkowitzProduct.  If there are several that
X *  are tied for the smallest MarkowitzProduct, the tie is broken by using
X *  the ratio of the magnitude of the element being considered to the largest
X *  element in the same column.  If no element is acceptable then the largest
X *  element in the reduced submatrix is used as the pivot and the
X *  matrix is declared to be spSMALL_PIVOT.  If the largest element is
X *  zero, the matrix is declared to be spSINGULAR.
X *
X *  >>> Returned:
X *  A pointer to the diagonal element chosen to be pivot.  If no element is
X *  found, then NULL is returned and the matrix is spSINGULAR.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  ChosenPivot  (ElementPtr)
X *      Pointer to the element that has been chosen to be the pivot.
X *  LargestElementMag  (RealNumber)
X *      Magnitude of the largest element yet found in the reduced submatrix.
X *  Size  (int)
X *      Local version of Size; placed in a register for speed.
X *  Magnitude  (RealNumber)
X *      Absolute value of diagonal element.
X *  MinMarkowitzProduct  (long)
X *      Smallest Markowitz product found of pivot candidates which are
X *      acceptable.
X *  NumberOfTies  (int)
X *      A count of the number of Markowitz ties that have occurred at current
X *      MarkowitzProduct.
X *  pElement  (ElementPtr)
X *      Pointer to current element.
X *  pLargestElement  (ElementPtr)
X *      Pointer to the largest element yet found in the reduced submatrix.
X *  Product  (long)
X *      Markowitz product for the current row and column.
X *  Ratio  (RealNumber)
X *      For the current pivot candidate, Ratio is the
X *      Ratio of the largest element in its column to its magnitude.
X *  RatioOfAccepted  (RealNumber)
X *      For the best pivot candidate found so far, RatioOfAccepted is the
X *      Ratio of the largest element in its column to its magnitude.
X *
X *  >>> Possible errors:
X *  spSINGULAR
X *  spSMALL_PIVOT
X */
X
static ElementPtr
SearchEntireMatrix(
X    MatrixPtr Matrix,
X    int Step
)
{
register  int  I, Size = Matrix->Size;
register  ElementPtr  pElement;
int  NumberOfTies;
long  Product, MinMarkowitzProduct;
ElementPtr  ChosenPivot, pLargestElement;
RealNumber  Magnitude, LargestElementMag, Ratio, RatioOfAccepted, LargestInCol;
RealNumber  FindLargestInCol();
X
/* Begin `SearchEntireMatrix'. */
X    ChosenPivot = NULL;
X    LargestElementMag = 0.0;
X    MinMarkowitzProduct = LARGEST_LONG_INTEGER;
X
/* Start search of matrix on column by column basis. */
X    for (I = Step; I <= Size; I++)
X    {   pElement = Matrix->FirstInCol[I];
X
X        while (pElement != NULL AND pElement->Row < Step)
X            pElement = pElement->NextInCol;
X
X        if((LargestInCol = FindLargestInCol(pElement)) == 0.0)
X            continue; /* for loop */
X
X        while (pElement != NULL)
X        {
/* Check to see if element is the largest encountered so far.  If so, record
X   its magnitude and address. */
X            if ((Magnitude = ELEMENT_MAG(pElement)) > LargestElementMag)
X            {   LargestElementMag = Magnitude;
X                pLargestElement = pElement;
X            }
/* Calculate element's MarkowitzProduct. */
X            spcMarkoProd( Product, Matrix->MarkowitzRow[pElement->Row],
X			  Matrix->MarkowitzCol[pElement->Col] );
X
/* Test to see if element is acceptable as a pivot candidate. */
X            if ((Product <= MinMarkowitzProduct) AND
X                (Magnitude > Matrix->RelThreshold * LargestInCol) AND
X                (Magnitude > Matrix->AbsThreshold))
X            {
/* Test to see if element has lowest MarkowitzProduct yet found, or whether it
X   is tied with an element found earlier. */
X                if (Product < MinMarkowitzProduct)
X                {
/* Notice strict inequality in test. This is a new smallest MarkowitzProduct. */
X                    ChosenPivot = pElement;
X                    MinMarkowitzProduct = Product;
X                    RatioOfAccepted = LargestInCol / Magnitude;
X                    NumberOfTies = 0;
X                }
X                else
X                {
/* This case handles Markowitz ties. */
X                    NumberOfTies++;
X                    Ratio = LargestInCol / Magnitude;
X                    if (Ratio < RatioOfAccepted)
X                    {   ChosenPivot = pElement;
X                        RatioOfAccepted = Ratio;
X                    }
X                    if (NumberOfTies >= MinMarkowitzProduct * TIES_MULTIPLIER)
X                        return ChosenPivot;
X                }
X            }
X            pElement = pElement->NextInCol;
X        }  /* End of while(pElement != NULL) */
X    } /* End of for(Step) */
X
X    if (ChosenPivot != NULL) return ChosenPivot;
X
X    if (LargestElementMag == 0.0)
X    {   Matrix->Error = spSINGULAR;
X        return NULL;
X    }
X
X    Matrix->Error = spSMALL_PIVOT;
X    return pLargestElement;
}
X
X
X
X
X
X
X
X
X
X
X
X
/*
X *  DETERMINE THE MAGNITUDE OF THE LARGEST ELEMENT IN A COLUMN
X *
X *  This routine searches a column and returns the magnitude of the largest
X *  element.  This routine begins the search at the element pointed to by
X *  pElement, the parameter.
X *
X *  The search is conducted by starting at the element specified by a pointer,
X *  which should be one below the diagonal, and moving down the column.  On
X *  the way down the column, the magnitudes of the elements are tested to see
X *  if they are the largest yet found.
X *
X *  >>> Returned:
X *  The magnitude of the largest element in the column below and including
X *  the one pointed to by the input parameter.
X *
X *  >>> Arguments:
X *  pElement  <input>  (ElementPtr)
X *      The pointer to the first element to be tested.  Also, used by the
X *      routine to access all lower elements in the column.
X *
X *  >>> Local variables:
X *  Largest  (RealNumber)
X *      The magnitude of the largest element.
X *  Magnitude  (RealNumber)
X *      The magnitude of the currently active element.
X */
X
static RealNumber
FindLargestInCol( register ElementPtr pElement )
{
RealNumber  Magnitude, Largest = 0.0;
X
/* Begin `FindLargestInCol'. */
/* Search column for largest element beginning at Element. */
X    while (pElement != NULL)
X    {   if ((Magnitude = ELEMENT_MAG(pElement)) > Largest)
X            Largest = Magnitude;
X        pElement = pElement->NextInCol;
X    }
X
X    return Largest;
}
X
X
X
X
X
X
X
X
X
X
/*
X *  DETERMINE THE MAGNITUDE OF THE LARGEST ELEMENT IN A COLUMN
X *  EXCLUDING AN ELEMENT
X *
X *  This routine searches a column and returns the magnitude of the largest
X *  element.  One given element is specifically excluded from the search.
X *
X *  The search is conducted by starting at the first element in the column
X *  and moving down the column until the active part of the matrix is entered,
X *  i.e. the reduced submatrix.  The rest of the column is then traversed
X *  looking for the largest element.
X *
X *  >>> Returned:
X *  The magnitude of the largest element in the active portion of the column,
X *  excluding the specified element, is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>    (MatrixPtr)
X *      Pointer to the matrix.
X *  pElement  <input>  (ElementPtr)
X *      The pointer to the element that is to be excluded from search. Column
X *      to be searched is one that contains this element.  Also used to
X *      access the elements in the column.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.  Indicates where
X *      the active part of the matrix begins.
X *
X *  >>> Local variables:
X *  Col  (int)
X *      The number of the column to be searched.  Also the column number of
X *      the element to be avoided in the search.
X *  Largest  (RealNumber)
X *      The magnitude of the largest element.
X *  Magnitude  (RealNumber)
X *      The magnitude of the currently active element.
X *  Row  (int)
X *      The row number of element to be excluded from the search.
X */
X
static RealNumber
FindBiggestInColExclude(
X    MatrixPtr Matrix,
X    register ElementPtr pElement,
X    register int Step
)
{
register  int  Row;
int  Col;
RealNumber  Largest, Magnitude;
X
/* Begin `FindBiggestInColExclude'. */
X    Row = pElement->Row;
X    Col = pElement->Col;
X    pElement = Matrix->FirstInCol[Col];
X
/* Travel down column until reduced submatrix is entered. */
X    while ((pElement != NULL) AND (pElement->Row < Step))
X        pElement = pElement->NextInCol;
X
/* Initialize the variable Largest. */
X    if (pElement->Row != Row)
X        Largest = ELEMENT_MAG(pElement);
X    else
X        Largest = 0.0;
X
/* Search rest of column for largest element, avoiding excluded element. */
X    while ((pElement = pElement->NextInCol) != NULL)
X    {   if ((Magnitude = ELEMENT_MAG(pElement)) > Largest)
X        {   if (pElement->Row != Row)
X                Largest = Magnitude;
X        }
X    }
X
X    return Largest;
}
X
X
X
X
X
X
X
X
X
X
/*
X *  EXCHANGE ROWS AND COLUMNS
X *
X *  Exchanges two rows and two columns so that the selected pivot is moved to
X *  the upper left corner of the remaining submatrix.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  pPivot  <input>  (ElementPtr)
X *      Pointer to the current pivot.
X *  Step  <input>  (int)
X *      Index of the diagonal currently being eliminated.
X *
X *  >>> Local variables:
X *  Col  (int)
X *      Column where the pivot was found.
X *  Row  (int)
X *      Row where the pivot was found.
X *  OldMarkowitzProd_Col  (long)
X *      Markowitz product associated with the diagonal element in the row
X *      the pivot was found in.
X *  OldMarkowitzProd_Row  (long)
X *      Markowitz product associated with the diagonal element in the column
X *      the pivot was found in.
X *  OldMarkowitzProd_Step  (long)
X *      Markowitz product associated with the diagonal element that is being
X *      moved so that the pivot can be placed in the upper left-hand corner
X *      of the reduced submatrix.
X */
X
static void
ExchangeRowsAndCols( 
X    MatrixPtr Matrix,
X    ElementPtr pPivot,
X    register int Step
)
{
register  int   Row, Col;
long  OldMarkowitzProd_Step, OldMarkowitzProd_Row, OldMarkowitzProd_Col;
X
/* Begin `ExchangeRowsAndCols'. */
X    Row = pPivot->Row;
X    Col = pPivot->Col;
X    Matrix->PivotsOriginalRow = Row;
X    Matrix->PivotsOriginalCol = Col;
X
X    if ((Row == Step) AND (Col == Step)) return;
X
/* Exchange rows and columns. */
X    if (Row == Col)
X    {   spcRowExchange( Matrix, Step, Row );
X        spcColExchange( Matrix, Step, Col );
X        SWAP( long, Matrix->MarkowitzProd[Step], Matrix->MarkowitzProd[Row] );
X        SWAP( ElementPtr, Matrix->Diag[Row], Matrix->Diag[Step] );
X    }
X    else
X    {
X
/* Initialize variables that hold old Markowitz products. */
X        OldMarkowitzProd_Step = Matrix->MarkowitzProd[Step];
X        OldMarkowitzProd_Row = Matrix->MarkowitzProd[Row];
X        OldMarkowitzProd_Col = Matrix->MarkowitzProd[Col];
X
/* Exchange rows. */
X        if (Row != Step)
X        {   spcRowExchange( Matrix, Step, Row );
X            Matrix->NumberOfInterchangesIsOdd =
X                                       NOT Matrix->NumberOfInterchangesIsOdd;
X            spcMarkoProd( Matrix->MarkowitzProd[Row],
X                          Matrix->MarkowitzRow[Row],
X			  Matrix->MarkowitzCol[Row] );
X
/* Update singleton count. */
X            if ((Matrix->MarkowitzProd[Row]==0) != (OldMarkowitzProd_Row==0))
X            {   if (OldMarkowitzProd_Row == 0)
X                    Matrix->Singletons--;
X                else
X                    Matrix->Singletons++;
X            }
X        }
X
/* Exchange columns. */
X        if (Col != Step)
X        {   spcColExchange( Matrix, Step, Col );
X            Matrix->NumberOfInterchangesIsOdd =
X                                       NOT Matrix->NumberOfInterchangesIsOdd;
X            spcMarkoProd( Matrix->MarkowitzProd[Col],
X	    	          Matrix->MarkowitzCol[Col],
X			  Matrix->MarkowitzRow[Col] );
X
/* Update singleton count. */
X            if ((Matrix->MarkowitzProd[Col]==0) != (OldMarkowitzProd_Col==0))
X            {   if (OldMarkowitzProd_Col == 0)
X                    Matrix->Singletons--;
X                else
X                    Matrix->Singletons++;
X            }
X
X            Matrix->Diag[Col] = spcFindDiag( Matrix, Col );
X        }
X        if (Row != Step)
X            Matrix->Diag[Row] = spcFindDiag( Matrix, Row );
X        Matrix->Diag[Step] = spcFindDiag( Matrix, Step );
X
/* Update singleton count. */
X        Matrix->MarkowitzProd[Step] = Matrix->MarkowitzCol[Step] *
X                                                    Matrix->MarkowitzRow[Step];
X        if ((Matrix->MarkowitzProd[Step]==0) != (OldMarkowitzProd_Step==0))
X        {   if (OldMarkowitzProd_Step == 0)
X                Matrix->Singletons--;
X            else
X                Matrix->Singletons++;
X        }
X    }
X    return;
}
X
X
X
X
X
X
X
X
X
/*
X *  EXCHANGE ROWS
X *
X *  Performs all required operations to exchange two rows. Those operations
X *  include: swap FirstInRow pointers, fixing up the NextInCol pointers,
X *  swapping row indexes in MatrixElements, and swapping Markowitz row
X *  counts.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  Row1  <input>  (int)
X *      Row index of one of the rows, becomes the smallest index.
X *  Row2  <input>  (int)
X *      Row index of the other row, becomes the largest index.
X *
X *  Local variables:
X *  Column  (int)
X *      Column in which row elements are currently being exchanged.
X *  Row1Ptr  (ElementPtr)
X *      Pointer to an element in Row1.
X *  Row2Ptr  (ElementPtr)
X *      Pointer to an element in Row2.
X *  Element1  (ElementPtr)
X *      Pointer to the element in Row1 to be exchanged.
X *  Element2  (ElementPtr)
X *      Pointer to the element in Row2 to be exchanged.
X */
X
void
spcRowExchange(
X    MatrixPtr Matrix,
X    int Row1,
X    int Row2
)
{
register  ElementPtr  Row1Ptr, Row2Ptr;
int  Column;
ElementPtr  Element1, Element2;
X
/* Begin `spcRowExchange'. */
X    if (Row1 > Row2)  SWAP(int, Row1, Row2);
X
X    Row1Ptr = Matrix->FirstInRow[Row1];
X    Row2Ptr = Matrix->FirstInRow[Row2];
X    while (Row1Ptr != NULL OR Row2Ptr != NULL)
X    {
/* Exchange elements in rows while traveling from left to right. */
X        if (Row1Ptr == NULL)
X        {   Column = Row2Ptr->Col;
X            Element1 = NULL;
X            Element2 = Row2Ptr;
X            Row2Ptr = Row2Ptr->NextInRow;
X        }
X        else if (Row2Ptr == NULL)
X        {   Column = Row1Ptr->Col;
X            Element1 = Row1Ptr;
X            Element2 = NULL;
X            Row1Ptr = Row1Ptr->NextInRow;
X        }
X        else if (Row1Ptr->Col < Row2Ptr->Col)
X        {   Column = Row1Ptr->Col;
X            Element1 = Row1Ptr;
X            Element2 = NULL;
X            Row1Ptr = Row1Ptr->NextInRow;
X        }
X        else if (Row1Ptr->Col > Row2Ptr->Col)
X        {   Column = Row2Ptr->Col;
X            Element1 = NULL;
X            Element2 = Row2Ptr;
X            Row2Ptr = Row2Ptr->NextInRow;
X        }
X        else   /* Row1Ptr->Col == Row2Ptr->Col */
X        {   Column = Row1Ptr->Col;
X            Element1 = Row1Ptr;
X            Element2 = Row2Ptr;
X            Row1Ptr = Row1Ptr->NextInRow;
X            Row2Ptr = Row2Ptr->NextInRow;
X        }
X
X        ExchangeColElements( Matrix, Row1, Element1, Row2, Element2, Column);
X    }  /* end of while(Row1Ptr != NULL OR Row2Ptr != NULL) */
X
X    if (Matrix->InternalVectorsAllocated)
X        SWAP( int, Matrix->MarkowitzRow[Row1], Matrix->MarkowitzRow[Row2]);
X    SWAP( ElementPtr, Matrix->FirstInRow[Row1], Matrix->FirstInRow[Row2]);
X    SWAP( int, Matrix->IntToExtRowMap[Row1], Matrix->IntToExtRowMap[Row2]);
#if TRANSLATE
X    Matrix->ExtToIntRowMap[ Matrix->IntToExtRowMap[Row1] ] = Row1;
X    Matrix->ExtToIntRowMap[ Matrix->IntToExtRowMap[Row2] ] = Row2;
#endif
X
X    return;
}
X
X
X
X
X
X
X
X
X
/*
X *  EXCHANGE COLUMNS
X *
X *  Performs all required operations to exchange two columns. Those operations
X *  include: swap FirstInCol pointers, fixing up the NextInRow pointers,
X *  swapping column indexes in MatrixElements, and swapping Markowitz 
X *  column counts.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  Col1  <input>  (int)
X *      Column index of one of the columns, becomes the smallest index.
X *  Col2  <input>  (int)
X *      Column index of the other column, becomes the largest index
X *
X *  Local variables:
X *  Row  (int)
X *      Row in which column elements are currently being exchanged.
X *  Col1Ptr  (ElementPtr)
X *      Pointer to an element in Col1.
X *  Col2Ptr  (ElementPtr)
X *      Pointer to an element in Col2.
X *  Element1  (ElementPtr)
X *      Pointer to the element in Col1 to be exchanged.
X *  Element2  (ElementPtr)
X *      Pointer to the element in Col2 to be exchanged.
X */
X
void
spcColExchange(
X    MatrixPtr Matrix,
X    int Col1,
X    int Col2
)
{
register  ElementPtr  Col1Ptr, Col2Ptr;
int  Row;
ElementPtr  Element1, Element2;
X
/* Begin `spcColExchange'. */
X    if (Col1 > Col2)  SWAP(int, Col1, Col2);
X
X    Col1Ptr = Matrix->FirstInCol[Col1];
X    Col2Ptr = Matrix->FirstInCol[Col2];
X    while (Col1Ptr != NULL OR Col2Ptr != NULL)
X    {
/* Exchange elements in rows while traveling from top to bottom. */
X        if (Col1Ptr == NULL)
X        {   Row = Col2Ptr->Row;
X            Element1 = NULL;
X            Element2 = Col2Ptr;
X            Col2Ptr = Col2Ptr->NextInCol;
X        }
X        else if (Col2Ptr == NULL)
X        {   Row = Col1Ptr->Row;
X            Element1 = Col1Ptr;
X            Element2 = NULL;
X            Col1Ptr = Col1Ptr->NextInCol;
X        }
X        else if (Col1Ptr->Row < Col2Ptr->Row)
X        {   Row = Col1Ptr->Row;
X            Element1 = Col1Ptr;
X            Element2 = NULL;
X            Col1Ptr = Col1Ptr->NextInCol;
X        }
X        else if (Col1Ptr->Row > Col2Ptr->Row)
X        {   Row = Col2Ptr->Row;
X            Element1 = NULL;
X            Element2 = Col2Ptr;
X            Col2Ptr = Col2Ptr->NextInCol;
X        }
X        else   /* Col1Ptr->Row == Col2Ptr->Row */
X        {   Row = Col1Ptr->Row;
X            Element1 = Col1Ptr;
X            Element2 = Col2Ptr;
X            Col1Ptr = Col1Ptr->NextInCol;
X            Col2Ptr = Col2Ptr->NextInCol;
X        }
X
X        ExchangeRowElements( Matrix, Col1, Element1, Col2, Element2, Row);
X    }  /* end of while(Col1Ptr != NULL OR Col2Ptr != NULL) */
X
X    if (Matrix->InternalVectorsAllocated)
X        SWAP( int, Matrix->MarkowitzCol[Col1], Matrix->MarkowitzCol[Col2]);
X    SWAP( ElementPtr, Matrix->FirstInCol[Col1], Matrix->FirstInCol[Col2]);
X    SWAP( int, Matrix->IntToExtColMap[Col1], Matrix->IntToExtColMap[Col2]);
#if TRANSLATE
X    Matrix->ExtToIntColMap[ Matrix->IntToExtColMap[Col1] ] = Col1;
X    Matrix->ExtToIntColMap[ Matrix->IntToExtColMap[Col2] ] = Col2;
#endif
X
X    return;
}
X
X
X
X
X
X
X
/*
X *  EXCHANGE TWO ELEMENTS IN A COLUMN
X *
X *  Performs all required operations to exchange two elements in a column.
X *  Those operations are: restring NextInCol pointers and swapping row indexes
X *  in the MatrixElements.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  Row1  <input>  (int)
X *      Row of top element to be exchanged.
X *  Element1  <input>  (ElementPtr)
X *      Pointer to top element to be exchanged.
X *  Row2  <input>  (int)
X *      Row of bottom element to be exchanged.
X *  Element2  <input>  (ElementPtr)
X *      Pointer to bottom element to be exchanged.
X *  Column <input>  (int)
X *      Column that exchange is to take place in.
X *
X *  >>> Local variables:
X *  ElementAboveRow1  (ElementPtr *)
X *      Location of pointer which points to the element above Element1. This
X *      pointer is modified so that it points to correct element on exit.
X *  ElementAboveRow2  (ElementPtr *)
X *      Location of pointer which points to the element above Element2. This
X *      pointer is modified so that it points to correct element on exit.
X *  ElementBelowRow1  (ElementPtr)
X *      Pointer to element below Element1.
X *  ElementBelowRow2  (ElementPtr)
X *      Pointer to element below Element2.
X *  pElement  (ElementPtr)
X *      Pointer used to traverse the column.
X */
X
static void
ExchangeColElements(
X    MatrixPtr Matrix,
X    int  Row1,
X    register ElementPtr Element1,
X    int  Row2,
X    register ElementPtr Element2,
X    int  Column
)
{
ElementPtr  *ElementAboveRow1, *ElementAboveRow2;
ElementPtr  ElementBelowRow1, ElementBelowRow2;
register  ElementPtr  pElement;
X
/* Begin `ExchangeColElements'. */
/* Search to find the ElementAboveRow1. */
X    ElementAboveRow1 = &(Matrix->FirstInCol[Column]);
X    pElement = *ElementAboveRow1;
X    while (pElement->Row < Row1)
X    {   ElementAboveRow1 = &(pElement->NextInCol);
X        pElement = *ElementAboveRow1;
X    }
X    if (Element1 != NULL)
X    {   ElementBelowRow1 = Element1->NextInCol;
X        if (Element2 == NULL)
X        {
/* Element2 does not exist, move Element1 down to Row2. */
X            if ( ElementBelowRow1 != NULL AND ElementBelowRow1->Row < Row2 )
X            {
/* Element1 must be removed from linked list and moved. */
X                *ElementAboveRow1 = ElementBelowRow1;
X
/* Search column for Row2. */
X                pElement = ElementBelowRow1;
X                do
X                {   ElementAboveRow2 = &(pElement->NextInCol);
X                    pElement = *ElementAboveRow2;
X                }   while (pElement != NULL AND pElement->Row < Row2);
X
/* Place Element1 in Row2. */
X                *ElementAboveRow2 = Element1;
X                Element1->NextInCol = pElement;
X                *ElementAboveRow1 =ElementBelowRow1;
X            }
X            Element1->Row = Row2;
X        }
X        else
X        {
/* Element2 does exist, and the two elements must be exchanged. */
X            if ( ElementBelowRow1->Row == Row2)
X            {
/* Element2 is just below Element1, exchange them. */
X                Element1->NextInCol = Element2->NextInCol;
X                Element2->NextInCol = Element1;
X                *ElementAboveRow1 = Element2;
X            }
X            else
X            {
/* Element2 is not just below Element1 and must be searched for. */
X                pElement = ElementBelowRow1;
X                do
X                {   ElementAboveRow2 = &(pElement->NextInCol);
X                    pElement = *ElementAboveRow2;
X                }   while (pElement->Row < Row2);
X
X                ElementBelowRow2 = Element2->NextInCol;
X
/* Switch Element1 and Element2. */
X                *ElementAboveRow1 = Element2;
X                Element2->NextInCol = ElementBelowRow1;
X                *ElementAboveRow2 = Element1;
X                Element1->NextInCol = ElementBelowRow2;
X            }
X            Element1->Row = Row2;
X            Element2->Row = Row1;
X        }
X    }
X    else
X    {
/* Element1 does not exist. */
X        ElementBelowRow1 = pElement;
X
/* Find Element2. */
X        if (ElementBelowRow1->Row != Row2)
X        {   do
X            {   ElementAboveRow2 = &(pElement->NextInCol);
X                pElement = *ElementAboveRow2;
X            }   while (pElement->Row < Row2);
X
X        ElementBelowRow2 = Element2->NextInCol;
X
/* Move Element2 to Row1. */
X            *ElementAboveRow2 = Element2->NextInCol;
X            *ElementAboveRow1 = Element2;
X            Element2->NextInCol = ElementBelowRow1;
X        }
X        Element2->Row = Row1;
X    }
X    return;
}
X
X
X
X
X
X
X
/*
X *  EXCHANGE TWO ELEMENTS IN A ROW
X *
X *  Performs all required operations to exchange two elements in a row.
X *  Those operations are: restring NextInRow pointers and swapping column
X *  indexes in the MatrixElements.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  Col1  <input>  (int)
X *      Col of left-most element to be exchanged.
X *  Element1  <input>  (ElementPtr)
X *      Pointer to left-most element to be exchanged.
X *  Col2  <input>  (int)
X *      Col of right-most element to be exchanged.
X *  Element2  <input>  (ElementPtr)
X *      Pointer to right-most element to be exchanged.
X *  Row <input>  (int)
X *      Row that exchange is to take place in.
X *
X *  >>> Local variables:
X *  ElementLeftOfCol1  (ElementPtr *)
X *      Location of pointer which points to the element to the left of
X *      Element1. This pointer is modified so that it points to correct
X *      element on exit.
X *  ElementLeftOfCol2  (ElementPtr *)
X *      Location of pointer which points to the element to the left of
X *      Element2. This pointer is modified so that it points to correct
X *      element on exit.
X *  ElementRightOfCol1  (ElementPtr)
X *      Pointer to element right of Element1.
X *  ElementRightOfCol2  (ElementPtr)
X *      Pointer to element right of Element2.
X *  pElement  (ElementPtr)
X *      Pointer used to traverse the row.
X */
X
static void
ExchangeRowElements(
X    MatrixPtr Matrix,
X    int  Col1,
X    register ElementPtr Element1,
X    int  Col2,
X    register ElementPtr Element2,
X    int  Row
)
{
ElementPtr  *ElementLeftOfCol1, *ElementLeftOfCol2;
ElementPtr  ElementRightOfCol1, ElementRightOfCol2;
register   ElementPtr  pElement;
X
/* Begin `ExchangeRowElements'. */
/* Search to find the ElementLeftOfCol1. */
X    ElementLeftOfCol1 = &(Matrix->FirstInRow[Row]);
X    pElement = *ElementLeftOfCol1;
X    while (pElement->Col < Col1)
X    {   ElementLeftOfCol1 = &(pElement->NextInRow);
X        pElement = *ElementLeftOfCol1;
X    }
X    if (Element1 != NULL)
X    {   ElementRightOfCol1 = Element1->NextInRow;
X        if (Element2 == NULL)
X        {
/* Element2 does not exist, move Element1 to right to Col2. */
X            if ( ElementRightOfCol1 != NULL AND ElementRightOfCol1->Col < Col2 )
X            {
/* Element1 must be removed from linked list and moved. */
X                *ElementLeftOfCol1 = ElementRightOfCol1;
X
/* Search Row for Col2. */
X                pElement = ElementRightOfCol1;
X                do
X                {   ElementLeftOfCol2 = &(pElement->NextInRow);
X                    pElement = *ElementLeftOfCol2;
X                }   while (pElement != NULL AND pElement->Col < Col2);
X
/* Place Element1 in Col2. */
X                *ElementLeftOfCol2 = Element1;
X                Element1->NextInRow = pElement;
X                *ElementLeftOfCol1 =ElementRightOfCol1;
X            }
X            Element1->Col = Col2;
X        }
X        else
X        {
/* Element2 does exist, and the two elements must be exchanged. */
X            if ( ElementRightOfCol1->Col == Col2)
X            {
/* Element2 is just right of Element1, exchange them. */
X                Element1->NextInRow = Element2->NextInRow;
X                Element2->NextInRow = Element1;
X                *ElementLeftOfCol1 = Element2;
X            }
X            else
X            {
/* Element2 is not just right of Element1 and must be searched for. */
X                pElement = ElementRightOfCol1;
X                do
X                {   ElementLeftOfCol2 = &(pElement->NextInRow);
X                    pElement = *ElementLeftOfCol2;
X                }   while (pElement->Col < Col2);
X
X                ElementRightOfCol2 = Element2->NextInRow;
X
/* Switch Element1 and Element2. */
X                *ElementLeftOfCol1 = Element2;
X                Element2->NextInRow = ElementRightOfCol1;
X                *ElementLeftOfCol2 = Element1;
X                Element1->NextInRow = ElementRightOfCol2;
X            }
X            Element1->Col = Col2;
X            Element2->Col = Col1;
X        }
X    }
X    else
X    {
/* Element1 does not exist. */
X        ElementRightOfCol1 = pElement;
X
/* Find Element2. */
X        if (ElementRightOfCol1->Col != Col2)
X        {   do
X            {   ElementLeftOfCol2 = &(pElement->NextInRow);
X                pElement = *ElementLeftOfCol2;
X            }   while (pElement->Col < Col2);
X
X            ElementRightOfCol2 = Element2->NextInRow;
X
/* Move Element2 to Col1. */
X            *ElementLeftOfCol2 = Element2->NextInRow;
X            *ElementLeftOfCol1 = Element2;
X            Element2->NextInRow = ElementRightOfCol1;
X        }
X        Element2->Col = Col1;
X    }
X    return;
}
X
X
X
X
X
X
X
X
X
X
X
/*
X *  PERFORM ROW AND COLUMN ELIMINATION ON REAL MATRIX
X *
X *  Eliminates a single row and column of the matrix and leaves single row of
X *  the upper triangular matrix and a single column of the lower triangular
X *  matrix in its wake.  Uses Gauss's method.
X *
X *  >>> Argument:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  pPivot  <input>  (ElementPtr)
X *      Pointer to the current pivot.
X *
X *  >>> Local variables:
X *  pLower  (ElementPtr)
X *      Points to matrix element in lower triangular column.
X *  pSub (ElementPtr)
X *      Points to elements in the reduced submatrix.
X *  Row  (int)
X *      Row index.
X *  pUpper  (ElementPtr)
X *      Points to matrix element in upper triangular row.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
static void
RealRowColElimination(
X    MatrixPtr Matrix,
X    register ElementPtr pPivot
)
{
#if REAL
register  ElementPtr  pSub, *ppAbove;
register  int  Row;
register  ElementPtr  pLower, pUpper;
X
/* Begin `RealRowColElimination'. */
X
/* Test for zero pivot. */
X    if (ABS(pPivot->Real) == 0.0)
X    {   (void)MatrixIsSingular( Matrix, pPivot->Row );
X        return;
X    }
X    pPivot->Real = 1.0 / pPivot->Real;
X
X    pUpper = pPivot->NextInRow;
X    while (pUpper != NULL)
X    {
/* Calculate upper triangular element. */
X        pUpper->Real *= pPivot->Real;
X
X        pSub = pUpper->NextInCol;
X        pLower = pPivot->NextInCol;
X	ppAbove = &pUpper->NextInCol;
X        while (pLower != NULL)
X        {   Row = pLower->Row;
X
/* Find element in row that lines up with current lower triangular element. */
X            while (pSub != NULL AND pSub->Row < Row)
X	    {   ppAbove = &pSub->NextInCol;
X                pSub = pSub->NextInCol;
X	    }
X
/* Test to see if desired element was not found, if not, create fill-in. */
X            if (pSub == NULL OR pSub->Row > Row)
X            {   pSub = spcCreateElement( Matrix, Row, pUpper->Col,
X					 &pLower->NextInRow, ppAbove, YES );
X                if (pSub == NULL)
X                {   Matrix->Error = spNO_MEMORY;
X                    return;
X                }
X            }
X            pSub->Real -= pUpper->Real * pLower->Real;
X            pSub = pSub->NextInCol;
X            pLower = pLower->NextInCol;
X        }
X        pUpper = pUpper->NextInRow;
X    }
X    return;
#endif /* REAL */
}
X
X
X
X
X
X
X
X
X
/*
X *  PERFORM ROW AND COLUMN ELIMINATION ON COMPLEX MATRIX
X *
X *  Eliminates a single row and column of the matrix and leaves single row of
X *  the upper triangular matrix and a single column of the lower triangular
X *  matrix in its wake.  Uses Gauss's method.
X *
X *  >>> Argument:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  pPivot  <input>  (ElementPtr)
X *      Pointer to the current pivot.
X *
X *  >>> Local variables:
X *  pLower  (ElementPtr)
X *      Points to matrix element in lower triangular column.
X *  pSub (ElementPtr)
X *      Points to elements in the reduced submatrix.
X *  Row  (int)
X *      Row index.
X *  pUpper  (ElementPtr)
X *      Points to matrix element in upper triangular row.
X *
X *  Possible errors:
X *  spNO_MEMORY
X */
X
static void
ComplexRowColElimination(
X    MatrixPtr Matrix,
X    register ElementPtr pPivot
)
{
#if spCOMPLEX
register  ElementPtr  pSub, *ppAbove;
register  int  Row;
register  ElementPtr  pLower, pUpper;
X
/* Begin `ComplexRowColElimination'. */
X
/* Test for zero pivot. */
X    if (ELEMENT_MAG(pPivot) == 0.0)
X    {   (void)MatrixIsSingular( Matrix, pPivot->Row );
X        return;
X    }
X    CMPLX_RECIPROCAL(*pPivot, *pPivot);
X
X    pUpper = pPivot->NextInRow;
X    while (pUpper != NULL)
X    {
/* Calculate upper triangular element. */
/* Cmplx expr: *pUpper = *pUpper * (1.0 / *pPivot). */
X        CMPLX_MULT_ASSIGN(*pUpper, *pPivot);
X
X        pSub = pUpper->NextInCol;
X        pLower = pPivot->NextInCol;
X	ppAbove = &pUpper->NextInCol;
X        while (pLower != NULL)
X        {   Row = pLower->Row;
X
/* Find element in row that lines up with current lower triangular element. */
X            while (pSub != NULL AND pSub->Row < Row)
X	    {   ppAbove = &pSub->NextInCol;
X                pSub = pSub->NextInCol;
X	    }
X
/* Test to see if desired element was not found, if not, create fill-in. */
X            if (pSub == NULL OR pSub->Row > Row)
X            {   pSub = spcCreateElement( Matrix, Row, pUpper->Col,
X					 &pLower->NextInRow, ppAbove, YES );
X                if (pSub == NULL)
X                {   Matrix->Error = spNO_MEMORY;
X                    return;
X                }
X            }
X
/* Cmplx expr: pElement -= *pUpper * pLower. */
X            CMPLX_MULT_SUBT_ASSIGN(*pSub, *pUpper, *pLower);
X            pSub = pSub->NextInCol;
X            pLower = pLower->NextInCol;
X        }
X        pUpper = pUpper->NextInRow;
X    }
X    return;
#endif /* spCOMPLEX */
}
X
X
X
X
X
/*
X *  UPDATE MARKOWITZ NUMBERS
X *
X *  Updates the Markowitz numbers after a row and column have been eliminated.
X *  Also updates singleton count.
X *
X *  >>> Argument:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  pPivot  <input>  (ElementPtr)
X *      Pointer to the current pivot.
X *
X *  >>> Local variables:
X *  Row  (int)
X *      Row index.
X *  Col  (int)
X *      Column index.
X *  ColPtr  (ElementPtr)
X *      Points to matrix element in upper triangular column.
X *  RowPtr  (ElementPtr)
X *      Points to matrix element in lower triangular row.
X */
X
static void
UpdateMarkowitzNumbers(
X    MatrixPtr Matrix,
X    ElementPtr pPivot
)
{
register  int  Row, Col;
register  ElementPtr  ColPtr, RowPtr;
register  int *MarkoRow = Matrix->MarkowitzRow, *MarkoCol = Matrix->MarkowitzCol;
double Product;
X
/* Begin `UpdateMarkowitzNumbers'. */
X
/* Update Markowitz numbers. */
X    for (ColPtr = pPivot->NextInCol; ColPtr != NULL; ColPtr = ColPtr->NextInCol)
X    {   Row = ColPtr->Row;
X        --MarkoRow[Row];
X
/* Form Markowitz product while being cautious of overflows. */
X        if ((MarkoRow[Row] > LARGEST_SHORT_INTEGER AND MarkoCol[Row] != 0) OR
X            (MarkoCol[Row] > LARGEST_SHORT_INTEGER AND MarkoRow[Row] != 0))
X        {   Product = (double)MarkoCol[Row] * (double)MarkoRow[Row];
X            if (Product >= LARGEST_LONG_INTEGER)
X                Matrix->MarkowitzProd[Row] = LARGEST_LONG_INTEGER;
X            else
X                Matrix->MarkowitzProd[Row] = (long)Product;
X        }
X        else Matrix->MarkowitzProd[Row] = MarkoRow[Row] * MarkoCol[Row];
X        if (MarkoRow[Row] == 0)
X            Matrix->Singletons++;
X    }
X
X    for (RowPtr = pPivot->NextInRow; RowPtr != NULL; RowPtr = RowPtr->NextInRow)
X    {   Col = RowPtr->Col;
X        --MarkoCol[Col];
X
/* Form Markowitz product while being cautious of overflows. */
X        if ((MarkoRow[Col] > LARGEST_SHORT_INTEGER AND MarkoCol[Col] != 0) OR
X            (MarkoCol[Col] > LARGEST_SHORT_INTEGER AND MarkoRow[Col] != 0))
X        {   Product = (double)MarkoCol[Col] * (double)MarkoRow[Col];
X            if (Product >= LARGEST_LONG_INTEGER)
X                Matrix->MarkowitzProd[Col] = LARGEST_LONG_INTEGER;
X            else
X                Matrix->MarkowitzProd[Col] = (long)Product;
X        }
X        else Matrix->MarkowitzProd[Col] = MarkoRow[Col] * MarkoCol[Col];
X        if ((MarkoCol[Col] == 0) AND (MarkoRow[Col] != 0))
X            Matrix->Singletons++;
X    }
X    return;
}
X
X
X
X
X
X
/*
X *  ZERO PIVOT ENCOUNTERED
X *
X *  This routine is called when a singular matrix is found.  It then
X *  records the current row and column and exits.
X *
X *  >>> Returned:
X *  The error code spSINGULAR or spZERO_DIAG is returned.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to matrix.
X *  Step  <input>  (int)
X *      Index of diagonal that is zero.
X */
X
static int
MatrixIsSingular(
X    MatrixPtr Matrix,
X    int Step
)
{
/* Begin `MatrixIsSingular'. */
X
X    Matrix->SingularRow = Matrix->IntToExtRowMap[ Step ];
X    Matrix->SingularCol = Matrix->IntToExtColMap[ Step ];
X    return (Matrix->Error = spSINGULAR);
}
X
X
static int
ZeroPivot(
X    MatrixPtr Matrix,
X    int Step
)
{
/* Begin `ZeroPivot'. */
X
X    Matrix->SingularRow = Matrix->IntToExtRowMap[ Step ];
X    Matrix->SingularCol = Matrix->IntToExtColMap[ Step ];
X    return (Matrix->Error = spZERO_DIAG);
}
X
X
X
X
X
X
#if (ANNOTATE == FULL)
X
/*
X *
X *  WRITE STATUS
X *
X *  Write a summary of important variables to standard output.
X */
X
static void
WriteStatus(
X    MatrixPtr Matrix,
X    int Step
)
{
int  I;
X
/* Begin `WriteStatus'. */
X
X    printf("Step = %1d   ", Step);
X    printf("Pivot found at %1d,%1d using ", Matrix->PivotsOriginalRow,
X                                            Matrix->PivotsOriginalCol);
X    switch(Matrix->PivotSelectionMethod)
X    {   case 's': printf("SearchForSingleton\n");  break;
X        case 'q': printf("QuicklySearchDiagonal\n");  break;
X        case 'd': printf("SearchDiagonal\n");  break;
X        case 'e': printf("SearchEntireMatrix\n");  break;
X    }
X
X    printf("MarkowitzRow     = ");
X    for (I = 1; I <= Matrix->Size; I++)
X        printf("%2d  ", Matrix->MarkowitzRow[I]);
X    printf("\n");
X
X    printf("MarkowitzCol     = ");
X    for (I = 1; I <= Matrix->Size; I++)
X        printf("%2d  ", Matrix->MarkowitzCol[I]);
X    printf("\n");
X
X    printf("MarkowitzProduct = ");
X    for (I = 1; I <= Matrix->Size; I++)
X        printf("%2d  ", Matrix->MarkowitzProd[I]);
X    printf("\n");
X
X    printf("Singletons = %2d\n", Matrix->Singletons);
X
X    printf("IntToExtRowMap     = ");
X    for (I = 1; I <= Matrix->Size; I++)
X        printf("%2d  ", Matrix->IntToExtRowMap[I]);
X    printf("\n");
X
X    printf("IntToExtColMap     = ");
X    for (I = 1; I <= Matrix->Size; I++)
X        printf("%2d  ", Matrix->IntToExtColMap[I]);
X    printf("\n");
X
X    printf("ExtToIntRowMap     = ");
X    for (I = 1; I <= Matrix->ExtSize; I++)
X        printf("%2d  ", Matrix->ExtToIntRowMap[I]);
X    printf("\n");
X
X    printf("ExtToIntColMap     = ");
X    for (I = 1; I <= Matrix->ExtSize; I++)
X        printf("%2d  ", Matrix->ExtToIntColMap[I]);
X    printf("\n\n");
X
/*  spPrint((char *)Matrix, NO, YES);  */
X
X    return;
X
}
#endif /* ANNOTATE == FULL */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spFactor.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spFactor.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spFactor.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spFactor.c: MD5 check failed'
       ) << \SHAR_EOF
b19227b1d98c9cb5516f01b2d092177c  sparse/spFactor.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spFactor.c'` -ne 98805 && \
  ${echo} 'restoration warning:  size of sparse/spFactor.c is not 98805'
  fi
fi
# ============= sparse/spFortran.c ==============
if test -f 'sparse/spFortran.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spFortran.c (file already exists)'
else
${echo} 'x - extracting sparse/spFortran.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spFortran.c' &&
/*
X *  SPARSE FORTRAN MODULE
X *
X *  Author:			Advising professor:
X *     Kenneth S. Kundert	    Alberto Sangiovanni-Vincentelli
X *     UC Berkeley
X */
/*! \file
*
X *  This module contains routines that interface Sparse1.4 to a calling
X *  program written in fortran.  Almost every externally available Sparse1.4
X *  routine has a counterpart defined in this file, with the name the
X *  same except the \a sp prefix is changed to \a sf.  The \a spADD_ELEMENT
X *  and \a spADD_QUAD macros are also replaced with the \a sfAdd1 and \a sfAdd4
X *  functions defined in this file.
X *
X *  To ease porting this file to different operating systems, the names of
X *  the functions can be easily redefined (search for `Routine Renaming').
X *  A simple example of a FORTRAN program that calls Sparse is included in
X *  this file (search for Example).  When interfacing to a FORTRAN program,
X *  the ARRAY_OFFSET option should be set to NO (see spConfig.h).
X *
X *  DISCLAIMER:
X *  These interface routines were written by a C programmer who has little
X *  experience with FORTRAN.  The routines have had minimal testing.
X *  Any interface between two languages is going to have portability
X *  problems, this one is no exception.
X */
/*  >>> User accessible functions contained in this file:
X *  sfCreate()
X *  sfDestroy()
X *  sfStripFills()
X *  sfClear()
X *  sfGetElement()
X *  sfGetAdmittance()
X *  sfGetQuad()
X *  sfGetOnes()
X *  sfAdd1Real()
X *  sfAdd1Imag()
X *  sfAdd1Complex()
X *  sfAdd4Real()
X *  sfAdd4Imag()
X *  sfAdd4Complex()
X *  sfOrderAndFactor()
X *  sfFactor()
X *  sfPartition()
X *  sfSolve()
X *  sfSolveTransposed()
X *  sfPrint()
X *  sfFileMatrix()
X *  sfFileVector()
X *  sfFileStats()
X *  sfMNA_Preorder()
X *  sfScale()
X *  sfMultiply()
X *  sfMultTransposed()
X *  sfDeterminant()
X *  sfError()
X *  sfErrorMessage()
X *  sfWhereSingular()
X *  sfGetSize()
X *  sfSetReal()
X *  sfSetComplex()
X *  sfFillinCount()
X *  sfElementCount()
X *  sfDeleteRowAndCol()
X *  sfPseudoCondition()
X *  sfCondition()
X *  sfNorm()
X *  sfLargestElement()
X *  sfRoundoff()
X */
X
/*
X *  FORTRAN -- C COMPATIBILITY
X *
X *  Fortran and C data types correspond in the following way:
X *  -- C --	-- FORTRAN --
X *  int		INTEGER*4 or INTEGER*2 (machine dependent, usually int*4)
X *  long	INTEGER*4
X *  float	REAL
X *  double	DOUBLE PRECISION (used by default in preference to float)
X *  
X *  The complex number format used by Sparse is compatible with that
X *  used by FORTRAN.  C pointers are passed to FORTRAN as longs, they should
X *  not be used in any way in FORTRAN.
X */
X  
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spFortran.c,v 1.3 2003/06/30 19:40:51 kundert Exp $";
#endif
X
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *     Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *     Macros and declarations to be imported by the user.
X *  spDefs.h
X *     Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
#if FORTRAN
X
X
X
X
/*
X *  Routine Renaming
X */
X
#define sfCreate		sfcreate
#define sfStripFills		sfstripfills
#define sfDestroy		sfdestroy
#define sfClear			sfclear
#define sfGetElement		sfgetelement
#define sfGetAdmittance		sfgetadmittance
#define sfGetQuad		sfgetquad
#define sfGetOnes		sfgetones
#define sfAdd1Real		sfadd1real
#define sfAdd1Imag		sfadd1imag
#define sfAdd1Complex		sfadd1complex
#define sfAdd4Real		sfadd4real
#define sfAdd4Imag		sfadd4imag
#define sfAdd4Complex		sfadd4complex
#define sfOrderAndFactor	sforderandfactor
#define sfFactor		sffactor
#define sfPartition		sfpartition
#define sfSolve			sfsolve
#define sfSolveTransposed	sfsolvetransposed
#define sfPrint			sfprint
#define sfFileMatrix		sffilematrix
#define sfFileVector		sffilevector
#define sfFileStats		sffilestats
#define sfMNA_Preorder		sfmna_preorder
#define sfScale			sfscale
#define sfMultiply		sfmultiply
#define sfMultTransposed	sfmulttransposed
#define sfDeterminant		sfdeterminant
#define sfError			sferror
#define sfErrorMessage		sferrormessage
#define sfWhereSingular		sfwheresingular
#define sfGetSize		sfgetsize
#define sfSetReal		sfsetreal
#define sfSetComplex		sfsetcomplex
#define sfFillinCount		sffillincount
#define sfElementCount		sfelementcount
#define sfDeleteRowAndCol	sfdeleterowandcol
#define sfPseudoCondition	sfpseudocondition
#define sfCondition		sfcondition
#define sfNorm			sfnorm
#define sfLargestElement	sflargestelement
#define sfRoundoff		sfroundoff
X
X
#define MATRIX_FILE_NAME	"spMatrix"
#define STATS_FILE_NAME		"spStats"
X
/*
X *
X *  Example of a FORTRAN Program Calling Sparse
X *
X
X      integer matrix, error, sfCreate, sfGetElement, spFactor
X      integer element(10)
X      double precision rhs(4), solution(4)
c
X      matrix = sfCreate(4,0,error)
X      element(1) = sfGetElement(matrix,1,1)
X      element(2) = sfGetElement(matrix,1,2)
X      element(3) = sfGetElement(matrix,2,1)
X      element(4) = sfGetElement(matrix,2,2)
X      element(5) = sfGetElement(matrix,2,3)
X      element(6) = sfGetElement(matrix,3,2)
X      element(7) = sfGetElement(matrix,3,3)
X      element(8) = sfGetElement(matrix,3,4)
X      element(9) = sfGetElement(matrix,4,3)
X      element(10) = sfGetElement(matrix,4,4)
X      call sfClear(matrix)
X      call sfAdd1Real(element(1), 2d0)
X      call sfAdd1Real(element(2), -1d0)
X      call sfAdd1Real(element(3), -1d0)
X      call sfAdd1Real(element(4), 3d0)
X      call sfAdd1Real(element(5), -1d0)
X      call sfAdd1Real(element(6), -1d0)
X      call sfAdd1Real(element(7), 3d0)
X      call sfAdd1Real(element(8), -1d0)
X      call sfAdd1Real(element(9), -1d0)
X      call sfAdd1Real(element(10), 3d0)
X      call sfprint(matrix, .false., .false.)
X      rhs(1) = 34d0
X      rhs(2) = 0d0
X      rhs(3) = 0d0
X      rhs(4) = 0d0
X      error = sfFactor(matrix)
X      call sfSolve(matrix, rhs, solution)
X      write (6, 10) rhs(1), rhs(2), rhs(3), rhs(4)
X   10 format (f 10.2)
X      end
X
X *
X */
X
X
X
X
X
X
/*  MATRIX ALLOCATION */
/*!
X *  Allocates and initializes the data structures associated with a matrix.
X *
X *  \return [INTEGER]
X *  A pointer to the matrix is returned cast into an integer.  This pointer
X *  is then passed and used by the other matrix routines to refer to a
X *  particular matrix.  If an error occurs, the NULL pointer is returned.
X *
X *  \param Size [INTEGER]
X *	Size of matrix or estimate of size of matrix if matrix is \a EXPANDABLE.
X *  \param Complex  [INTEGER or INTEGER*2]
X *	Type of matrix.  If \a Complex is 0 then the matrix is real, otherwise
X *	the matrix will be complex.
X *	Note that if a matrix will be both real and complex, it must
X *	be specified here as being complex.
X *  \param Error  [INTEGER or INTEGER*2]
X *	Returns error flag, needed because function spError() will not work
X *	correctly if spCreate() returns NULL. Possible errors include \a spNO_MEMORY.
X */
X
long
sfCreate( int *Size, int *Complex, int *Error )
{
/* Begin `sfCreate'. */
X    return (long)spCreate(*Size, *Complex, Error );
}
X
X
X
X
X
X
/*  MATRIX DEALLOCATION */
/*!
X *  Deallocates pointers and elements of matrix.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to the matrix frame which is to be removed from memory.
X */
X
void
sfDestroy( long *Matrix )
{
/* Begin `sfDestroy'. */
X    spDestroy((spMatrix)*Matrix);
X    return;
}
X
X
X
X
X
X
#if STRIP
X
/*  STRIP FILL-INS FROM MATRIX */
/*!
X *  Strips the matrix of all fill-ins.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to the matrix to be stripped.
X */
X
void
sfStripFills( long *Matrix )
{
/* Begin `sfStripFills'. */
X    spStripFills((spMatrix)*Matrix);
X    return;
}
#endif
X
X
X
X
X
X
X
/*  CLEAR MATRIX */
/*!
X *  Sets every element of the matrix to zero and clears the error flag.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to matrix that is to be cleared.
X */
X
void
sfClear( long *Matrix )
{
/* Begin `sfClear'. */
X    spClear((spMatrix)*Matrix);
X    return;
}
X
X
X
X
X
X
/*  SINGLE ELEMENT ADDITION TO MATRIX BY INDEX */
/*!
X *  Finds element [Row,Col] and returns a pointer to it.  If element is
X *  not found then it is created and spliced into matrix.  This routine
X *  is only to be used after spCreate() and before spMNA_Preorder(),
X *  spFactor() or spOrderAndFactor().  Returns a pointer to the
X *  Real portion of a matrix element.  This pointer is later used by
X *  sfAddxxxxx() to directly access element.
X *
X *  \return [INTEGER]
X *  Returns a pointer to the element.  This pointer is then used to directly
X *  access the element during successive builds. Returns NULL if \a spNO_MEMORY
X *  error occurs. Error is not cleared in this routine.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix that the element is to be added to.
X *  \param Row [INTEGER or INTEGER*2]
X *     Row index for element.  Must be in the range of [0..Size] unless
X *     the options \a EXPANDABLE or \a TRANSLATE are used. Elements placed in
X *     row zero are discarded.  In no case may \a Row be less than zero.
X *  \param Col [INTEGER or INTEGER*2]
X *     Column index for element.  Must be in the range of [0..Size] unless
X *     the options \a EXPANDABLE or \a TRANSLATE are used. Elements placed in
X *     column zero are discarded.  In no case may \a Col be less than zero.
X */
X
long
sfGetElement( long *Matrix, int *Row, int *Col )
{
/* Begin `sfGetElement'. */
X    return (long)spGetElement((spMatrix)*Matrix, *Row, *Col);
}
X
X
X
X
X
X
X
#if QUAD_ELEMENT
/*  ADDITION OF ADMITTANCE TO MATRIX BY INDEX */
/*!
X *  Performs same function as sfGetElement() except rather than one
X *  element, all four Matrix elements for a floating component are
X *  added.  This routine also works if component is grounded.  Positive
X *  elements are placed at [Node1,Node2] and [Node2,Node1].  This
X *  routine is only to be used after sfCreate() and before
X *  sfMNA_Preorder(), sfFactor() or sfOrderAndFactor().
X *
X *  \return [INTEGER or INTEGER*2]
X *  The error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix that component is to be entered in.
X *  \param Node1 [INTEGER or INTEGER*2]
X *     Row and column indices for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Node zero is the
X *     ground node.  In no case may \a Node1 be less than zero.
X *  \param Node2 [INTEGER or INTEGER*2]
X *     Row and column indices for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Node zero is the
X *     ground node.  In no case may \a Node2 be less than zero.
X *  \param Template [INTEGER (4)]
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
int
sfGetAdmittance( long *Matrix, int *Node1, int *Node2, long Template[4] )
{
/* Begin `spGetAdmittance'. */
X    return
X    (   spGetAdmittance((spMatrix)*Matrix, *Node1, *Node2,
X			(struct spTemplate *)Template )
X    );
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
X
X
#if QUAD_ELEMENT
/*  ADDITION OF FOUR ELEMENTS TO MATRIX BY INDEX */
/*!
X *  Similar to sfGetAdmittance(), except that sfGetAdmittance() only
X *  handles 2-terminal components, whereas sfGetQuad() handles simple
X *  4-terminals as well.  These 4-terminals are simply generalized
X *  2-terminals with the option of having the sense terminals different
X *  from the source and sink terminals.  sfGetQuad() adds four
X *  elements to the matrix.  Positive elements occur at Row1,Col1
X *  Row2,Col2 while negative elements occur at Row1,Col2 and Row2,Col1.
X *  The routine works fine if any of the rows and columns are zero.
X *  This routine is only to be used after sfCreate() and before
X *  sfMNA_Preorder(), sfFactor() or sfOrderAndFactor()
X *  unless TRANSLATE is set true.
X *
X *  \return [INTEGER or INTEGER*2]
X *  Error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix that component is to be entered in.
X *  \param Row1 [INTEGER or INTEGER*2]
X *     First row index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Row1 be less than zero.
X *  \param Row2 [INTEGER or INTEGER*2]
X *     Second row index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Row2 be less than zero.
X *  \param Col1 [INTEGER or INTEGER*2]
X *     First column index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground column.  In no case may \a Col1 be less than zero.
X *  \param Col2 [INTEGER or INTEGER*2]
X *     Second column index for elements. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground column.  In no case may \a Col2 be less than zero.
X *  \param Template [INTEGER (4)]
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
int
sfGetQuad( long *Matrix, int *Row1, int *Row2, int *Col1, int *Col2, long Template[4] )
{
/* Begin `spGetQuad'. */
X    return
X    (   spGetQuad( (spMatrix)*Matrix, *Row1, *Row2, *Col1, *Col2,
X		   (struct spTemplate *)Template )
X    );
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
X
X
#if QUAD_ELEMENT
/*  ADDITION OF FOUR STRUCTURAL ONES TO MATRIX BY INDEX */
/*!
X *  Performs similar function to sfGetQuad() except this routine is
X *  meant for components that do not have an admittance representation.
X *
X *  The following stamp is used: \code
X *         Pos  Neg  Eqn
X *  Pos  [  .    .    1  ]
X *  Neg  [  .    .   -1  ]
X *  Eqn  [  1   -1    .  ]
X *  \endcode
X *
X *  \return [INTEGER or INTEGER*2]
X *  Error code. Possible errors include \a spNO_MEMORY.
X *  Error is not cleared in this routine.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix that component is to be entered in.
X *  \param Pos [INTEGER or INTEGER*2]
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Pos be less than zero.
X *  \param Neg [INTEGER or INTEGER*2]
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Neg be less than zero.
X *  \param Eqn [INTEGER or INTEGER*2]
X *     See stamp above. Must be in the range of [0..Size]
X *     unless the options \a EXPANDABLE or \a TRANSLATE are used. Zero is the
X *     ground row.  In no case may \a Eqn be less than zero.
X *  \param Template [4]) [INTEGER (4)]
X *     Collection of pointers to four elements that are later used to directly
X *     address elements.  User must supply the template, this routine will
X *     fill it.
X */
X
int
sfGetOnes( long *Matrix, int *Pos, int *Neg, int *Eqn, long Template[4] )
{
/* Begin `sfGetOnes'. */
X    return
X    (   spGetOnes( (spMatrix)*Matrix, *Pos, *Neg, *Eqn,
X		   (struct spTemplate *)Template )
X    );
}
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
X
/*  ADD ELEMENT(S) DIRECTLY TO MATRIX */
/*!
X *  Adds a real value to a matrix element.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetElement().
X *
X *  \param Element [INTEGER]
X *	Pointer to the element that is to be added to.
X *  \param Real [REAL or DOUBLE PRECISION]
X *	Real portion of the number to be added to the element.
X */
X
void
sfAdd1Real( long *Element, spREAL *Real )
{
/* Begin `sfAdd1Real'. */
X    *((RealNumber *)*Element) += *Real;
}
X
X
#if spCOMPLEX
/*!
X *  Adds an imaginary value to a matrix element.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetElement().
X *
X *  \param Element [INTEGER]
X *	Pointer to the element that is to be added to.
X *  \param Imag [REAL or DOUBLE PRECISION]
X *	Imaginary portion of the number to be added to the element.
X */
X
void
sfAdd1Imag( long *Element, spREAL *Imag )
{
/* Begin `sfAdd1Imag'. */
X    *(((RealNumber *)*Element)+1) += *Imag;
}
X
X
/*!
X *  Adds a complex value to a matrix element.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetElement().
X *
X *  \param Element [INTEGER]
X *	Pointer to the element that is to be added to.
X *  \param Real [REAL or DOUBLE PRECISION]
X *	Real portion of the number to be added to the element.
X *  \param Imag [REAL or DOUBLE PRECISION]
X *	Imaginary portion of the number to be added to the element.
X */
void
sfAdd1Complex( long *Element, spREAL *Real, spREAL *Imag )
{
/* Begin `sfAdd1Complex'. */
X    *((RealNumber *)*Element) += *Real;
X    *(((RealNumber *)*Element)+1) += *Imag;
}
#endif /* spCOMPLEX */
X
X
#if QUAD_ELEMENT
/*!
X *  Adds a real value to a set of four elements in a matrix.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetAdmittance(), spGetQuad(), or spGetOnes().
X *
X *  \param Template [4]) [INTEGER (4)]
X *	Pointer to the element that is to be added to.
X *  \param Real [REAL or DOUBLE PRECISION]
X *	Real portion of the number to be added to the element.
X */
X
void
sfAdd4Real( long Template[4], spREAL *Real )
{
/* Begin `sfAdd4Real'. */
X    *((RealNumber *)Template[0]) += *Real;
X    *((RealNumber *)Template[1]) += *Real;
X    *((RealNumber *)Template[2]) -= *Real;
X    *((RealNumber *)Template[3]) -= *Real;
}
X
X
#if spCOMPLEX
/*!
X *  Adds an imaginary value to a set of four elements in a matrix.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetAdmittance(), spGetQuad(), or spGetOnes().
X *
X *  \param Template [4]) [INTEGER (4)]
X *	Pointer to the element that is to be added to.
X *  \param Imag [REAL or DOUBLE PRECISION]
X *	Imaginary portion of the number to be added to the element.
X */
X
void
sfAdd4Imag( long Template[4], spREAL *Imag )
{
/* Begin `sfAdd4Imag'. */
X    *(((RealNumber *)Template[0])+1) += *Imag;
X    *(((RealNumber *)Template[1])+1) += *Imag;
X    *(((RealNumber *)Template[2])+1) -= *Imag;
X    *(((RealNumber *)Template[3])+1) -= *Imag;
}
X
X
/*!
X *  Adds a complex value to a set of four elements in a matrix.
X *  These elements are referenced by pointer, and so must already have
X *  been created by spGetAdmittance(), spGetQuad(), or spGetOnes().
X *
X *  \param Template [4]) [INTEGER (4)]
X *	Pointer to the element that is to be added to.
X *  \param Real [REAL or DOUBLE PRECISION]
X *	Real portion of the number to be added to the element.
X *  \param Imag [REAL or DOUBLE PRECISION]
X *	Imaginary portion of the number to be added to the element.
X */
X
void
sfAdd4Complex( long Template[4], spREAL *Real, spREAL *Imag )
{
/* Begin `sfAdd4Complex'. */
X    *((RealNumber *)Template[0]) += *Real;
X    *((RealNumber *)Template[1]) += *Real;
X    *((RealNumber *)Template[2]) -= *Real;
X    *((RealNumber *)Template[3]) -= *Real;
X    *(((RealNumber *)Template[0])+1) += *Imag;
X    *(((RealNumber *)Template[1])+1) += *Imag;
X    *(((RealNumber *)Template[2])+1) -= *Imag;
X    *(((RealNumber *)Template[3])+1) -= *Imag;
}
#endif /* spCOMPLEX */
#endif /* QUAD_ELEMENT */
X
X
X
X
X
X
/*  ORDER AND FACTOR MATRIX */
/*!
X *  This routine chooses a pivot order for the matrix and factors it
X *  into LU form.  It handles both the initial factorization and subsequent
X *  factorizations when a reordering is desired.  This is handled in a manner
X *  that is transparent to the user.  The routine uses a variation of
X *  Gauss's method where the pivots are associated with L and the
X *  diagonal terms of U are one.
X *
X *  \return [INTEGER of INTEGER*2]
X *  The error code is returned.  Possible errors include \a spNO_MEMORY,
X *  \a spSINGULAR, and \a spSMALL_PIVOT.
X *  Error is cleared in this function.
X *
X *  \return Matrix [INTEGER]
X *	Pointer to matrix.
X *  \return RHS [REAL (1) or DOUBLE PRECISION (1)]
X *	Representative right-hand side vector that is used to determine
X *	pivoting order when the right hand side vector is sparse.  If
X *	\a RHS is a NULL pointer then the RHS vector is assumed to
X *	be full and it is not used when determining the pivoting
X *	order.
X *  \return RelThreshold [REAL or DOUBLE PRECISION]
X *      This number determines what the pivot relative threshold will
X *      be.  It should be between zero and one.  If it is one then the
X *      pivoting method becomes complete pivoting, which is very slow
X *      and tends to fill up the matrix.  If it is set close to zero
X *      the pivoting method becomes strict Markowitz with no
X *      threshold.  The pivot threshold is used to eliminate pivot
X *      candidates that would cause excessive element growth if they
X *      were used.  Element growth is the cause of roundoff error.
X *      Element growth occurs even in well-conditioned matrices.
X *      Setting the \a RelThreshold large will reduce element growth and
X *      roundoff error, but setting it too large will cause execution
X *      time to be excessive and will result in a large number of
X *      fill-ins.  If this occurs, accuracy can actually be degraded
X *      because of the large number of operations required on the
X *      matrix due to the large number of fill-ins.  A good value seems
X *      to be 0.001.  The default is chosen by giving a value larger
X *      than one or less than or equal to zero.  This value should be
X *      increased and the matrix resolved if growth is found to be
X *      excessive.  Changing the pivot threshold does not improve
X *      performance on matrices where growth is low, as is often the
X *      case with ill-conditioned matrices.  Once a valid threshold is
X *      given, it becomes the new default.  The default value of
X *      RelThreshold was chosen for use with nearly diagonally
X *      dominant matrices such as node- and modified-node admittance
X *      matrices.  For these matrices it is usually best to use
X *      diagonal pivoting.  For matrices without a strong diagonal, it
X *      is usually best to use a larger threshold, such as 0.01 or
X *      0.1.
X *  \return AbsThreshold [REAL or DOUBLE PRECISION]
X *	The absolute magnitude an element must have to be considered
X *	as a pivot candidate, except as a last resort.  This number
X *	should be set significantly smaller than the smallest diagonal
X *	element that is is expected to be placed in the matrix.  If
X *	there is no reasonable prediction for the lower bound on these
X *	elements, then \a AbsThreshold should be set to zero.
X *	\a AbsThreshold is used to reduce the possibility of choosing as a
X *	pivot an element that has suffered heavy cancellation and as a
X *	result mainly consists of roundoff error.  Once a valid
X *	threshold is given, it becomes the new default.
X *  \return DiagPivoting [LOGICAL]
X *	A flag indicating that pivot selection should be confined to the
X *	diagonal if possible.  If DiagPivoting is nonzero and if
X *	\a DIAGONAL_PIVOTING is enabled pivots will be chosen only from
X *	the diagonal unless there are no diagonal elements that satisfy
X *	the threshold criteria.  Otherwise, the entire reduced
X *	submatrix is searched when looking for a pivot.  The diagonal
X *	pivoting in Sparse is efficient and well refined, while the
X *	off-diagonal pivoting is not.  For symmetric and near symmetric
X *	matrices, it is best to use diagonal pivoting because it
X *	results in the best performance when reordering the matrix and
X *	when factoring the matrix without ordering.  If there is a
X *	considerable amount of nonsymmetry in the matrix, then
X *	off-diagonal pivoting may result in a better equation ordering
X *	simply because there are more pivot candidates to choose from.
X *	A better ordering results in faster subsequent factorizations.
X *	However, the initial pivot selection process takes considerably
X *	longer for off-diagonal pivoting.
X */
X
int
sfOrderAndFactor(
X	long *Matrix,
X	spREAL RHS[],
X	spREAL *RelThreshold,
X	spREAL *AbsThreshold,
X	long *DiagPivoting
)
{
/* Begin `sfOrderAndFactor'. */
X    return spOrderAndFactor( (spMatrix)*Matrix, RHS, *RelThreshold,
X			     *AbsThreshold, (BOOLEAN)*DiagPivoting );
}
X
X
X
X
X
X
X
/*  FACTOR MATRIX */
/*!
X *  This routine is the companion routine to spOrderAndFactor().
X *  Unlike sfOrderAndFactor(), sfFactor() cannot change the ordering.
X *  It is also faster than sfOrderAndFactor().  The standard way of
X *  using these two routines is to first use sfOrderAndFactor() for the
X *  initial factorization.  For subsequent factorizations, sfFactor()
X *  is used if there is some assurance that little growth will occur
X *  (say for example, that the matrix is diagonally dominant).  If
X *  sfFactor() is called for the initial factorization of the matrix,
X *  then sfOrderAndFactor() is automatically called with the default
X *  threshold.  This routine uses "row at a time" LU factorization.
X *  Pivots are associated with the lower triangular matrix and the
X *  diagonals of the upper triangular matrix are ones.
X *
X *  \return [INTEGER or INTEGER*2]
X *  The error code is returned.  Possible errors include
X *  \a spNO_MEMORY
X *  \a spSINGULAR
X *  \a spZERO_DIAG
X *  \a spSMALL_PIVOT
X *  Error is cleared in this function.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to matrix.
X */
X
int
sfFactor( long *Matrix )
{
/* Begin `sfFactor'. */
X    return spFactor((spMatrix)*Matrix);
}
X
X
X
X
X
X
/*  PARTITION MATRIX */
/*!
X *  This routine determines the cost to factor each row using both
X *  direct and indirect addressing and decides, on a row-by-row basis,
X *  which addressing mode is fastest.  This information is used in
X *  sfFactor() to speed the factorization.
X *
X *  When factoring a previously ordered matrix using sfFactor(), Sparse
X *  operates on a row-at-a-time basis.  For speed, on each step, the
X *  row being updated is copied into a full vector and the operations
X *  are performed on that vector.  This can be done one of two ways,
X *  either using direct addressing or indirect addressing.  Direct
X *  addressing is fastest when the matrix is relatively dense and
X *  indirect addressing is best when the matrix is quite sparse.  The
X *  user selects the type of partition used with \a Mode.  If \a Mode is set
X *  to \a spDIRECT_PARTITION, then the all rows are placed in the direct
X *  addressing partition.  Similarly, if \a Mode is set to
X *  \a spINDIRECT_PARTITION, then the all rows are placed in the indirect
X *  addressing partition.  By setting \a Mode to \a spAUTO_PARTITION, the
X *  user allows \a Sparse to select the partition for each row
X *  individually.  sfFactor() generally runs faster if Sparse is
X *  allowed to choose its own partitioning, however choosing a
X *  partition is expensive.  The time required to choose a partition is
X *  of the same order of the cost to factor the matrix.  If you plan to
X *  factor a large number of matrices with the same structure, it is
X *  best to let \a Sparse choose the partition.  Otherwise, you should
X *  choose the partition based on the predicted density of the matrix.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to matrix.
X *  \param Mode [INTEGER or INTEGER*2]
X *	Mode must be one of three special codes: \a spDIRECT_PARTITION,
X *	\a spINDIRECT_PARTITION, or \a spAUTO_PARTITION.
X */
X
void
sfPartition( long *Matrix, int *Mode )
{
/* Begin `sfPartition'. */
X    spPartition((spMatrix)*Matrix, *Mode);
}
X
X
X
X
X
X
X
/*  SOLVE MATRIX EQUATION */
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the RHS vector and factored matrix.  This
X *  routine assumes that the pivots are associated with the lower
X *  triangular (L) matrix and that the diagonal of the upper triangular
X *  (U) matrix consists of ones.  This routine arranges the computation
X *  in different way than is traditionally used in order to exploit the
X *  sparsity of the right-hand side.  See the reference in spRevision.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to matrix.
X *  \param RHS [REAL (1) or DOUBLE PRECISION (1)]
X *      \a RHS is the input data array, the right hand side. This data is
X *      undisturbed and may be reused for other solves.
X *  \param Solution [REAL (1) or DOUBLE PRECISION (1)]
X *      \a Solution is the output data array. This routine is constructed such that
X *      \a RHS and \a Solution can be the same array.
X *  \param iRHS [REAL (1) or DOUBLE PRECISION (1)]
X *      \a iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      This argument is only necessary if matrix is complex and if
X *      \a spSEPARATED_COMPLEX_VECTOR is set true.
X *  \param iSolution [REAL (1) or DOUBLE PRECISION (1)]
X *      \a iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that \a iRHS and \a iSolution can be
X *      the same array.  This argument is only necessary if matrix is complex
X *      and if \a spSEPARATED_COMPLEX_VECTOR is set true.
X */
X
/*VARARGS3*/
X
void
sfSolve(
X    long *Matrix,
X    spREAL RHS[],
X    spREAL Solution[]
#   if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X	, spREAL iRHS[]
X	, spREAL iSolution[]
#   endif
)
{
/* Begin `sfSolve'. */
X    spSolve( (spMatrix)*Matrix, RHS, Solution IMAG_VECTORS );
}
X
X
X
X
X
X
#if TRANSPOSE
/*  SOLVE TRANSPOSED MATRIX EQUATION */
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the RHS vector and transposed factored
X *  matrix. This routine is useful when performing sensitivity analysis
X *  on a circuit using the adjoint method.  This routine assumes that
X *  the pivots are associated with the untransposed lower triangular
X *  (L) matrix and that the diagonal of the untransposed upper
X *  triangular (U) matrix consists of ones.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to matrix.
X *  \param RHS [REAL (1) or DOUBLE PRECISION (1)]
X *      \a RHS is the input data array, the right hand side. This data is
X *      undisturbed and may be reused for other solves.
X *  \param Solution [REAL (1) or DOUBLE PRECISION (1)]
X *      \a Solution is the output data array. This routine is constructed such that
X *      \a RHS and \a Solution can be the same array.
X *  \param iRHS [REAL (1) or DOUBLE PRECISION (1)]
X *      \a iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      If \a spSEPARATED_COMPLEX_VECTOR is set false, or if matrix is real, there
X *      is no need to supply this array.
X *  \param iSolution [REAL (1) or DOUBLE PRECISION (1)]
X *      \a iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that \a iRHS and \a iSolution can be
X *      the same array.  If \a spSEPARATED_COMPLEX_VECTOR is set false, or if
X *      matrix is real, there is no need to supply this array.
X */
X
/*VARARGS3*/
X
void
sfSolveTransposed( 
X    long *Matrix,
X    spREAL RHS[],
X    spREAL Solution[]
#   if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X	, spREAL iRHS[]
X	, spREAL iSolution[]
#   endif
)
{
/* Begin `sfSolveTransposed'. */
X    spSolveTransposed( (spMatrix)*Matrix, RHS, Solution IMAG_VECTORS );
}
#endif /* TRANSPOSE */
X
X
X
X
X
#if DOCUMENTATION
/*  PRINT MATRIX */
/*!
X *  Formats and send the matrix to standard output.  Some elementary
X *  statistics are also output.  The matrix is output in a format that is
X *  readable by people.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to matrix.
X *  \param PrintReordered [LOGICAL]
X *	Indicates whether the matrix should be printed out in its original
X *	form, as input by the user, or whether it should be printed in its
X *	reordered form, as used by the matrix routines.  A zero indicates that
X *	the matrix should be printed as inputed, a one indicates that it
X *	should be printed reordered.
X *  \param Data [LOGICAL]
X *	Boolean flag that when false indicates that output should be
X *	compressed such that only the existence of an element should be
X *	indicated rather than giving the actual value. Thus 10 times as many
X *	can be printed on a row.  A zero signifies that the matrix should
X *	be printed compressed.  A one indicates that the matrix should be
X *	printed in all its glory.
X *  \param Header [LOGICAL]
X *	Flag indicating that extra information such as the row and column
X *	numbers should be printed.
X */
X
void
sfPrint( long *Matrix, long *PrintReordered, long *Data, long *Header )
{
/* Begin `sfPrint'. */
X    spPrint( (spMatrix)*Matrix, (int)*PrintReordered,
X				(int)*Data, (int)*Header );
}
#endif /* DOCUMENTATION */
X
X
X
X
X
X
#if DOCUMENTATION
/*  OUTPUT MATRIX TO FILE */
/*!
X *  Writes matrix to file in format suitable to be read back in by the
X *  matrix test program.  Data is sent to a file with a fixed name 
X *  (MATRIX_FILE_NAME) because it is impossible to pass strings from
X *  FORTRAN to C in a manner that is portable.
X *
X *  \return
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to matrix.
X *  \param Reordered [LOGICAL]
X *      Specifies whether matrix should be output in reordered form,
X *	or in original order.
X *  \param Data [LOGICAL]
X *      Indicates that the element values should be output along with
X *      the indices for each element.  This parameter must be true if
X *      matrix is to be read by the sparse test program.
X *  \param Header [LOGICAL]
X *      Indicates that header is desired.  This parameter must be true if
X *      matrix is to be read by the sparse test program.
X */
X
long
sfFileMatrix( long *Matrix, long *Reordered, long *Data, long *Header )
{
/* Begin `sfFileMatrix'. */
X    return spFileMatrix( (spMatrix)*Matrix, MATRIX_FILE_NAME, "",
X			 (int)*Reordered, (int)*Data, (int)*Header );
}
#endif /* DOCUMENTATION */
X
X
X
X
X
X
#if DOCUMENTATION
/*  OUTPUT SOURCE VECTOR TO FILE */
/*!
X *  Writes vector to file in format suitable to be read back in by the
X *  matrix test program.  This routine should be executed after the function
X *  sfFileMatrix.
X *
X *  \return
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to matrix.
X *  \param RHS [REAL (1) or DOUBLE PRECISION (1)]
X *      Right-hand side vector. This is only the real portion if
X *      \a spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iRHS [REAL (1) or DOUBLE PRECISION (1)]
X *      Right-hand side vector, imaginary portion.  Not necessary if matrix
X *      is real or if \a spSEPARATED_COMPLEX_VECTORS is set false.
X */
X
int
sfFileVector( 
X    long *Matrix,
X    spREAL RHS[]
#   if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X	, spREAL iRHS[]
#   endif
)
{
/* Begin `sfFileVector'. */
X    return spFileVector( (spMatrix)*Matrix, MATRIX_FILE_NAME, RHS IMAG_RHS );
}
#endif /* DOCUMENTATION */
X
X
X
X
X
X
X
#if DOCUMENTATION
/*  OUTPUT STATISTICS TO FILE */
/*!
X *  Writes useful information concerning the matrix to a file.  Should be
X *  executed after the matrix is factored.
X *  Data is sent to a file with a fixed name (STATS_FILE_NAME) because
X *  it is impossible to pass strings from FORTRAN to C in a manner that is
X *  portable.
X * 
X *  \return [LOGICAL]
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to matrix.
X */
X
int
sfFileStats( long *Matrix )
{
/* Begin `sfFileStats'. */
X    return spFileStats( (spMatrix)*Matrix, STATS_FILE_NAME, "" );
}
#endif /* DOCUMENTATION */
X
X
X
X
#if MODIFIED_NODAL
/*  PREORDER MODIFIED NODE ADMITTANCE MATRIX TO REMOVE ZEROS FROM DIAGONAL */
/*!
X *  This routine massages modified node admittance matrices to remove
X *  zeros from the diagonal.  It takes advantage of the fact that the
X *  row and column associated with a zero diagonal usually have
X *  structural ones placed symmetricly.  This routine should be used
X *  only on modified node admittance matrices and should be executed
X *  after the matrix has been built but before the factorization
X *  begins.  It should be executed for the initial factorization only
X *  and should be executed before the rows have been linked.  Thus it
X *  should be run before using spScale(), spMultiply(),
X *  spDeleteRowAndCol(), or spNorm().
X *
X *  This routine exploits the fact that the structural one are placed
X *  in the matrix in symmetric twins.  For example, the stamps for
X *  grounded and a floating voltage sources are \code
X *  grounded:              floating:
X *  [  x   x   1 ]         [  x   x   1 ]
X *  [  x   x     ]         [  x   x  -1 ]
X *  [  1         ]         [  1  -1     ]
X *  \endcode
X *  Notice for the grounded source, there is one set of twins, and for
X *  the grounded, there are two sets.  We remove the zero from the diagonal
X *  by swapping the rows associated with a set of twins.  For example:
X *  grounded:              floating 1:            floating 2: \code
X *  [  1         ]         [  1  -1     ]         [  x   x   1 ]
X *  [  x   x     ]         [  x   x  -1 ]         [  1  -1     ]
X *  [  x   x   1 ]         [  x   x   1 ]         [  x   x  -1 ]
X *  \endcode
X *
X *  It is important to deal with any zero diagonals that only have one
X *  set of twins before dealing with those that have more than one because
X *  swapping row destroys the symmetry of any twins in the rows being
X *  swapped, which may limit future moves.  Consider \code
X *  [  x   x   1     ]
X *  [  x   x  -1   1 ]
X *  [  1  -1         ]
X *  [      1         ]
X *  \endcode
X *  There is one set of twins for diagonal 4 and two for diagonal3.
X *  Dealing with diagonal for first requires swapping rows 2 and 4. \code
X *  [  x   x   1     ]
X *  [      1         ]
X *  [  1  -1         ]
X *  [  x   x  -1   1 ]
X *  \endcode
X *  We can now deal with diagonal 3 by swapping rows 1 and 3. \code
X *  [  1  -1         ]
X *  [      1         ]
X *  [  x   x   1     ]
X *  [  x   x  -1   1 ]
X *  \endcode
X *  And we are done, there are no zeros left on the diagonal.  However, if
X *  we originally dealt with diagonal 3 first, we could swap rows 2 and 3 \code
X *  [  x   x   1     ]
X *  [  1  -1         ]
X *  [  x   x  -1   1 ]
X *  [      1         ]
X *  \endcode
X *  Diagonal 4 no longer has a symmetric twin and we cannot continue.
X *
X *  So we always take care of lone twins first.  When none remain, we
X *  choose arbitrarily a set of twins for a diagonal with more than one set
X *  and swap the rows corresponding to that twin.  We then deal with any
X *  lone twins that were created and repeat the procedure until no
X *  zero diagonals with symmetric twins remain.
X *
X *  In this particular implementation, columns are swapped rather than rows.
X *  The algorithm used in this function was developed by Ken Kundert and
X *  Tom Quarles.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to the matrix to be preordered.
X */
X
void
sfMNA_Preorder( long *Matrix )
{
/* Begin `sfMNA_Preorder'. */
X    spMNA_Preorder( (spMatrix)*Matrix );
}
#endif /* MODIFIED_NODAL */
X
X
X
X
X
X
#if SCALING
/*  SCALE MATRIX */
/*!
X *  This function scales the matrix to enhance the possibility of
X *  finding a good pivoting order.  Note that scaling enhances accuracy
X *  of the solution only if it affects the pivoting order, so it makes
X *  no sense to scale the matrix before spFactor().  If scaling is
X *  desired it should be done before spOrderAndFactor().  There
X *  are several things to take into account when choosing the scale
X *  factors.  First, the scale factors are directly multiplied against
X *  the elements in the matrix.  To prevent roundoff, each scale factor
X *  should be equal to an integer power of the number base of the
X *  machine.  Since most machines operate in base two, scale factors
X *  should be a power of two.  Second, the matrix should be scaled such
X *  that the matrix of element uncertainties is equilibrated.  Third,
X *  this function multiplies the scale factors by the elements, so if
X *  one row tends to have uncertainties 1000 times smaller than the
X *  other rows, then its scale factor should be 1024, not 1/1024.
X *  Fourth, to save time, this function does not scale rows or columns
X *  if their scale factors are equal to one.  Thus, the scale factors
X *  should be normalized to the most common scale factor.  Rows and
X *  columns should be normalized separately.  For example, if the size
X *  of the matrix is 100 and 10 rows tend to have uncertainties near
X *  1e-6 and the remaining 90 have uncertainties near 1e-12, then the
X *  scale factor for the 10 should be 1/1,048,576 and the scale factors
X *  for the remaining 90 should be 1.  Fifth, since this routine
X *  directly operates on the matrix, it is necessary to apply the scale
X *  factors to the RHS and Solution vectors.  It may be easier to
X *  simply use spOrderAndFactor() on a scaled matrix to choose the
X *  pivoting order, and then throw away the matrix.  Subsequent
X *  factorizations, performed with spFactor(), will not need to have
X *  the RHS and Solution vectors descaled.  Lastly, this function
X *  should not be executed before the function spMNA_Preorder.
X *
X *  \param Matrix [INTEGER]
X *      Pointer to the matrix to be scaled.
X *  \param SolutionScaleFactors [REAL(1) or DOUBLE PRECISION(1)]
X *      The array of Solution scale factors.  These factors scale the columns.
X *      All scale factors are real valued.
X *  \param RHS_ScaleFactors [REAL(1) or DOUBLE PRECISION(1)]
X *      The array of RHS scale factors.  These factors scale the rows.
X *      All scale factors are real valued.
X */
X
void
sfScale( long *Matrix, spREAL RHS_ScaleFactors[], spREAL SolutionScaleFactors[] )
{
/* Begin `sfScale'. */
X    spScale( (spMatrix)*Matrix, RHS_ScaleFactors, SolutionScaleFactors );
}
#endif /* SCALING */
X
X
X
X
X
X
#if MULTIPLICATION
/*  MATRIX MULTIPLICATION */
/*!
X *  Multiplies matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be used
X *  as a test to see if solutions are correct.  It should not be used
X *  before PreorderFoModifiedNodal().
X *
X *  \param Matrix [INTEGER]
X *      Pointer to the matrix.
X *  \param RHS [REAL(1) or DOUBLE PRECISION(1)]
X *      RHS is the right hand side. This is what is being solved for.
X *  \param Solution [REAL(1) or DOUBLE PRECISION(1)]
X *      Solution is the vector being multiplied by the matrix.
X *  \param iRHS [REAL(1) or DOUBLE PRECISION(1)]
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iSolution [REAL(1) or DOUBLE PRECISION(1)]
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X */
X
void
sfMultiply( 
X    long *Matrix,
X    spREAL RHS[],
X    spREAL Solution[]
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X    , spREAL iRHS[]
X    , spREAL iSolution[]
#endif
)
{
/* Begin `sfMultiply'. */
X    spMultiply( (spMatrix)*Matrix, RHS, Solution IMAG_VECTORS );
}
#endif /* MULTIPLICATION */
X
X
X
X
X
X
#if MULTIPLICATION AND TRANSPOSE
/*  TRANSPOSED MATRIX MULTIPLICATION */
/*!
X *  Multiplies transposed matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be used
X *  as a test to see if solutions are correct.  It should not be used
X *  before PreorderFoModifiedNodal().
X *
X *  \param Matrix [INTEGER]
X *      Pointer to the matrix.
X *  \param RHS [REAL(1) or DOUBLE PRECISION(1)]
X *      RHS is the right hand side. This is what is being solved for.
X *  \param Solution [REAL(1) or DOUBLE PRECISION(1)]
X *      Solution is the vector being multiplied by the matrix.
X *  \param iRHS [REAL(1) or DOUBLE PRECISION(1)]
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iSolution [REAL(1) or DOUBLE PRECISION(1)]
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X */
X
void
sfMultTransposed(
X    long *Matrix,
X    spREAL RHS[],
X    spREAL Solution[]
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X    , spREAL iRHS[]
X    , spREAL iSolution[]
#endif
)
{
/* Begin `sfMultTransposed'. */
X    spMultTransposed( (spMatrix)*Matrix, RHS, Solution IMAG_VECTORS );
}
#endif /* MULTIPLICATION AND TRANSPOSE */
X
X
X
X
X
X
#if DETERMINANT
X
/*  CALCULATE DETERMINANT */
/*!
X *  This routine in capable of calculating the determinant of the
X *  matrix once the LU factorization has been performed.  Hence, only
X *  use this routine after spFactor() and before spClear().
X *  The determinant equals the product of all the diagonal elements of
X *  the lower triangular matrix L, except that this product may need
X *  negating.  Whether the product or the negative product equals the
X *  determinant is determined by the number of row and column
X *  interchanges performed.  Note that the determinants of matrices can
X *  be very large or very small.  On large matrices, the determinant
X *  can be far larger or smaller than can be represented by a floating
X *  point number.  For this reason the determinant is scaled to a
X *  reasonable value and the logarithm of the scale factor is returned.
X *
X *  \param Matrix [INTEGER]
X *      A pointer to the matrix for which the determinant is desired.
X *  \param pExponent [INTEGER or INTEGER*2]
X *      The logarithm base 10 of the scale factor for the determinant.  To
X *	find
X *      the actual determinant, Exponent should be added to the exponent of
X *      DeterminantReal.
X *  \param pDeterminant [REAL or DOUBLE PRECISION]
X *      The real portion of the determinant.   This number is scaled to be
X *      greater than or equal to 1.0 and less than 10.0.
X *  \param piDeterminant [REAL or DOUBLE PRECISION]
X *      The imaginary portion of the determinant.  When the matrix is real
X *      this pointer need not be supplied, nothing will be returned.   This
X *      number is scaled to be greater than or equal to 1.0 and less than 10.0.
X */
X
#if spCOMPLEX
X
void
sfDeterminant(
X    long *Matrix,
X    spREAL *pDeterminant,
X    spREAL *piDeterminant,
X    int  *pExponent
)
{
/* Begin `sfDeterminant'. */
X    spDeterminant( (spMatrix)*Matrix, pExponent, pDeterminant, piDeterminant );
}
X
#else /* spCOMPLEX */
X
void
sfDeterminant( Matrix, pExponent, pDeterminant )
X
long *Matrix;
RealNumber *pDeterminant;
int  *pExponent;
{
/* Begin `sfDeterminant'. */
X    spDeterminant( (spMatrix)*Matrix, pExponent, pDeterminant );
}
#endif /* spCOMPLEX */
#endif /* DETERMINANT */
X
X
X
X
X
X
/*  RETURN MATRIX ERROR STATUS */
/*!
X *  This function is used to determine the error status of the given matrix.
X *
X *  \return [INTEGER or INTEGER*2]
X *     The error status of the given matrix.
X *
X *  \param Matrix [INTEGER]
X *     The matrix for which the error status is desired.
X */
X
int
sfErrorState( long  *Matrix )
{
/* Begin `sfError'. */
X    return spErrorState( (spMatrix)*Matrix );
}
X
X
X
X
X
X
/*  PRINT MATRIX ERROR MESSAGE */
/*!
X *  This function prints a Sparse error message to stderr.
X *
X *  \param Matrix [INTEGER]
X *     The matrix for which the error message is desired.
X */
X
void
sfErrorMessage( long  *Matrix )
{
/* Begin `sfErrorMessage'. */
X    spErrorMessage( (spMatrix)*Matrix, stderr, NULL );
}
X
X
X
X
X
X
/*  WHERE IS MATRIX SINGULAR */
/*!
X *  This function returns the row and column number where the matrix was
X *  detected as singular or where a zero was detected on the diagonal.
X *
X *  \param Matrix [INTEGER]
X *     The matrix for which the error status is desired.
X *  \param pRow  [INTEGER or INTEGER*2]
X *     The row number.
X *  \param pCol  [INTEGER or INTEGER*2]
X *     The column number.
X */
X
void
sfWhereSingular( long *Matrix, int *Row, int *Col )
{
/* Begin `sfWhereSingular'. */
X    spWhereSingular( (spMatrix)*Matrix, Row, Col );
}
X
X
X
X
X
/*   MATRIX SIZE */
/*!
X *   Returns the size of the matrix.  Either the internal or external size of
X *   the matrix is returned.
X *
X *   \param Matrix [INTEGER]
X *       Pointer to matrix.
X *   \param External [LOGICAL]
X *       If External is set true, the external size , i.e., the value of the
X *       largest external row or column number encountered is returned.
X *       Otherwise the true size of the matrix is returned.  These two sizes
X *       may differ if the TRANSLATE option is set true.
X */
X
int
sfGetSize( long  *Matrix, long *External )
{
/* Begin `sfGetSize'. */
X    return spGetSize( (spMatrix)*Matrix, (BOOLEAN)*External );
}
X
X
X
X
X
X
X
X
/*   SET MATRIX REAL */
/*!
X *   Forces matrix to be real.
X *
X *   \param Matrix [INTEGER]
X *       Pointer to matrix.
X */
X
void
sfSetReal( long *Matrix )
{
/* Begin `sfSetReal'. */
X    spSetReal( (spMatrix)*Matrix );
}
X
X
/*   SET MATRIX COMPLEX */
/*!
X *   Forces matrix to be complex.
X *
X *   \param Matrix [INTEGER]
X *       Pointer to matrix.
X */
X
void
sfSetComplex( long *Matrix )
{
/* Begin `sfSetComplex'. */
X    spSetComplex( (spMatrix)*Matrix );
}
X
X
X
X
X
X
X
X
X
/*   FILL-IN COUNT */
/*!
X *   Returns the number of fill-ins in the matrix.
X *
X *   >>> Arguments:
X *   Matrix [INTEGER]
X *       Pointer to matrix.
X */
X
int
sfFillinCount( long *Matrix )
{
/* Begin `sfFillinCount'. */
X    return spFillinCount( (spMatrix)*Matrix );
}
X
X
/*   ELEMENT COUNT */
/*!
X *   Returns the total number of total elements in the matrix.
X *
X *   >>> Arguments:
X *   Matrix [INTEGER]
X *       Pointer to matrix.
X */
X
int
sfElementCount( long *Matrix )
{
/* Begin `sfElementCount'. */
X    return spElementCount( (spMatrix)*Matrix );
}
X
X
X
X
X
X
#if TRANSLATE AND DELETE
X
/*  DELETE A ROW AND COLUMN FROM THE MATRIX */
/*!
X *  Deletes a row and a column from a matrix.
X *
X *  Sparse will abort if an attempt is made to delete a row or column that
X *  doesn't exist.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix in which the row and column are to be deleted.
X *  \param Row [INTEGER or INTEGER*2]
X *     Row to be deleted.
X *  \param Col [INTEGER or INTEGER*2]
X *     Column to be deleted.
X */
X
void
sfDeleteRowAndCol( long *Matrix, int *Row, int *Col )
{
/* Begin `sfDeleteRowAndCol'. */
X    spDeleteRowAndCol( (spMatrix)*Matrix, *Row, *Col );
}
#endif
X
X
X
X
X
#if PSEUDOCONDITION
X
/*  CALCULATE PSEUDOCONDITION */
/*!
X *  Computes the magnitude of the ratio of the largest to the smallest
X *  pivots.  This quantity is an indicator of ill-conditioning in the
X *  matrix.  If this ratio is large, and if the matrix is scaled such
X *  that uncertainties in the RHS and the matrix entries are
X *  equilibrated, then the matrix is ill-conditioned.  However, a small
X *  ratio does not necessarily imply that the matrix is
X *  well-conditioned.  This routine must only be used after a matrix
X *  has been factored by sfOrderAndFactor() or sfFactor() and before it
X *  is cleared by sfClear() or spInitialize().  The pseudocondition is faster
X *  to compute than the condition number calculated by sfCondition(), but
X *  is not as informative.
X *
X *  \return [REAL or DOUBLE PRECISION]
X *  The magnitude of the ratio of the largest to smallest pivot used during
X *  previous factorization.  If the matrix was singular, zero is returned.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix.
X */
X
spREAL
sfPseudoCondition( long *Matrix )
{
/* Begin `sfPseudoCondition'. */
X    return spPseudoCondition( (spMatrix)Matrix );
}
#endif
X
X
X
X
X
X
X
#if CONDITION
X
/*  ESTIMATE CONDITION NUMBER */
/*!
X *  Computes an estimate of the condition number using a variation on
X *  the LINPACK condition number estimation algorithm.  This quantity is
X *  an indicator of ill-conditioning in the matrix.  To avoid problems
X *  with overflow, the reciprocal of the condition number is returned.
X *  If this number is small, and if the matrix is scaled such that
X *  uncertainties in the RHS and the matrix entries are equilibrated,
X *  then the matrix is ill-conditioned.  If the this number is near
X *  one, the matrix is well conditioned.  This routine must only be
X *  used after a matrix has been factored by sfOrderAndFactor() or
X *  sfFactor() and before it is cleared by sfClear() or spInitialize().
X *
X *  Unlike the LINPACK condition number estimator, this routines
X *  returns the L infinity condition number.  This is an artifact of
X *  Sparse placing ones on the diagonal of the upper triangular matrix
X *  rather than the lower.  This difference should be of no importance.
X *
X *  \b References:
X *  A.K. Cline, C.B. Moler, G.W. Stewart, J.H. Wilkinson.  An estimate
X *  for the condition number of a matrix.  SIAM Journal on Numerical
X *  Analysis.  Vol. 16, No. 2, pages 368-375, April 1979.
X *  
X *  J.J. Dongarra, C.B. Moler, J.R. Bunch, G.W. Stewart.  LINPACK
X *  User's Guide.  SIAM, 1979.
X *  
X *  Roger G. Grimes, John G. Lewis.  Condition number estimation for
X *  sparse matrices.  SIAM Journal on Scientific and Statistical
X *  Computing.  Vol. 2, No. 4, pages 384-388, December 1981.
X *  
X *  Dianne Prost O'Leary.  Estimating matrix condition numbers.  SIAM
X *  Journal on Scientific and Statistical Computing.  Vol. 1, No. 2,
X *  pages 205-209, June 1980.
X *
X *  \return [REAL or DOUBLE PRECISION]
X *  The reciprocal of the condition number.  If the matrix was singular,
X *  zero is returned.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to the matrix.
X *  \param NormOfMatrix [REAL or DOUBLE PRECISION]
X *	The L-infinity norm of the unfactored matrix as computed by
X *	spNorm().
X *  \param pError [INTEGER or INTEGER*2]
X *	Used to return error code.  Possible errors include \a spSINGULAR
X *      and \a spNO_MEMORY.
X */
X
spREAL
sfCondition( long *Matrix, spREAL *NormOfMatrix, int *pError )
{
/* Begin `sfCondition'. */
X    return spCondition( (spMatrix)*Matrix, *NormOfMatrix, pError );
}
X
X
X
X
X
/*  L-INFINITY MATRIX NORM */
/*!
X *  Computes the L-infinity norm of an unfactored matrix.  It is a fatal
X *  error to pass this routine a factored matrix.
X *
X *  \return [REAL or DOUBLE PRECISION]
X *  The largest absolute row sum of matrix.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix.
X */
X
spREAL
sfNorm( long *Matrix )
{
/* Begin `sfNorm'. */
X    return spNorm( (spMatrix)*Matrix );
}
#endif /* CONDITION */
X
X
X
X
X
#if STABILITY
X
/*  LARGEST ELEMENT IN MATRIX */
/*!
X *  spLargestElement() finds the magnitude on the largest element in the
X *  matrix.  If the matrix has not yet been factored, the largest
X *  element is found by direct search.  If the matrix is factored, a
X *  bound on the largest element in any of the reduced submatrices is
X *  computed.
X *
X *  \return [REAL or DOUBLE PRECISION]
X *  If matrix is not factored, returns the magnitude of the largest element in
X *  the matrix.  If the matrix is factored, a bound on the magnitude of the
X *  largest element in any of the reduced submatrices is returned.
X *
X *  \param Matrix [INTEGER]
X *     Pointer to the matrix.
X *
X *  \see spLargestElement()
X */
X
spREAL
sfLargestElement( long *Matrix )
{
/* Begin `sfLargestElement'. */
X    return spLargestElement( (spMatrix)Matrix );
}
X
X
X
X
/*  MATRIX ROUNDOFF ERROR */
/*!
X *  This routine, along with spLargestElement(), are used to gauge the
X *  stability of a factorization. See description of spLargestElement()
X *  for more information.
X *
X *  \return [REAL or DOUBLE PRECISION]
X *  Returns a bound on the magnitude of the largest element in E = A - LU.
X *
X *  \param Matrix [INTEGER]
X *	Pointer to the matrix.
X *  \param Rho [REAL or DOUBLE PRECISION]
X *	The bound on the magnitude of the largest element in any of the
X *	reduced submatrices.  This is the number computed by the function
X *	spLargestElement() when given a factored matrix.  If this number is
X *	negative, the bound will be computed automatically.
X *  \see spRoundoff()
X */
X
spREAL
sfRoundoff( long *Matrix, spREAL *Rho )
{
/* Begin `sfRoundoff'. */
X    return spRoundoff( (spMatrix)*Matrix, *Rho );
}
#endif
X
#endif /* FORTRAN */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spFortran.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spFortran.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spFortran.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spFortran.c: MD5 check failed'
       ) << \SHAR_EOF
72ce88e9e8badca54a9e44180196194e  sparse/spFortran.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spFortran.c'` -ne 56802 && \
  ${echo} 'restoration warning:  size of sparse/spFortran.c is not 56802'
  fi
fi
# ============= sparse/spLicense ==============
if test -f 'sparse/spLicense' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spLicense (file already exists)'
else
${echo} 'x - extracting sparse/spLicense (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spLicense' &&
Copyright (c) 2003, Kenneth S. Kundert
All rights reserved.
X
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
X
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.  Redistributions
in binary form must reproduce the above copyright notice, this list
of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.  Neither the name of the
copyright holder nor the names of the authors may be used to endorse
or promote products derived from this software without specific prior
written permission.
X
This software is provided by the copyright holders and contributors
"as is" and any express or implied warranties, including, but not
limited to, the implied warranties of merchantability and fitness for
a particular purpose are disclaimed. In no event shall the copyright
owner or contributors be liable for any direct, indirect, incidental,
special, exemplary, or consequential damages (including, but not limited
to, procurement of substitute goods or services; loss of use, data, or
profits; or business interruption) however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use of this
software, even if advised of the possibility of such damage.
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spLicense'; eval "$shar_touch") &&
  chmod 0600 'sparse/spLicense'
if test $? -ne 0
then ${echo} 'restore of sparse/spLicense failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spLicense: MD5 check failed'
       ) << \SHAR_EOF
ba0c8e767cb7df78b487d88867dec55c  sparse/spLicense
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spLicense'` -ne 1474 && \
  ${echo} 'restoration warning:  size of sparse/spLicense is not 1474'
  fi
fi
# ============= sparse/spMatrix.h ==============
if test -f 'sparse/spMatrix.h' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spMatrix.h (file already exists)'
else
${echo} 'x - extracting sparse/spMatrix.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spMatrix.h' &&
/*  EXPORTS for sparse matrix routines. */
/*!
X *  \file
X *
X *  This file contains definitions that are useful to the calling
X *  program.  In particular, this file contains error keyword
X *  definitions, some macro functions that are used to quickly enter
X *  data into the matrix and the type definition of a data structure
X *  that acts as a template for entering admittances into the matrix.
X *  Also included is the type definitions for the various functions
X *  available to the user.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X *
X *  $Date: 2003/06/29 04:19:52 $
X *  $Revision: 1.2 $
X */
X
X
X
X
#ifndef  spOKAY
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *      Macros that customize the sparse matrix routines.
X */
X
#include "spConfig.h"
X
X
X
X
X
X
/*
X *  ERROR KEYWORDS
X *
X *  The actual numbers used in the error codes are not sacred, they can be
X *  changed under the condition that the codes for the nonfatal errors are
X *  less than the code for spFATAL and similarly the codes for the fatal
X *  errors are greater than that for spFATAL.
X */
X
/* Begin error macros. */
#define  spOKAY		0  /*!<
X			    * Error code that indicates that no error has
X			    * occurred.
X			    */
#define  spSMALL_PIVOT	1  /*!<
X			    * Non-fatal error code that indicates that, when
X			    * reordering the matrix, no element was found that
X			    * satisfies the absolute threshold criteria. The
X			    * largest element in the matrix was chosen as pivot.
X			    */
#define  spZERO_DIAG	2  /*!<
X			    * Fatal error code that indicates that, a zero was
X			    * encountered on the diagonal the matrix. This does
X			    * not necessarily imply that the matrix is singular.
X			    * When this error occurs, the matrix should be
X			    * reconstructed and factored using
X			    * spOrderAndFactor().
X			    */
#define  spSINGULAR	3  /*!<
X			    * Fatal error code that indicates that, matrix is
X			    * singular, so no unique solution exists.
X			    */
#define  spMANGLED	4  /*!<
X			    * Fatal error code that indicates that, matrix has
X			    * been mangled, results of requested operation are
X			    * garbage.
X			    */
#define  spNO_MEMORY	5  /*!<
X			    * Fatal error code that indicates that not enough
X			    * memory is available.
X			    */
#define  spPANIC	6  /*!<
X			    * Fatal error code that indicates that the routines
X			    * are not prepared to handle the matrix that has
X			    * been requested.  This may occur when the matrix
X			    * is specified to be real and the routines are not
X			    * compiled for real matrices, or when the matrix is
X			    * specified to be complex and the routines are not
X			    * compiled to handle complex matrices.
X			    */
#define  spFATAL	2  /*!<
X			    * Error code that is not an error flag, but rather
X			    * the dividing line between fatal errors and
X			    * warnings.
X			    */
X
X
X
X
X
X
/*
X *  KEYWORD DEFINITIONS
X */
X
#define  spREAL double  /*!<
X			 * Defines the precision of the arithmetic used by
X			 * \a Sparse will use.  Double precision is suggested
X			 * as being most appropriate for circuit simulation
X			 * and for C.  However, it is possible to change spREAL
X			 * to a float for single precision arithmetic.  Note
X			 * that in C, single precision arithmetic is often
X			 * slower than double precision.  Sparse
X			 * internally refers to spREALs as RealNumbers.
X			 */
X
X
X
/*
X *  PARTITION TYPES
X *
X *  When factoring a previously ordered matrix using spFactor(), Sparse
X *  operates on a row-at-a-time basis.  For speed, on each step, the row
X *  being updated is copied into a full vector and the operations are
X *  performed on that vector.  This can be done one of two ways, either
X *  using direct addressing or indirect addressing.  Direct addressing
X *  is fastest when the matrix is relatively dense and indirect addressing
X *  is quite sparse.  The user can select which partitioning mode is used.
X *  The following keywords are passed to spPartition() and indicate that
X *  Sparse should use only direct addressing, only indirect addressing, or
X *  that it should choose the best mode on a row-by-row basis.  The time
X *  required to choose a partition is of the same order of the cost to factor
X *  the matrix.
X *
X *  If you plan to factor a large number of matrices with the same structure,
X *  it is best to let Sparse choose the partition.  Otherwise, you should
X *  choose the partition based on the predicted density of the matrix.
X */
X
/* Begin partition keywords. */
X
#define spDEFAULT_PARTITION	0 /*!<
X			           * Partition code for spPartition().
X				   * Indicates that the default partitioning
X				   * mode should be used.
X				   * \see spPartition()
X				   */
#define spDIRECT_PARTITION	1 /*!<
X			           * Partition code for spPartition().
X				   * Indicates that all rows should be placed
X				   * in the direct addressing partition.
X				   * \see spPartition()
X				   */
#define spINDIRECT_PARTITION	2 /*!<
X			           * Partition code for spPartition().
X				   * Indicates that all rows should be placed
X				   * in the indirect addressing partition.
X				   * \see spPartition()
X				   */
#define spAUTO_PARTITION	3 /*!<
X			           * Partition code for spPartition().
X				   * Indicates that \a Sparse should chose
X				   * the best partition for each row based
X				   * on some simple rules. This is generally
X				   * preferred.
X				   * \see spPartition()
X				   */
X
X
X
X
X
/*
X *  MACRO FUNCTION DEFINITIONS
X */
X
/* Begin Macros. */
/*!
X * Macro function that adds data to a real element in the matrix by a pointer.
X */
#define  spADD_REAL_ELEMENT(element,real)       *(element) += real
X
/*!
X * Macro function that adds data to a imaginary element in the matrix by
X * a pointer.
X */
#define  spADD_IMAG_ELEMENT(element,imag)       *(element+1) += imag
X
/*!
X * Macro function that adds data to a complex element in the matrix by
X * a pointer.
X */
#define  spADD_COMPLEX_ELEMENT(element,real,imag)       \
{   *(element) += real;                                 \
X    *(element+1) += imag;                               \
}
X
/*!
X * Macro function that adds data to each of the four real matrix elements
X * specified by the given template.
X */
#define  spADD_REAL_QUAD(template,real)         \
{   *((template).Element1) += real;             \
X    *((template).Element2) += real;             \
X    *((template).Element3Negated) -= real;      \
X    *((template).Element4Negated) -= real;      \
}
X
/*!
X * Macro function that adds data to each of the four imaginary matrix
X * elements specified by the given template.
X */
#define  spADD_IMAG_QUAD(template,imag)         \
{   *((template).Element1+1) += imag;           \
X    *((template).Element2+1) += imag;           \
X    *((template).Element3Negated+1) -= imag;    \
X    *((template).Element4Negated+1) -= imag;    \
}
X
/*!
X * Macro function that adds data to each of the four complex matrix
X * elements specified by the given template.
X */
#define  spADD_COMPLEX_QUAD(template,real,imag) \
{   *((template).Element1) += real;             \
X    *((template).Element2) += real;             \
X    *((template).Element3Negated) -= real;      \
X    *((template).Element4Negated) -= real;      \
X    *((template).Element1+1) += imag;           \
X    *((template).Element2+1) += imag;           \
X    *((template).Element3Negated+1) -= imag;    \
X    *((template).Element4Negated+1) -= imag;    \
}
X
X
X
X
X
X
X
/*
X *   TYPE DEFINITION FOR EXTERNAL MATRIX ELEMENT REFERENCES
X *
X *   External type definitions for Sparse data objects.
X */
X
/*! Declares the type of the a pointer to a matrix. */
typedef spGenericPtr spMatrix;
X
/*! Declares the type of the a pointer to a matrix element. */
typedef spREAL spElement;
X
/*! Declares the type of the Sparse error codes. */
typedef int spError;
X
X
X
X
X
/* TYPE DEFINITION FOR COMPONENT TEMPLATE */
/*!
X *   This data structure is used to hold pointers to four related elements in
X *   matrix.  It is used in conjunction with the routines spGetAdmittance(),
X *   spGetQuad(), and spGetOnes().  These routines stuff the structure which
X *   is later used by the \a spADD_QUAD macro functions above.  It is also
X *   possible for the user to collect four pointers returned by spGetElement()
X *   and stuff them into the template.  The \a spADD_QUAD routines stuff data
X *   into the matrix in locations specified by \a Element1 and \a Element2
X *   without changing the data.  The data is negated before being placed in
X *   \a Element3 and \a Element4.
X */
X
/* Begin `spTemplate'. */
struct  spTemplate
{   spElement	*Element1;
X    spElement	*Element2;
X    spElement	*Element3Negated;
X    spElement	*Element4Negated;
};
X
X
X
X
X
/*
X *   FUNCTION TYPE DEFINITIONS
X *
X *   The type of every user accessible function is declared here.
X */
X
/* Begin function declarations. */
X
spcEXTERN  void       spClear( spMatrix );
spcEXTERN  spREAL     spCondition( spMatrix, spREAL, int* );
spcEXTERN  spMatrix   spCreate( int, int, spError* );
spcEXTERN  void       spDeleteRowAndCol( spMatrix, int, int );
spcEXTERN  void       spDestroy( spMatrix );
spcEXTERN  int        spElementCount( spMatrix );
spcEXTERN  spError    spErrorState( spMatrix );
#ifdef EOF
X    spcEXTERN void    spErrorMessage( spMatrix, FILE*, char* );
#else
#   define spErrorMessage(a,b,c) spcFUNC_NEEDS_FILE(_spErrorMessage,stdio)
#endif
X
X
spcEXTERN  spError    spFactor( spMatrix );
spcEXTERN  int        spFileMatrix( spMatrix, char*, char*, int, int, int );
spcEXTERN  int        spFileStats( spMatrix, char*, char* );
spcEXTERN  int        spFillinCount( spMatrix );
spcEXTERN  spElement *spFindElement( spMatrix, int, int );
spcEXTERN  spError    spGetAdmittance( spMatrix, int, int,
X				struct spTemplate* );
spcEXTERN  spElement *spGetElement( spMatrix, int, int );
spcEXTERN  spGenericPtr spGetInitInfo( spElement* );
spcEXTERN  spError    spGetOnes( spMatrix, int, int, int,
X				struct spTemplate* );
spcEXTERN  spError    spGetQuad( spMatrix, int, int, int, int,
X				struct spTemplate* );
spcEXTERN  int        spGetSize( spMatrix, int );
spcEXTERN  int        spInitialize( spMatrix, int (*pInit)(spElement *, spGenericPtr, int, int) );
spcEXTERN  void       spInstallInitInfo( spElement*, spGenericPtr );
spcEXTERN  spREAL     spLargestElement( spMatrix );
spcEXTERN  void       spMNA_Preorder( spMatrix );
spcEXTERN  spREAL     spNorm( spMatrix );
spcEXTERN  spError    spOrderAndFactor( spMatrix, spREAL[], spREAL,
X				spREAL, int );
spcEXTERN  void       spPartition( spMatrix, int );
spcEXTERN  void       spPrint( spMatrix, int, int, int );
spcEXTERN  spREAL     spPseudoCondition( spMatrix );
spcEXTERN  spREAL     spRoundoff( spMatrix, spREAL );
spcEXTERN  void       spScale( spMatrix, spREAL[], spREAL[] );
spcEXTERN  void       spSetComplex( spMatrix );
spcEXTERN  void       spSetReal( spMatrix );
spcEXTERN  void       spStripFills( spMatrix );
spcEXTERN  void       spWhereSingular( spMatrix, int*, int* );
X
/* Functions with argument lists that are dependent on options. */
X
#if spCOMPLEX
spcEXTERN  void       spDeterminant( spMatrix, int*, spREAL*, spREAL* );
#else /* NOT spCOMPLEX */
spcEXTERN  void       spDeterminant( spMatrix, int*, spREAL* );
#endif /* NOT spCOMPLEX */
#if spCOMPLEX && spSEPARATED_COMPLEX_VECTORS
spcEXTERN  int        spFileVector( spMatrix, char* ,
X				spREAL[], spREAL[]);
spcEXTERN  void       spMultiply( spMatrix, spREAL[], spREAL[],
X				spREAL[], spREAL[] );
spcEXTERN  void       spMultTransposed( spMatrix, spREAL[], spREAL[],
X				spREAL[], spREAL[] );
spcEXTERN  void       spSolve( spMatrix, spREAL[], spREAL[], spREAL[],
X				spREAL[] );
spcEXTERN  void       spSolveTransposed( spMatrix, spREAL[], spREAL[],
X				spREAL[], spREAL[] );
#else /* NOT  (spCOMPLEX && spSEPARATED_COMPLEX_VECTORS) */
spcEXTERN  int        spFileVector( spMatrix, char* , spREAL[] );
spcEXTERN  void       spMultiply( spMatrix, spREAL[], spREAL[] );
spcEXTERN  void       spMultTransposed( spMatrix,
X				spREAL[], spREAL[] );
spcEXTERN  void       spSolve( spMatrix, spREAL[], spREAL[] );
spcEXTERN  void       spSolveTransposed( spMatrix,
X				spREAL[], spREAL[] );
#endif /* NOT  (spCOMPLEX && spSEPARATED_COMPLEX_VECTORS) */
#endif  /* spOKAY */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spMatrix.h'; eval "$shar_touch") &&
  chmod 0600 'sparse/spMatrix.h'
if test $? -ne 0
then ${echo} 'restore of sparse/spMatrix.h failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spMatrix.h: MD5 check failed'
       ) << \SHAR_EOF
b390c6629b2821f252b0b93900e613d6  sparse/spMatrix.h
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spMatrix.h'` -ne 12377 && \
  ${echo} 'restoration warning:  size of sparse/spMatrix.h is not 12377'
  fi
fi
# ============= sparse/spOutput.c ==============
if test -f 'sparse/spOutput.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spOutput.c (file already exists)'
else
${echo} 'x - extracting sparse/spOutput.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spOutput.c' &&
/*
X *  MATRIX OUTPUT MODULE
X *
X *  Author:                     Advisor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X */
/*! \file
X * 
X *  This file contains the output-to-file and output-to-screen routines for
X *  the matrix package.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spPrint
X *  spFileMatrix
X *  spFileVector
X *  spFileStats
X *
X *  >>> Other functions contained in this file:
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003
X *  by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "$Header: /cvsroot/sparse/src/spOutput.c,v 1.3 2003/06/29 04:19:52 kundert Exp $";
#endif
X
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *     Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *     Macros and declarations to be imported by the user.
X *  spDefs.h
X *     Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
X
#if DOCUMENTATION
X
/*!
X *  Formats and send the matrix to standard output.  Some elementary
X *  statistics are also output.  The matrix is output in a format that is
X *  readable by people.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param PrintReordered
X *      Indicates whether the matrix should be printed out in its original
X *      form, as input by the user, or whether it should be printed in its
X *      reordered form, as used by the matrix routines.  A zero indicates that
X *      the matrix should be printed as inputed, a one indicates that it
X *      should be printed reordered.
X *  \param Data
X *      Boolean flag that when false indicates that output should be
X *      compressed such that only the existence of an element should be
X *      indicated rather than giving the actual value.  Thus 11 times as
X *      many can be printed on a row.  A zero signifies that the matrix
X *      should be printed compressed. A one indicates that the matrix
X *      should be printed in all its glory.
X *  \param Header
X *      Flag indicating that extra information should be given, such as row
X *      and column numbers.
X */
/*  >>> Local variables:
X *  Col  (int)
X *      Column being printed.
X *  ElementCount  (int)
X *      Variable used to count the number of nonzero elements in the matrix.
X *  LargestElement  (RealNumber)
X *      The magnitude of the largest element in the matrix.
X *  LargestDiag  (RealNumber)
X *      The magnitude of the largest diagonal in the matrix.
X *  Magnitude  (RealNumber)
X *      The absolute value of the matrix element being printed.
X *  PrintOrdToIntColMap  (int [])
X *      A translation array that maps the order that columns will be
X *      printed in (if not PrintReordered) to the internal column numbers.
X *  PrintOrdToIntRowMap  (int [])
X *      A translation array that maps the order that rows will be
X *      printed in (if not PrintReordered) to the internal row numbers.
X *  pElement  (ElementPtr)
X *      Pointer to the element in the matrix that is to be printed.
X *  pImagElements  (ElementPtr [ ])
X *      Array of pointers to elements in the matrix.  These pointers point
X *      to the elements whose real values have just been printed.  They are
X *      used to quickly access those same elements so their imaginary values
X *      can be printed.
X *  Row  (int)
X *      Row being printed.
X *  Size  (int)
X *      The size of the matrix.
X *  SmallestDiag  (RealNumber)
X *      The magnitude of the smallest diagonal in the matrix.
X *  SmallestElement  (RealNumber)
X *      The magnitude of the smallest element in the matrix excluding zero
X *      elements.
X *  StartCol  (int)
X *      The column number of the first column to be printed in the group of
X *      columns currently being printed.
X *  StopCol  (int)
X *      The column number of the last column to be printed in the group of
X *      columns currently being printed.
X *  Top  (int)
X *      The largest expected external row or column number.
X */
X
void
spPrint(
X    spMatrix eMatrix,
X    int PrintReordered,
X    int Data,
X    int Header
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  int  J = 0;
int I, Row, Col, Size, Top, StartCol = 1, StopCol, Columns, ElementCount = 0;
double  Magnitude, SmallestDiag, SmallestElement;
double  LargestElement = 0.0, LargestDiag = 0.0;
ElementPtr  pElement, pImagElements[PRINTER_WIDTH/10+1];
int  *PrintOrdToIntRowMap, *PrintOrdToIntColMap;
X
/* Begin `spPrint'. */
X    ASSERT_IS_SPARSE( Matrix );
X    Size = Matrix->Size;
X
/* Create a packed external to internal row and column translation array. */
# if TRANSLATE
X    Top = Matrix->AllocatedExtSize;
#else
X    Top = Matrix->AllocatedSize;
#endif
X    CALLOC( PrintOrdToIntRowMap, int, Top + 1 );
X    CALLOC( PrintOrdToIntColMap, int, Top + 1 );
X    if ( PrintOrdToIntRowMap == NULL OR PrintOrdToIntColMap == NULL)
X    {   Matrix->Error = spNO_MEMORY;
X        return;
X    }
X    for (I = 1; I <= Size; I++)
X    {   PrintOrdToIntRowMap[ Matrix->IntToExtRowMap[I] ] = I;
X        PrintOrdToIntColMap[ Matrix->IntToExtColMap[I] ] = I;
X    }
X
/* Pack the arrays. */
X    for (J = 1, I = 1; I <= Top; I++)
X    {   if (PrintOrdToIntRowMap[I] != 0)
X            PrintOrdToIntRowMap[ J++ ] = PrintOrdToIntRowMap[ I ];
X    }
X    for (J = 1, I = 1; I <= Top; I++)
X    {   if (PrintOrdToIntColMap[I] != 0)
X            PrintOrdToIntColMap[ J++ ] = PrintOrdToIntColMap[ I ];
X    }
X
/* Print header. */
X    if (Header)
X    {   printf("MATRIX SUMMARY\n\n");
X        printf("Size of matrix = %1d x %1d.\n", Size, Size);
X        if ( Matrix->Reordered AND PrintReordered )
X            printf("Matrix has been reordered.\n");
X        putchar('\n');
X
X        if ( Matrix->Factored )
X            printf("Matrix after factorization:\n");
X        else
X            printf("Matrix before factorization:\n");
X
X        SmallestElement = LARGEST_REAL;
X        SmallestDiag = SmallestElement;
X    }
X    if (Size == 0) return;
X
/* Determine how many columns to use. */
X    Columns = PRINTER_WIDTH;
X    if (Header) Columns -= 5;
X    if (Data) Columns = (Columns+1) / 10;
X
/*
X * Print matrix by printing groups of complete columns until all the columns
X * are printed.
X */
X    J = 0;
X    while ( J <= Size )
X
/* Calculate index of last column to printed in this group. */
X    {   StopCol = StartCol + Columns - 1;
X        if (StopCol > Size)
X            StopCol = Size;
X
/* Label the columns. */
X        if (Header)
X        {   if (Data)
X            {   printf("    ");
X                for (I = StartCol; I <= StopCol; I++)
X                {   if (PrintReordered)
X                        Col = I;
X                    else
X                        Col = PrintOrdToIntColMap[I];
X                    printf(" %9d", Matrix->IntToExtColMap[ Col ]);
X                }
X                printf("\n\n");
X            }
X            else
X            {   if (PrintReordered)
X                    printf("Columns %1d to %1d.\n",StartCol,StopCol);
X                else
X                {   printf("Columns %1d to %1d.\n",
X                        Matrix->IntToExtColMap[ PrintOrdToIntColMap[StartCol] ],
X                        Matrix->IntToExtColMap[ PrintOrdToIntColMap[StopCol] ]);
X                }
X            }
X        }
X
/* Print every row ...  */
X        for (I = 1; I <= Size; I++)
X        {   if (PrintReordered)
X                Row = I;
X            else
X                Row = PrintOrdToIntRowMap[I];
X
X            if (Header)
X            {   if (PrintReordered AND NOT Data)
X                    printf("%4d", I);
X                else
X                    printf("%4d", Matrix->IntToExtRowMap[ Row ]);
X                if (NOT Data) putchar(' ');
X            }
X
/* ... in each column of the group. */
X            for (J = StartCol; J <= StopCol; J++)
X            {   if (PrintReordered)
X                    Col = J;
X                else
X                    Col = PrintOrdToIntColMap[J];
X
X                pElement = Matrix->FirstInCol[Col];
X                while(pElement != NULL AND pElement->Row != Row)
X                    pElement = pElement->NextInCol;
X
X                if (Data)
X                    pImagElements[J - StartCol] = pElement;
X
X                if (pElement != NULL)
X
/* Case where element exists */
X                {   if (Data)
X                        printf(" %9.3g", (double)pElement->Real);
X                    else
X                        putchar('x');
X
/* Update status variables */
X                    if ( (Magnitude = ELEMENT_MAG(pElement)) > LargestElement )
X                        LargestElement = Magnitude;
X                    if ((Magnitude < SmallestElement) AND (Magnitude != 0.0))
X                        SmallestElement = Magnitude;
X                    ElementCount++;
X                }
X
/* Case where element is structurally zero */
X                else
X                {   if (Data)
X                        printf("       ...");
X                    else
X                        putchar('.');
X                }
X            }
X            putchar('\n');
X
#if spCOMPLEX
X            if (Matrix->Complex AND Data)
X            {   if (Header)
X		    printf("    ");
X                for (J = StartCol; J <= StopCol; J++)
X                {   if (pImagElements[J - StartCol] != NULL)
X                    {   printf(" %8.2gj",
X                               (double)pImagElements[J-StartCol]->Imag);
X                    }
X                    else printf("          ");
X                }
X                putchar('\n');
X            }
#endif /* spCOMPLEX */
X        }
X
/* Calculate index of first column in next group. */
X        StartCol = StopCol;
X        StartCol++;
X        putchar('\n');
X    }
X    if (Header)
X    {   printf("\nLargest element in matrix = %-1.4g.\n", LargestElement);
X        printf("Smallest element in matrix = %-1.4g.\n", SmallestElement);
X
/* Search for largest and smallest diagonal values */
X        for (I = 1; I <= Size; I++)
X        {   if (Matrix->Diag[I] != NULL)
X            {   Magnitude = ELEMENT_MAG( Matrix->Diag[I] );
X                if ( Magnitude > LargestDiag ) LargestDiag = Magnitude;
X                if ( Magnitude < SmallestDiag ) SmallestDiag = Magnitude;
X            }
X        }
X
X    /* Print the largest and smallest diagonal values */
X        if ( Matrix->Factored )
X        {   printf("\nLargest diagonal element = %-1.4g.\n", LargestDiag);
X            printf("Smallest diagonal element = %-1.4g.\n", SmallestDiag);
X        }
X        else
X        {   printf("\nLargest pivot element = %-1.4g.\n", LargestDiag);
X            printf("Smallest pivot element = %-1.4g.\n", SmallestDiag);
X        }
X
X    /* Calculate and print sparsity and number of fill-ins created. */
X	printf("\nDensity = %2.2f%%.\n", ((double)ElementCount * 100.0)
X					 / (((double)Size * (double)Size)));
X        if (NOT Matrix->NeedsOrdering)
X            printf("Number of fill-ins = %1d.\n", Matrix->Fillins);
X    }
X    putchar('\n');
X    (void)fflush(stdout);
X
X    FREE(PrintOrdToIntColMap);
X    FREE(PrintOrdToIntRowMap);
X    return;
}
X
X
X
X
X
X
X
X
X
X
X
/*!
X *  Writes matrix to file in format suitable to be read back in by the
X *  matrix test program.
X *
X *  \return
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query \a errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param File
X *      Name of file into which matrix is to be written.
X *  \param Label
X *      String that is transferred to file and is used as a label.
X *  \param Reordered
X *      Specifies whether matrix should be output in reordered form,
X *      or in original order.
X *  \param Data
X *      Indicates that the element values should be output along with
X *      the indices for each element.  This parameter must be true if
X *      matrix is to be read by the sparse test program.
X *  \param Header
X *      Indicates that header is desired.  This parameter must be true if
X *      matrix is to be read by the sparse test program.
X */
/*  >>> Local variables:
X *  Col  (int)
X *      The original column number of the element being output.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  pMatrixFile  (FILE *)
X *      File pointer to the matrix file.
X *  Row  (int)
X *      The original row number of the element being output.
X *  Size  (int)
X *      The size of the matrix.
X */
X
int
spFileMatrix(
X    spMatrix eMatrix,
X    char *File,
X    char *Label,
X    int Reordered,
X    int Data,
X    int Header
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  int  I, Size;
register  ElementPtr  pElement;
int  Row, Col, Err;
FILE  *pMatrixFile;
X
/* Begin `spFileMatrix'. */
X    ASSERT_IS_SPARSE( Matrix );
X
/* Open file matrix file in write mode. */
X    if ((pMatrixFile = fopen(File, "w")) == NULL)
X        return 0;
X
/* Output header. */
X    Size = Matrix->Size;
X    if (Header)
X    {   if (Matrix->Factored AND Data)
X        {   Err = fprintf
X            (   pMatrixFile,
X                "Warning : The following matrix is factored in to LU form.\n"
X            );
X	    if (Err < 0) return 0;
X        }
X        if (fprintf(pMatrixFile, "%s\n", Label) < 0) return 0;
X        Err = fprintf( pMatrixFile, "%d\t%s\n", Size,
X                                    (Matrix->Complex ? "complex" : "real"));
X        if (Err < 0) return 0;
X    }
X    if (Size == 0) return 1;
X
/* Output matrix. */
X    if (NOT Data)
X    {   for (I = 1; I <= Size; I++)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   if (Reordered)
X                {   Row = pElement->Row;
X                    Col = I;
X                }
X                else
X                {   Row = Matrix->IntToExtRowMap[pElement->Row];
X                    Col = Matrix->IntToExtColMap[I];
X                }
X                pElement = pElement->NextInCol;
X                if (fprintf(pMatrixFile, "%d\t%d\n", Row, Col) < 0) return 0;
X            }
X        }
/* Output terminator, a line of zeros. */
X        if (Header)
X            if (fprintf(pMatrixFile, "0\t0\n") < 0) return 0;
X    }
X
#if spCOMPLEX
X    if (Data AND Matrix->Complex)
X    {   for (I = 1; I <= Size; I++)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   if (Reordered)
X                {   Row = pElement->Row;
X                    Col = I;
X                }
X                else
X                {   Row = Matrix->IntToExtRowMap[pElement->Row];
X                    Col = Matrix->IntToExtColMap[I];
X                }
X                Err = fprintf
X                (   pMatrixFile,"%d\t%d\t%-.15g\t%-.15g\n",
X                    Row, Col, (double)pElement->Real, (double)pElement->Imag
X                );
X                if (Err < 0) return 0;
X                pElement = pElement->NextInCol;
X            }
X        }
/* Output terminator, a line of zeros. */
X        if (Header)
X            if (fprintf(pMatrixFile,"0\t0\t0.0\t0.0\n") < 0) return 0;
X
X    }
#endif /* spCOMPLEX */
X
#if REAL
X    if (Data AND NOT Matrix->Complex)
X    {   for (I = 1; I <= Size; I++)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   Row = Matrix->IntToExtRowMap[pElement->Row];
X                Col = Matrix->IntToExtColMap[I];
X                Err = fprintf
X                (   pMatrixFile,"%d\t%d\t%-.15g\n",
X                    Row, Col, (double)pElement->Real
X                );
X                if (Err < 0) return 0;
X                pElement = pElement->NextInCol;
X            }
X        }
/* Output terminator, a line of zeros. */
X        if (Header)
X            if (fprintf(pMatrixFile,"0\t0\t0.0\n") < 0) return 0;
X
X    }
#endif /* REAL */
X
/* Close file. */
X    if (fclose(pMatrixFile) < 0) return 0;
X    return 1;
}
X
X
X
X
X
X
X
/*!
X *  Writes vector to file in format suitable to be read back in by the
X *  matrix test program.  This routine should be executed after the function
X *  spFileMatrix.
X *
X *  \return
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query \a errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param File
X *      Name of file into which matrix is to be written.
X *  \param RHS
X *      Right-hand side vector. This is only the real portion if
X *      \a spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iRHS
X *      Right-hand side vector, imaginary portion.  Not necessary if matrix
X *      is real or if \a spSEPARATED_COMPLEX_VECTORS is set false.
X *      \a iRHS is a macro that replaces itself with `, iRHS' if the options
X *      \a spCOMPLEX and \a spSEPARATED_COMPLEX_VECTORS are set, otherwise
X *      it disappears without a trace.
X */
/*  >>> Local variables:
X *  pMatrixFile  (FILE *)
X *      File pointer to the matrix file.
X *  Size  (int)
X *      The size of the matrix.
X */
X
int
spFileVector(
X    spMatrix eMatrix,
X    char *File,
X    spREAL RHS[]
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X    , spREAL iRHS[]
#endif
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  int  I, Size, Err;
FILE  *pMatrixFile;
X
/* Begin `spFileVector'. */
X    ASSERT_IS_SPARSE( Matrix );
X    vASSERT( RHS != NULL, "Vector missing" );
X
/* Open File in append mode. */
X    if ((pMatrixFile = fopen(File,"a")) == NULL)
X        return 0;
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spCOMPLEX
X    if (Matrix->Complex)
X    {
#if spSEPARATED_COMPLEX_VECTORS
X        vASSERT( iRHS != NULL, "Imaginary vector missing" );
X        --RHS;
X        --iRHS;
#else
X        RHS -= 2;
#endif
X    }
X    else
#endif /* spCOMPLEX */
X        --RHS;
#endif /* NOT ARRAY_OFFSET */
X
X
/* Output vector. */
X    Size = Matrix->Size;
X    if (Size == 0) return 1;
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {
#if spSEPARATED_COMPLEX_VECTORS
X        for (I = 1; I <= Size; I++)
X        {   Err = fprintf
X            (   pMatrixFile, "%-.15g\t%-.15g\n",
X                (double)RHS[I], (double)iRHS[I]
X            );
X            if (Err < 0) return 0;
X        }
#else
X        for (I = 1; I <= Size; I++)
X        {   Err = fprintf
X            (   pMatrixFile, "%-.15g\t%-.15g\n",
X                (double)RHS[2*I], (double)RHS[2*I+1]
X            );
X            if (Err < 0) return 0;
X        }
#endif
X    }
#endif /* spCOMPLEX */
#if REAL AND spCOMPLEX
X    else
#endif
#if REAL
X    {   for (I = 1; I <= Size; I++)
X        {   if (fprintf(pMatrixFile, "%-.15g\n", (double)RHS[I]) < 0)
X                return 0;
X        }
X    }
#endif /* REAL */
X
/* Close file. */
X    if (fclose(pMatrixFile) < 0) return 0;
X    return 1;
}
X
X
X
X
X
X
X
X
X
/*!
X *  Writes useful information concerning the matrix to a file.  Should be
X *  executed after the matrix is factored.
X * 
X *  \return
X *  One is returned if routine was successful, otherwise zero is returned.
X *  The calling function can query \a errno (the system global error variable)
X *  as to the reason why this routine failed.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param File
X *      Name of file into which matrix is to be written.
X *  \param Label
X *      String that is transferred to file and is used as a label.
X */
/*  >>> Local variables:
X *  Data  (RealNumber)
X *      The value of the matrix element being output.
X *  LargestElement  (RealNumber)
X *      The largest element in the matrix.
X *  NumberOfElements  (int)
X *      Number of nonzero elements in the matrix.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  pStatsFile  (FILE *)
X *      File pointer to the statistics file.
X *  Size  (int)
X *      The size of the matrix.
X *  SmallestElement  (RealNumber)
X *      The smallest element in the matrix excluding zero elements.
X */
X
int
spFileStats(
X    spMatrix eMatrix,
X    char *File,
X    char *Label
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  int  Size, I;
register  ElementPtr  pElement;
int NumberOfElements;
RealNumber  Data, LargestElement, SmallestElement;
FILE  *pStatsFile;
X
/* Begin `spFileStats'. */
X    ASSERT_IS_SPARSE( Matrix );
X
/* Open File in append mode. */
X    if ((pStatsFile = fopen(File, "a")) == NULL)
X        return 0;
X
/* Output statistics. */
X    Size = Matrix->Size;
X    if (NOT Matrix->Factored)
X        fprintf(pStatsFile, "Matrix has not been factored.\n");
X    fprintf(pStatsFile, "|||  Starting new matrix  |||\n");
X    fprintf(pStatsFile, "%s\n", Label);
X    if (Matrix->Complex)
X        fprintf(pStatsFile, "Matrix is complex.\n");
X    else
X        fprintf(pStatsFile, "Matrix is real.\n");
X    fprintf(pStatsFile,"     Size = %d\n",Size);
X    if (Size == 0) return 1;
X
/* Search matrix. */
X    NumberOfElements = 0;
X    LargestElement = 0.0;
X    SmallestElement = LARGEST_REAL;
X
X    for (I = 1; I <= Size; I++)
X    {   pElement = Matrix->FirstInCol[I];
X        while (pElement != NULL)
X        {   NumberOfElements++;
X            Data = ELEMENT_MAG(pElement);
X            if (Data > LargestElement)
X                LargestElement = Data;
X            if (Data < SmallestElement AND Data != 0.0)
X                SmallestElement = Data;
X            pElement = pElement->NextInCol;
X        }
X    }
X
X    SmallestElement = MIN( SmallestElement, LargestElement );
X
/* Output remaining statistics. */
X    fprintf(pStatsFile, "     Initial number of elements = %d\n",
X            NumberOfElements - Matrix->Fillins);
X    fprintf(pStatsFile,
X            "     Initial average number of elements per row = %f\n",
X            (double)(NumberOfElements - Matrix->Fillins) / (double)Size);
X    fprintf(pStatsFile, "     Fill-ins = %d\n",Matrix->Fillins);
X    fprintf(pStatsFile, "     Average number of fill-ins per row = %f%%\n",
X            (double)Matrix->Fillins / (double)Size);
X    fprintf(pStatsFile, "     Total number of elements = %d\n",
X            NumberOfElements);
X    fprintf(pStatsFile, "     Average number of elements per row = %f\n",
X            (double)NumberOfElements / (double)Size);
X    fprintf(pStatsFile,"     Density = %f%%\n",
X	    (100.0*(double)NumberOfElements)/((double)Size*(double)Size));
X    fprintf(pStatsFile,"     Relative Threshold = %e\n", Matrix->RelThreshold);
X    fprintf(pStatsFile,"     Absolute Threshold = %e\n", Matrix->AbsThreshold);
X    fprintf(pStatsFile,"     Largest Element = %e\n", LargestElement);
X    fprintf(pStatsFile,"     Smallest Element = %e\n\n\n", SmallestElement);
X
/* Close file. */
X    (void)fclose(pStatsFile);
X    return 1;
}
#endif /* DOCUMENTATION */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spOutput.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spOutput.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spOutput.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spOutput.c: MD5 check failed'
       ) << \SHAR_EOF
55952f2ead49c70ba2a68b4a9c0641b7  sparse/spOutput.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spOutput.c'` -ne 22792 && \
  ${echo} 'restoration warning:  size of sparse/spOutput.c is not 22792'
  fi
fi
# ============= sparse/spRevision ==============
if test -f 'sparse/spRevision' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spRevision (file already exists)'
else
${echo} 'x - extracting sparse/spRevision (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spRevision' &&
/*
X *  REVISION HISTORY
X *
X *  Author:
X *      Kenneth S. Kundert
X *      kundert@users.sourceforge.net
X *
X *  References
X *  Kenneth S. Kundert.  Sparse matrix techniques.  In "Circuit Analysis,
X *      Simulation and Design," vol. 3, pt. 1, Albert E. Ruehli (editor).
X *      North-Holland, 1986.
X */
X
/*
X *  Copyright information.
X *
X *  Copyright (c) 1985-2003
X *  by Kenneth S. Kundert
X *  All rights reserved
X */
X
/*
X *  >>> Current revision information:
X *  $Author: kundert $
X *  $Date: 2003/06/07 05:48:42 $
X *  $Revision: 1.2 $
X */
X
X
X
X
X
X
/*
X *  >>> History:
X *  Revision 1.1  January 1985
X *      Initial release.
X *
X *  Revision 1.1a  20 March 1985
X *      Modified DecomposeMatrix() and OrderAndDecomposeMatrix() so that
X *      the parameters Growth, PseudoCondition and LargestElement may be 
X *      given as NULL.
X *
X *  Revision 1.1b  28 March 1985
X *      Corrected a bug that caused OrderAndDecomposeMatrix() to reorder
X *      the matrix every time it was called.  Also made many of the global
X *      variables defined in MtrxDecom.c static.
X *
X *  Revision 1.2  October 1985
X *      This new version of Sparse is meant to make it more compatible
X *      with interactive circuit simulators.  In it the TRANSLATE
X *      option was added, along with the ability to access the matrix
X *      with AddElementToMatrix() and AddAdmittanceToMatrix() after it
X *      has been reordered.  Also added were the DeleteRowAndColFromMatrix(),
X *      CleanMatrix(), GetMatrixSize(), SetMatrixReal() and SetMatrixComplex()
X *      routines.
X *
X *  Revision 1.2a  April 1986
X *      Fixed a bug that caused the matrix frame to get freed twice and one
X *      in the test program that caused sparse to crash when a complex matrix
X *      with no source vector was attempted.
X *
X *  Revision 1.2b  July 1986
X *      Modified the test routine so that it allocates vectors from the heap
X *      rather than the stack.
X *
X *  Revision 1.2c  February 1987
X *      Fixed off-by-one error in PreorderForModifiedNodal().
X *
X *  Revision 1.2d
X *      Modified the pivot selection algorithm so that singletons also meet
X *      numerical threshold criterion.  Deleted some global variables.  Modified
X *      test program to add command line options among other things.  Made 
X *      thresholds sticky, so that once a valid threshold has been specified
X *      for a particular matrix, it becomes the new default.
X *
X *  Revision 1.3a  July 1988
X *      Made numerous changes.  Highlights are:
X *      Routine names shortened and made unique to 8 characters.
X *      Unordering factorization is faster.
X *      Added self initialization feature.
X *      Sparse now aborts on errors that should not occur.
X *      Cleaned up test program.
X *      Separated growth and pseudocondition calculations from factorization.
X *      Added LINPACK condition number estimator.
X *      Rewrote spMNA_Preorder, algorithm extended to fix inadequacies.
X *      Eliminated all global variables.
X *      Added DIAGONAL_PIVOTING option (only diagonal pivoting before).
X *
X *  Revision 1.3b  August 1988
X *	Added function declarations at the top of each file.
X *
X *  Revision 1.3c  January 1989
X *      Fixed bug in spFactor.c:SearchForSingleton that caused the program
X *      to crash when looking for a singleton in a row or column in the
X *      reduced submatrix that has no elements.
X *
X *  Revision 1.3d  June 1989
X *      Compatibility to Spice3c1 added.
X *      Added spErrorMessage() error message printing function.
X *
X *  Revision 1.3e  March 1990
X *      Fixed bug that caused sparse to crash when using spMultiply() or
X *	spMultTransposed() before the matrix had been factored once.
X *      Compatibility to Spice3d1 added.
X *
X *  Revision 1.3f  July 1990
X *	Fixed bug in spFactor.c:spOrderAndFactor().
X *	Added verbose ASSERT() and ABORT().
X *
X *  Revision 1.4a  June 2003
X *	Modernized the API a bit.
X *	Fixed the Markowitz overflow problem.
X *	Released on SourceForge as open source software.
X */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spRevision'; eval "$shar_touch") &&
  chmod 0600 'sparse/spRevision'
if test $? -ne 0
then ${echo} 'restore of sparse/spRevision failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spRevision: MD5 check failed'
       ) << \SHAR_EOF
832dc3fa5d0c8012c2acbd97ec670ffa  sparse/spRevision
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spRevision'` -ne 3994 && \
  ${echo} 'restoration warning:  size of sparse/spRevision is not 3994'
  fi
fi
# ============= sparse/spSMP.c ==============
if test -f 'sparse/spSMP.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spSMP.c (file already exists)'
else
${echo} 'x - extracting sparse/spSMP.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spSMP.c' &&
/*
X *  Spice3 COMPATIBILITY MODULE
X *
X *  Author:                     Advising professor:
X *     Kenneth S. Kundert           Alberto Sangiovanni-Vincentelli
X *     UC Berkeley
X *
X *  This module contains routines that make Sparse1.4 a direct
X *  replacement for the SMP sparse matrix package in Spice3c1 and Spice3d1.
X *  Sparse1.4 is in general a faster and more robust package than SMP.
X *  These advantages become significant on large circuits.
X *
X *  This module is provided for convience only. It has not been tested
X *  with the recent version of Spice3 and is not supported.
X *
X *  >>> User accessible functions contained in this file:
X *  SMPaddElt
X *  SMPmakeElt
X *  SMPcClear
X *  SMPclear
X *  SMPcLUfac
X *  SMPluFac
X *  SMPcReorder
X *  SMPreorder
X *  SMPcaSolve
X *  SMPcSolve
X *  SMPsolve
X *  SMPmatSize
X *  SMPnewMatrix
X *  SMPdestroy
X *  SMPpreOrder
X *  SMPprint
X *  SMPgetError
X *  SMPcProdDiag
X */
X
/*
X *  To replace SMP with Sparse, rename the file spSpice3.h to
X *  spMatrix.h and place Sparse in a subdirectory of SPICE called
X *  `sparse'.  Then on UNIX compile Sparse by executing `make spice'.
X *  If not on UNIX, after compiling Sparse and creating the sparse.a
X *  archive, compile this file (spSMP.c) and spSMP.o to the archive,
X *  then copy sparse.a into the SPICE main directory and rename it
X *  SMP.a.  Finally link SPICE.
X *
X *  To be compatible with SPICE, the following Sparse compiler options
X *  (in spConfig.h) should be set as shown below:
X *
X *      REAL                            YES
X *      EXPANDABLE                      YES
X *      TRANSLATE                       NO
X *      INITIALIZE                      NO or YES, YES for use with test prog.
X *      DIAGONAL_PIVOTING               YES
X *      ARRAY_OFFSET                    YES
X *      MODIFIED_MARKOWITZ              NO
X *      DELETE                          NO
X *      STRIP                           NO
X *      MODIFIED_NODAL                  YES
X *      QUAD_ELEMENT                    NO
X *      TRANSPOSE                       YES
X *      SCALING                         NO
X *      DOCUMENTATION                   YES
X *      MULTIPLICATION                  NO
X *      DETERMINANT                     YES
X *      STABILITY                       NO
X *      CONDITION                       NO
X *      PSEUDOCONDITION                 NO
X *      FORTRAN                         NO
X *      DEBUG                           YES
X *      spCOMPLEX                       1
X *      spSEPARATED_COMPLEX_VECTORS     1
X *
X *      spREAL  double
X */
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spSMP.c,v 1.3 2003/06/30 19:40:51 kundert Exp $";
#endif
X
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spMatrix.h
X *     Sparse macros and declarations.
X *  SMPdefs.h
X *     Spice3's matrix macro definitions.
X */
X
#include "spMatrix.h"
#include "../include/SMPdefs.h"
X
#define NO   0
#define YES  1
X
X
/*
X * SMPaddElt()
X */
int
SMPaddElt( Matrix, Row, Col, Value )
SMPmatrix *Matrix;
int Row, Col;
double Value;
{
X    *spGetElement( (char *)Matrix, Row, Col ) = Value;
X    return spError( (char *)Matrix );
}
X
/*
X * SMPmakeElt()
X */
double *
SMPmakeElt( Matrix, Row, Col )
SMPmatrix *Matrix;
int Row, Col;
{
X    return spGetElement( (char *)Matrix, Row, Col );
}
X
/*
X * SMPcClear()
X */
void
SMPcClear( Matrix )
SMPmatrix *Matrix;
{
X    spClear( (char *)Matrix );
}
X
/*
X * SMPclear()
X */
void
SMPclear( Matrix )
SMPmatrix *Matrix;
{
X    spClear( (char *)Matrix );
}
X
/*
X * SMPcLUfac()
X */
/*ARGSUSED*/
int
SMPcLUfac( Matrix, PivTol )
SMPmatrix *Matrix;
double PivTol;
{
X    spSetComplex( (char *)Matrix );
X    return spFactor( (char *)Matrix );
}
X
/*
X * SMPluFac()
X */
/*ARGSUSED*/
int
SMPluFac( Matrix, PivTol, Gmin )
SMPmatrix *Matrix;
double PivTol, Gmin;
{
X    spSetReal( (char *)Matrix );
X    LoadGmin( (char *)Matrix, Gmin );
X    return spFactor( (char *)Matrix );
}
X
/*
X * SMPcReorder()
X */
int
SMPcReorder( Matrix, PivTol, PivRel, NumSwaps )
SMPmatrix *Matrix;
double PivTol, PivRel;
int *NumSwaps;
{
X    *NumSwaps = 0;
X    spSetComplex( (char *)Matrix );
X    return spOrderAndFactor( (char *)Matrix, (spREAL*)NULL,
X                             (spREAL)PivRel, (spREAL)PivTol, YES );
}
X
/*
X * SMPreorder()
X */
int
SMPreorder( Matrix, PivTol, PivRel, Gmin )
SMPmatrix *Matrix;
double PivTol, PivRel, Gmin;
{
X    spSetComplex( (char *)Matrix );
X    LoadGmin( (char *)Matrix, Gmin );
X    return spOrderAndFactor( (char *)Matrix, (spREAL*)NULL,
X                             (spREAL)PivRel, (spREAL)PivTol, YES );
}
X
/*
X * SMPcaSolve()
X */
void
SMPcaSolve( Matrix, RHS, iRHS, Spare, iSpare)
SMPmatrix *Matrix;
double RHS[], iRHS[], Spare[], iSpare[];
{
X    spSolveTransposed( (char *)Matrix, RHS, RHS, iRHS, iRHS );
}
X
/*
X * SMPcSolve()
X */
void
SMPcSolve( Matrix, RHS, iRHS, Spare, iSpare)
SMPmatrix *Matrix;
double RHS[], iRHS[], Spare[], iSpare[];
{
X    spSolve( (char *)Matrix, RHS, RHS, iRHS, iRHS );
}
X
/*
X * SMPsolve()
X */
void
SMPsolve( Matrix, RHS, Spare )
SMPmatrix *Matrix;
double RHS[], Spare[];
{
X    spSolve( (char *)Matrix, RHS, RHS, (spREAL*)NULL, (spREAL*)NULL );
}
X
/*
X * SMPmatSize()
X */
int
SMPmatSize( Matrix )
SMPmatrix *Matrix;
{
X    return spGetSize( (char *)Matrix, 1 );
}
X
/*
X * SMPnewMatrix()
X */
int
SMPnewMatrix( pMatrix )
SMPmatrix **pMatrix;
{
int Error;
X    *pMatrix = (SMPmatrix *)spCreate( 0, 1, &Error );
X    return Error;
}
X
/*
X * SMPdestroy()
X */
void
SMPdestroy( Matrix )
SMPmatrix *Matrix;
{
X    spDestroy( (char *)Matrix );
}
X
/*
X * SMPpreOrder()
X */
int
SMPpreOrder( Matrix )
SMPmatrix *Matrix;
{
X    spMNA_Preorder( (char *)Matrix );
X    return spError( (char *)Matrix );
}
X
/*
X * SMPprint()
X */
/*ARGSUSED*/
void
SMPprint( Matrix, File )
SMPmatrix *Matrix;
FILE *File;
{
X    spPrint( (char *)Matrix, 0, 1, 1 );
}
X
/*
X * SMPgetError()
X */
void
SMPgetError( Matrix, Col, Row)
SMPmatrix *Matrix;
int *Row, *Col;
{
X    spWhereSingular( (char *)Matrix, Row, Col );
}
X
/*
X * SMPcProdDiag()
X */
int
SMPcProdDiag( Matrix, pMantissa, pExponent)
SMPmatrix *Matrix;
SPcomplex *pMantissa;
int *pExponent;
{
X    spDeterminant( (char *)Matrix, pExponent, &(pMantissa->real),
X                                              &(pMantissa->imag) );
X    return spError( (char *)Matrix );
}
X
/*
X *  LOAD GMIN
X *
X *  This routine adds Gmin to each diagonal element.  Because Gmin is
X *  added to the current diagonal, which may bear little relation to
X *  what the outside world thinks is a diagonal, and because the
X *  elements that are diagonals may change after calling spOrderAndFactor,
X *  use of this routine is not recommended.  It is included here simply
X *  for compatibility with Spice3.
X */
#include "spDefs.h"
X
LoadGmin( eMatrix, Gmin )
X
char *eMatrix;
register double Gmin;
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
register int I;
register ArrayOfElementPtrs Diag;
X
/* Begin `spLoadGmin'. */
X    ASSERT_IS_SPARSE( Matrix );
X
X    Diag = Matrix->Diag;
X    for (I = Matrix->Size; I > 0; I--)
X        Diag[I]->Real += Gmin;
X    return;
}
X
X
X
X
X
/*
X *  FIND ELEMENT
X *
X *  This routine finds an element in the matrix by row and column number.
X *  If the element exists, a pointer to it is returned.  If not, then NULL
X *  is returned unless the CreateIfMissing flag is true, in which case a
X *  pointer to the new element is returned.
X */
X
SMPelement *
SMPfindElt( eMatrix, Row, Col, CreateIfMissing )
X
char *eMatrix;
int Row, Col;
int CreateIfMissing;
{
MatrixPtr Matrix = (MatrixPtr)eMatrix;
spREAL *Element = (spREAL *)Matrix->FirstInCol[Col];
X
/* Begin `SMPfindElt'. */
X    ASSERT_IS_SPARSE( Matrix );
X    if (CreateIfMissing)
X    {   Element = spcCreateElement( Matrix, Row, Col,
X				    &Matrix->FirstInRow[Row],
X				    &Matrix->FirstInCol[Col], NO );
X    }
X    else Element = spcFindElement( Matrix, Row, Col );
X    return (SMPelement *)Element;
}
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spSMP.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spSMP.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spSMP.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spSMP.c: MD5 check failed'
       ) << \SHAR_EOF
9d1df87663d33281e556a06efe26afd5  sparse/spSMP.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spSMP.c'` -ne 7999 && \
  ${echo} 'restoration warning:  size of sparse/spSMP.c is not 7999'
  fi
fi
# ============= sparse/spSolve.c ==============
if test -f 'sparse/spSolve.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spSolve.c (file already exists)'
else
${echo} 'x - extracting sparse/spSolve.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spSolve.c' &&
/*
X *  MATRIX SOLVE MODULE
X *
X *  Author:                     Advising professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X */
/*! \file
X *  This file contains the forward and backward substitution routines for
X *  the sparse matrix routines.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spSolve
X *  spSolveTransposed
X *
X *  >>> Other functions contained in this file:
X *  SolveComplexMatrix
X *  SolveComplexTransposedMatrix
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003
X *  by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spSolve.c,v 1.3 2003/06/29 04:19:52 kundert Exp $";
#endif
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *     Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *     Macros and declarations to be imported by the user.
X *  spDefs.h
X *     Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
/*
X * Function declarations
X */
X
#if spSEPARATED_COMPLEX_VECTORS
static void SolveComplexMatrix( MatrixPtr,
X                        RealVector, RealVector, RealVector, RealVector );
static void SolveComplexTransposedMatrix( MatrixPtr,
X                        RealVector, RealVector, RealVector, RealVector );
#else
static void SolveComplexMatrix( MatrixPtr, RealVector, RealVector );
static void SolveComplexTransposedMatrix( MatrixPtr,
X			RealVector, RealVector );
#endif
X
X
X
X
X
X
X
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the \a RHS vector and factored matrix.  This
X *  routine assumes that the pivots are associated with the lower
X *  triangular matrix and that the diagonal of the upper triangular
X *  matrix consists of ones.  This routine arranges the computation
X *  in different way than is traditionally used in order to exploit the
X *  sparsity of the right-hand side.  See the reference in spRevision.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param RHS
X *      \a RHS is the input data array, the right hand side. This data is
X *      undisturbed and may be reused for other solves.
X *  \param Solution
X *      \a Solution is the output data array. This routine is constructed
X *      such that \a RHS and \a Solution can be the same array.
X *  \param iRHS
X *      \a iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      This argument is only necessary if matrix is complex and if
X *      \a spSEPARATED_COMPLEX_VECTOR is set true.
X *  \param iSolution
X *      \a iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that \a iRHS and \a iSolution can be
X *      the same array.  This argument is only necessary if matrix is complex
X *      and if \a spSEPARATED_COMPLEX_VECTOR is set true.
X */
/*  >>> Local variables:
X *  Intermediate  (RealVector)
X *      Temporary storage for use in forward elimination and backward
X *      substitution.  Commonly referred to as c, when the LU factorization
X *      equations are given as  Ax = b, Lc = b, Ux = c Local version of
X *      Matrix->Intermediate, which was created during the initial
X *      factorization in function spcCreateInternalVectors() in the matrix
X *      factorization module.
X *  pElement  (ElementPtr)
X *      Pointer used to address elements in both the lower and upper triangle
X *      matrices.
X *  pExtOrder  (int *)
X *      Pointer used to sequentially access each entry in IntToExtRowMap
X *      and IntToExtColMap arrays.  Used to quickly scramble and unscramble
X *      RHS and Solution to account for row and column interchanges.
X *  pPivot  (ElementPtr)
X *      Pointer that points to current pivot or diagonal element.
X *  Size  (int)
X *      Size of matrix. Made local to reduce indirection.
X *  Temp  (RealNumber)
X *      Temporary storage for entries in arrays.
X *
X *  >>> Obscure Macros
X *  IMAG_VECTORS
X *      Replaces itself with `, iRHS, iSolution' if the options spCOMPLEX and
X *      spSEPARATED_COMPLEX_VECTORS are set, otherwise it disappears
X *      without a trace.
X */
X
/*VARARGS3*/
X
void
spSolve(
X    spMatrix eMatrix,
X    spREAL RHS[],
X    spREAL Solution[]
#   if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X	, spREAL iRHS[]
X	, spREAL iSolution[]
#   endif
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement;
register  RealVector  Intermediate;
register  RealNumber  Temp;
register  int  I, *pExtOrder, Size;
ElementPtr  pPivot;
void SolveComplexMatrix();
X
/* Begin `spSolve'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   SolveComplexMatrix( Matrix, RHS, Solution IMAG_VECTORS );
X        return;
X    }
#endif
X
#if REAL
X    Intermediate = Matrix->Intermediate;
X    Size = Matrix->Size;
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
X    --RHS;
X    --Solution;
#endif
X
/* Initialize Intermediate vector. */
X    pExtOrder = &Matrix->IntToExtRowMap[Size];
X    for (I = Size; I > 0; I--)
X        Intermediate[I] = RHS[*(pExtOrder--)];
X
/* Forward elimination. Solves Lc = b.*/
X    for (I = 1; I <= Size; I++)
X    {   
/* This step of the elimination is skipped if Temp equals zero. */
X        if ((Temp = Intermediate[I]) != 0.0)
X        {   pPivot = Matrix->Diag[I];
X            Intermediate[I] = (Temp *= pPivot->Real);
X
X            pElement = pPivot->NextInCol;
X            while (pElement != NULL)
X            {   Intermediate[pElement->Row] -= Temp * pElement->Real;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X
/* Backward Substitution. Solves Ux = c.*/
X    for (I = Size; I > 0; I--)
X    {   Temp = Intermediate[I];
X        pElement = Matrix->Diag[I]->NextInRow;
X        while (pElement != NULL)
X        {   Temp -= pElement->Real * Intermediate[pElement->Col];
X            pElement = pElement->NextInRow;
X        }
X        Intermediate[I] = Temp;
X    }
X
/* Unscramble Intermediate vector while placing data in to Solution vector. */
X    pExtOrder = &Matrix->IntToExtColMap[Size];
X    for (I = Size; I > 0; I--)
X        Solution[*(pExtOrder--)] = Intermediate[I];
X
X    return;
#endif /* REAL */
}
X
X
X
X
X
X
X
X
X
X
X
#if spCOMPLEX
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the RHS vector and factored matrix.  This
X *  routine assumes that the pivots are associated with the lower
X *  triangular matrix and that the diagonal of the upper triangular
X *  matrix consists of ones.  This routine arranges the computation
X *  in different way than is traditionally used in order to exploit the
X *  sparsity of the right-hand side.  See the reference in spRevision.
X *
X *  \param Matrix
X *      Pointer to matrix.
X *  \param RHS
X *      RHS is the real portion of the input data array, the right hand
X *      side. This data is undisturbed and may be reused for other solves.
X *  \param Solution
X *      Solution is the real portion of the output data array. This routine
X *      is constructed such that RHS and Solution can be the same
X *      array.
X *  \param iRHS
X *      iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      If spSEPARATED_COMPLEX_VECTOR is set false, there is no need to
X *      supply this array.
X *  \param iSolution
X *      iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that iRHS and iSolution can be
X *      the same array.  If spSEPARATED_COMPLEX_VECTOR is set false, there is no
X *      need to supply this array.
X */
/*  >>> Local variables:
X *  Intermediate  (ComplexVector)
X *      Temporary storage for use in forward elimination and backward
X *      substitution.  Commonly referred to as c, when the LU factorization
X *      equations are given as  Ax = b, Lc = b, Ux = c.
X *      Local version of Matrix->Intermediate, which was created during
X *      the initial factorization in function spcCreateInternalVectors() in the
X *      matrix factorization module.
X *  pElement  (ElementPtr)
X *      Pointer used to address elements in both the lower and upper triangle
X *      matrices.
X *  pExtOrder  (int *)
X *      Pointer used to sequentially access each entry in IntToExtRowMap
X *      and IntToExtColMap arrays.  Used to quickly scramble and unscramble
X *      RHS and Solution to account for row and column interchanges.
X *  pPivot  (ElementPtr)
X *      Pointer that points to current pivot or diagonal element.
X *  Size  (int)
X *      Size of matrix. Made local to reduce indirection.
X *  Temp  (ComplexNumber)
X *      Temporary storage for entries in arrays.
X */
X
static void
SolveComplexMatrix(
X    MatrixPtr Matrix,
X    RealVector RHS,
X    RealVector Solution
#   if spSEPARATED_COMPLEX_VECTORS
X	, RealVector iRHS
X	, RealVector iSolution
#   endif
)
{
register  ElementPtr  pElement;
register  ComplexVector  Intermediate;
register  int  I, *pExtOrder, Size;
ElementPtr  pPivot;
register ComplexVector  ExtVector;
ComplexNumber  Temp;
X
/* Begin `SolveComplexMatrix'. */
X
X    Size = Matrix->Size;
X    Intermediate = (ComplexVector)Matrix->Intermediate;
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spSEPARATED_COMPLEX_VECTORS
X    --RHS;      --iRHS;
X    --Solution; --iSolution;
#else
X    RHS -= 2; Solution -= 2;
#endif
#endif
X
/* Initialize Intermediate vector. */
X    pExtOrder = &Matrix->IntToExtRowMap[Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Size; I > 0; I--)
X    {   Intermediate[I].Real = RHS[*(pExtOrder)];
X        Intermediate[I].Imag = iRHS[*(pExtOrder--)];
X    }
#else
X    ExtVector = (ComplexVector)RHS;
X    for (I = Size; I > 0; I--)
X        Intermediate[I] = ExtVector[*(pExtOrder--)];
#endif
X
/* Forward substitution. Solves Lc = b.*/
X    for (I = 1; I <= Size; I++)
X    {   Temp = Intermediate[I];
X
/* This step of the substitution is skipped if Temp equals zero. */
X        if ((Temp.Real != 0.0) OR (Temp.Imag != 0.0))
X        {   pPivot = Matrix->Diag[I];
/* Cmplx expr: Temp *= (1.0 / Pivot). */
X            CMPLX_MULT_ASSIGN(Temp, *pPivot);
X            Intermediate[I] = Temp;
X            pElement = pPivot->NextInCol;
X            while (pElement != NULL)
X            {
/* Cmplx expr: Intermediate[Element->Row] -= Temp * *Element. */
X                CMPLX_MULT_SUBT_ASSIGN(Intermediate[pElement->Row],
X                                       Temp, *pElement);
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X
/* Backward Substitution. Solves Ux = c.*/
X    for (I = Size; I > 0; I--)
X    {   Temp = Intermediate[I];
X        pElement = Matrix->Diag[I]->NextInRow;
X
X        while (pElement != NULL)
X        {
/* Cmplx expr: Temp -= *Element * Intermediate[Element->Col]. */
X            CMPLX_MULT_SUBT_ASSIGN(Temp, *pElement,Intermediate[pElement->Col]);
X            pElement = pElement->NextInRow;
X        }
X        Intermediate[I] = Temp;
X    }
X
/* Unscramble Intermediate vector while placing data in to Solution vector. */
X    pExtOrder = &Matrix->IntToExtColMap[Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Size; I > 0; I--)
X    {   Solution[*(pExtOrder)] = Intermediate[I].Real;
X        iSolution[*(pExtOrder--)] = Intermediate[I].Imag;
X    }
#else
X    ExtVector = (ComplexVector)Solution;
X    for (I = Size; I > 0; I--)
X        ExtVector[*(pExtOrder--)] = Intermediate[I];
#endif
X
X    return;
}
#endif /* spCOMPLEX */
X
X
X
X
X
X
X
X
X
X
X
X
X
X
#if TRANSPOSE
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the RHS vector and transposed factored
X *  matrix. This routine is useful when performing sensitivity analysis
X *  on a circuit using the adjoint method.  This routine assumes that
X *  the pivots are associated with the untransposed lower triangular
X *  matrix and that the diagonal of the untransposed upper
X *  triangular matrix consists of ones.
X *
X *  \param eMatrix
X *      Pointer to matrix.
X *  \param RHS
X *      \a RHS is the input data array, the right hand side. This data is
X *      undisturbed and may be reused for other solves.
X *  \param Solution
X *      \a Solution is the output data array. This routine is constructed
X *      such that \a RHS and \a Solution can be the same array.
X *  \param iRHS
X *      \a iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      If \a spSEPARATED_COMPLEX_VECTOR is set false, or if matrix is real,
X *      there is no need to supply this array.
X *  \param iSolution
X *      \a iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that \a iRHS and \a iSolution can be
X *      the same array.  If \a spSEPARATED_COMPLEX_VECTOR is set false, or if
X *      matrix is real, there is no need to supply this array.
X */
/*  >>> Local variables:
X *  Intermediate  (RealVector)
X *      Temporary storage for use in forward elimination and backward
X *      substitution.  Commonly referred to as c, when the LU factorization
X *      equations are given as  Ax = b, Lc = b, Ux = c.  Local version of
X *      Matrix->Intermediate, which was created during the initial
X *      factorization in function spcCreateInternalVectors() in the matrix
X *      factorization module.
X *  pElement  (ElementPtr)
X *      Pointer used to address elements in both the lower and upper triangle
X *      matrices.
X *  pExtOrder  (int *)
X *      Pointer used to sequentially access each entry in IntToExtRowMap
X *      and IntToExtRowMap arrays.  Used to quickly scramble and unscramble
X *      RHS and Solution to account for row and column interchanges.
X *  pPivot  (ElementPtr)
X *      Pointer that points to current pivot or diagonal element.
X *  Size  (int)
X *      Size of matrix. Made local to reduce indirection.
X *  Temp  (RealNumber)
X *      Temporary storage for entries in arrays.
X */
X
/*VARARGS3*/
X
void
spSolveTransposed(
X    spMatrix eMatrix,
X    spREAL  RHS[],
X    spREAL  Solution[]
#   if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X	, spREAL iRHS[]
X	, spREAL iSolution[]
#   endif
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement;
register  RealVector  Intermediate;
register  int  I, *pExtOrder, Size;
ElementPtr  pPivot;
RealNumber  Temp;
void SolveComplexTransposedMatrix();
X
/* Begin `spSolveTransposed'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   SolveComplexTransposedMatrix( Matrix, RHS, Solution IMAG_VECTORS );
X        return;
X    }
#endif
X
#if REAL
X    Size = Matrix->Size;
X    Intermediate = Matrix->Intermediate;
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
X    --RHS;
X    --Solution;
#endif
X
/* Initialize Intermediate vector. */
X    pExtOrder = &Matrix->IntToExtColMap[Size];
X    for (I = Size; I > 0; I--)
X        Intermediate[I] = RHS[*(pExtOrder--)];
X
/* Forward elimination. */
X    for (I = 1; I <= Size; I++)
X    {   
/* This step of the elimination is skipped if Temp equals zero. */
X        if ((Temp = Intermediate[I]) != 0.0)
X        {   pElement = Matrix->Diag[I]->NextInRow;
X            while (pElement != NULL)
X            {   Intermediate[pElement->Col] -= Temp * pElement->Real;
X                pElement = pElement->NextInRow;
X            }
X
X        }
X    }
X
/* Backward Substitution. */
X    for (I = Size; I > 0; I--)
X    {   pPivot = Matrix->Diag[I];
X        Temp = Intermediate[I];
X        pElement = pPivot->NextInCol;
X        while (pElement != NULL)
X        {   Temp -= pElement->Real * Intermediate[pElement->Row];
X            pElement = pElement->NextInCol;
X        }
X        Intermediate[I] = Temp * pPivot->Real;
X    }
X
/* Unscramble Intermediate vector while placing data in to Solution vector. */
X    pExtOrder = &Matrix->IntToExtRowMap[Size];
X    for (I = Size; I > 0; I--)
X        Solution[*(pExtOrder--)] = Intermediate[I];
X
X    return;
#endif /* REAL */
}
#endif /* TRANSPOSE */
X
X
X
X
X
X
X
X
X
X
#if TRANSPOSE AND spCOMPLEX
/*!
X *  Performs forward elimination and back substitution to find the
X *  unknown vector from the RHS vector and transposed factored
X *  matrix. This routine is useful when performing sensitivity analysis
X *  on a circuit using the adjoint method.  This routine assumes that
X *  the pivots are associated with the untransposed lower triangular
X *  matrix and that the diagonal of the untransposed upper
X *  triangular matrix consists of ones.
X *
X *  \param Matrix
X *      Pointer to matrix.
X *  \param RHS
X *      \a RHS is the input data array, the right hand
X *      side. This data is undisturbed and may be reused for other solves.
X *      This vector is only the real portion if the matrix is complex and
X *      \a spSEPARATED_COMPLEX_VECTORS is set true.
X *  \param Solution
X *      \a Solution is the real portion of the output data array. This routine
X *      is constructed such that \a RHS and \a Solution can be the same array.
X *      This vector is only the real portion if the matrix is complex and
X *      \a spSEPARATED_COMPLEX_VECTORS is set true.
X *  \param iRHS
X *      \a iRHS is the imaginary portion of the input data array, the right
X *      hand side. This data is undisturbed and may be reused for other solves.
X *      If either \a spCOMPLEX or \a spSEPARATED_COMPLEX_VECTOR is set false,
X *      there is no need to supply this array.
X *  \param iSolution
X *      \a iSolution is the imaginary portion of the output data array. This
X *      routine is constructed such that \a iRHS and \a iSolution can be
X *      the same array.  If \a spCOMPLEX or \a spSEPARATED_COMPLEX_VECTOR is set
X *      false, there is no need to supply this array.
X */
/*  >>> Local variables:
X *  Intermediate  (ComplexVector)
X *      Temporary storage for use in forward elimination and backward
X *      substitution.  Commonly referred to as c, when the LU factorization
X *      equations are given as  Ax = b, Lc = b, Ux = c.  Local version of
X *      Matrix->Intermediate, which was created during
X *      the initial factorization in function spcCreateInternalVectors() in the
X *      matrix factorization module.
X *  pElement  (ElementPtr)
X *      Pointer used to address elements in both the lower and upper triangle
X *      matrices.
X *  pExtOrder  (int *)
X *      Pointer used to sequentially access each entry in IntToExtRowMap
X *      and IntToExtColMap arrays.  Used to quickly scramble and unscramble
X *      RHS and Solution to account for row and column interchanges.
X *  pPivot  (ElementPtr)
X *      Pointer that points to current pivot or diagonal element.
X *  Size  (int)
X *      Size of matrix. Made local to reduce indirection.
X *  Temp  (ComplexNumber)
X *      Temporary storage for entries in arrays.
X */
X
static void
SolveComplexTransposedMatrix(
X    MatrixPtr  Matrix,
X    RealVector  RHS,
X    RealVector  Solution
#   if spSEPARATED_COMPLEX_VECTORS
X	, RealVector iRHS
X	, RealVector iSolution
#   endif
)
{
register  ElementPtr  pElement;
register  ComplexVector  Intermediate;
register  int  I, *pExtOrder, Size;
register  ComplexVector  ExtVector;
ElementPtr  pPivot;
ComplexNumber  Temp;
X
/* Begin `SolveComplexTransposedMatrix'. */
X
X    Size = Matrix->Size;
X    Intermediate = (ComplexVector)Matrix->Intermediate;
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spSEPARATED_COMPLEX_VECTORS
X    --RHS;      --iRHS;
X    --Solution; --iSolution;
#else
X    RHS -= 2;   Solution -= 2;
#endif
#endif
X
/* Initialize Intermediate vector. */
X    pExtOrder = &Matrix->IntToExtColMap[Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Size; I > 0; I--)
X    {   Intermediate[I].Real = RHS[*(pExtOrder)];
X        Intermediate[I].Imag = iRHS[*(pExtOrder--)];
X    }
#else
X    ExtVector = (ComplexVector)RHS;
X    for (I = Size; I > 0; I--)
X        Intermediate[I] = ExtVector[*(pExtOrder--)];
#endif
X
/* Forward elimination. */
X    for (I = 1; I <= Size; I++)
X    {   Temp = Intermediate[I];
X
/* This step of the elimination is skipped if Temp equals zero. */
X        if ((Temp.Real != 0.0) OR (Temp.Imag != 0.0))
X        {   pElement = Matrix->Diag[I]->NextInRow;
X            while (pElement != NULL)
X            {
/* Cmplx expr: Intermediate[Element->Col] -= Temp * *Element. */
X                CMPLX_MULT_SUBT_ASSIGN( Intermediate[pElement->Col],
X                                        Temp, *pElement);
X                pElement = pElement->NextInRow;
X            }
X        }
X    }
X
/* Backward Substitution. */
X    for (I = Size; I > 0; I--)
X    {   pPivot = Matrix->Diag[I];
X        Temp = Intermediate[I];
X        pElement = pPivot->NextInCol;
X
X        while (pElement != NULL)
X        {
/* Cmplx expr: Temp -= Intermediate[Element->Row] * *Element. */
X            CMPLX_MULT_SUBT_ASSIGN(Temp,Intermediate[pElement->Row],*pElement);
X
X            pElement = pElement->NextInCol;
X        }
/* Cmplx expr: Intermediate = Temp * (1.0 / *pPivot). */
X        CMPLX_MULT(Intermediate[I], Temp, *pPivot);
X    }
X
/* Unscramble Intermediate vector while placing data in to Solution vector. */
X    pExtOrder = &Matrix->IntToExtRowMap[Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Size; I > 0; I--)
X    {   Solution[*(pExtOrder)] = Intermediate[I].Real;
X        iSolution[*(pExtOrder--)] = Intermediate[I].Imag;
X    }
#else
X    ExtVector = (ComplexVector)Solution;
X    for (I = Size; I > 0; I--)
X        ExtVector[*(pExtOrder--)] = Intermediate[I];
#endif
X
X    return;
}
#endif /* TRANSPOSE AND spCOMPLEX */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spSolve.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spSolve.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spSolve.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spSolve.c: MD5 check failed'
       ) << \SHAR_EOF
0fe08947f4394fb87be58ee22870b8fc  sparse/spSolve.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spSolve.c'` -ne 22041 && \
  ${echo} 'restoration warning:  size of sparse/spSolve.c is not 22041'
  fi
fi
# ============= sparse/spSpice3.h ==============
if test -f 'sparse/spSpice3.h' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spSpice3.h (file already exists)'
else
${echo} 'x - extracting sparse/spSpice3.h (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spSpice3.h' &&
/*
X *  EXPORTS for sparse matrix routines with SPICE3.
X *
X *  Author:                     Advising professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X *
X *  This file contains definitions that are useful to the calling
X *  program.  In particular, this file contains error keyword
X *  definitions, some macro functions that are used to quickly enter
X *  data into the matrix and the type definition of a data structure
X *  that acts as a template for entering admittances into the matrix.
X *  Also included is the type definitions for the various functions
X *  available to the user.
X *
X *  This file is a modified version of spMatrix.h that is used when
X *  interfacing to Spice3.
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X *
X *  $Date: 2003/06/29 04:19:52 $
X *  $Revision: 1.2 $
X */
X
X
X
X
#ifndef  spOKAY
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *      Macros that customize the sparse matrix routines.
X */
X
#include "spConfig.h"
X
X
X
X
X
X
/*
X *  ERROR KEYWORDS
X *
X *  The actual numbers used in the error codes are not sacred, they can be
X *  changed under the condition that the codes for the nonfatal errors are
X *  less than the code for spFATAL and similarly the codes for the fatal
X *  errors are greater than that for spFATAL.
X *
X *  >>> Error descriptions:
X *  spOKAY
X *      No error has occurred.
X *  spSMALL_PIVOT
X *      When reordering the matrix, no element was found which satisfies the
X *      threshold criteria.  The largest element in the matrix was chosen
X *      as pivot.  Non-fatal.
X *  spZERO_DIAG
X *      Fatal error.  A zero was encountered on the diagonal the matrix.  This
X *      does not necessarily imply that the matrix is singular.  When this
X *      error occurs, the matrix should be reconstructed and factored using
X *      spOrderAndFactor().  In spCOMPATIBILITY mode, spZERO_DIAG is
X *      indistinguishable from spSINGULAR.
X *  spSINGULAR
X *      Fatal error.  Matrix is singular, so no unique solution exists.
X *  spNO_MEMORY
X *      Fatal error.  Indicates that not enough memory is available to handle
X *      the matrix.
X *  spPANIC
X *      Fatal error indicating that the routines are not prepared to
X *      handle the matrix that has been requested.  This may occur when
X *      the matrix is specified to be real and the routines are not
X *      compiled for real matrices, or when the matrix is specified to
X *      be complex and the routines are not compiled to handle complex
X *      matrices.
X *  spFATAL
X *      Not an error flag, but rather the dividing line between fatal errors
X *      and warnings.
X */
X
#include "../include/SPerror.h"  /* Spice error definitions. */
X
/* Begin error macros. */
#define  spOKAY                 OK
#define  spSMALL_PIVOT          OK
#define  spZERO_DIAG            E_SINGULAR
#define  spSINGULAR             E_SINGULAR
#define  spNO_MEMORY            E_NOMEM
#define  spPANIC                E_BADMATRIX
X
#define  spFATAL                E_BADMATRIX
X
X
#if spCOMPATIBILITY
#define  NO_ERROR               spOKAY
#define  UNDER_FLOW             spOKAY
#define  OVER_FLOW              spOKAY
#define  ILL_CONDITIONED        spSMALL_PIVOT
#define  SINGULAR               spSINGULAR
#define  NO_MEMORY              spNO_MEMORY
#define  RANGE                  spPANIC
X
#define  FATAL                  spFATAL
X
#undef   spZERO_DIAG
#define  spZERO_DIAG            spSINGULAR
#endif /* spCOMPATIBILITY */
X
X
X
X
X
/*
X *  KEYWORD DEFINITIONS
X *
X *  Here we define what precision arithmetic Sparse will use.  Double
X *  precision is suggested as being most appropriate for circuit
X *  simulation and for C.  However, it is possible to change spREAL
X *  to a float for single precision arithmetic.  Note that in C, single
X *  precision arithmetic is often slower than double precision.  Sparse
X *  internally refers to spREALs as RealNumbers.
X *
X *  Some C compilers, notably the old VMS compiler, do not handle the keyword
X *  "void" correctly.  If this is true for your compiler, remove the
X *  comment delimiters from the redefinition of void to int below.
X */
X
#define  spREAL double
/* #define  void    int   */
X
#if spCOMPATIBILITY
#define SPARSE_REAL     spREAL
#endif
X
X
X
/*
X *  PARTITION TYPES
X *
X *  When factoring a previously ordered matrix using spFactor(), Sparse
X *  operates on a row-at-a-time basis.  For speed, on each step, the row
X *  being updated is copied into a full vector and the operations are
X *  performed on that vector.  This can be done one of two ways, either
X *  using direct addressing or indirect addressing.  Direct addressing
X *  is fastest when the matrix is relatively dense and indirect addressing
X *  is quite sparse.  The user can select which partitioning mode is used.
X *  The following keywords are passed to spPartition() and indicate that
X *  Sparse should use only direct addressing, only indirect addressing, or
X *  that it should choose the best mode on a row-by-row basis.  The time
X *  required to choose a partition is of the same order of the cost to factor
X *  the matrix.
X *
X *  If you plan to factor a large number of matrices with the same structure,
X *  it is best to let Sparse choose the partition.  Otherwise, you should
X *  choose the partition based on the predicted density of the matrix.
X */
X
/* Begin partition keywords. */
X
#define spDEFAULT_PARTITION     0
#define spDIRECT_PARTITION      1
#define spINDIRECT_PARTITION    2
#define spAUTO_PARTITION        3
X
X
X
X
X
/*
X *  MACRO FUNCTION DEFINITIONS
X *
X *  >>> Macro descriptions:
X *  spADD_REAL_ELEMENT
X *      Macro function that adds data to a real element in the matrix by a
X *      pointer.
X *  spADD_IMAG_ELEMENT
X *      Macro function that adds data to a imaginary element in the matrix by
X *      a pointer.
X *  spADD_COMPLEX_ELEMENT
X *      Macro function that adds data to a complex element in the matrix by a
X *      pointer.
X *  spADD_REAL_QUAD
X *      Macro function that adds data to each of the four real matrix elements
X *      specified by the given template.
X *  spADD_IMAG_QUAD
X *      Macro function that adds data to each of the four imaginary matrix
X *      elements specified by the given template.
X *  spADD_COMPLEX_QUAD
X *      Macro function that adds data to each of the four complex matrix
X *      elements specified by the given template.
X */
X
/* Begin Macros. */
#define  spADD_REAL_ELEMENT(element,real)       *(element) += real
X
#define  spADD_IMAG_ELEMENT(element,imag)       *(element+1) += imag
X
#define  spADD_COMPLEX_ELEMENT(element,real,imag)       \
{   *(element) += real;                                 \
X    *(element+1) += imag;                               \
}
X
#define  spADD_REAL_QUAD(template,real)         \
{   *((template).Element1) += real;             \
X    *((template).Element2) += real;             \
X    *((template).Element3Negated) -= real;      \
X    *((template).Element4Negated) -= real;      \
}
X
#define  spADD_IMAG_QUAD(template,imag)         \
{   *((template).Element1+1) += imag;           \
X    *((template).Element2+1) += imag;           \
X    *((template).Element3Negated+1) -= imag;    \
X    *((template).Element4Negated+1) -= imag;    \
}
X
#define  spADD_COMPLEX_QUAD(template,real,imag) \
{   *((template).Element1) += real;             \
X    *((template).Element2) += real;             \
X    *((template).Element3Negated) -= real;      \
X    *((template).Element4Negated) -= real;      \
X    *((template).Element1+1) += imag;           \
X    *((template).Element2+1) += imag;           \
X    *((template).Element3Negated+1) -= imag;    \
X    *((template).Element4Negated+1) -= imag;    \
}
X
#if spCOMPATIBILITY
#define  ADD_REAL_ELEMENT_TO_MATRIX             spADD_REAL_ELEMENT
#define  ADD_IMAG_ELEMENT_TO_MATRIX             spADD_IMAG_ELEMENT
#define  ADD_COMPLEX_ELEMENT_TO_MATRIX          spADD_COMPLEX_ELEMENT
#define  ADD_REAL_QUAD_ELEMENT_TO_MATRIX        spADD_REAL_ELEMENT
#define  ADD_IMAG_QUAD_ELEMENT_TO_MATRIX        spADD_IMAG_ELEMENT
#define  ADD_COMPLEX_QUAD_ELEMENT_TO_MATRIX     spADD_COMPLEX_ELEMENT
#endif
X
X
X
X
X
X
/*
X *   TYPE DEFINITION FOR COMPONENT TEMPLATE
X *
X *   This data structure is used to hold pointers to four related elements in
X *   matrix.  It is used in conjunction with the routines
X *       spGetAdmittance
X *       spGetQuad
X *       spGetOnes
X *   These routines stuff the structure which is later used by the spADD_QUAD
X *   macro functions above.  It is also possible for the user to collect four
X *   pointers returned by spGetElement and stuff them into the template.
X *   The spADD_QUAD routines stuff data into the matrix in locations specified
X *   by Element1 and Element2 without changing the data.  The data is negated
X *   before being placed in Element3 and Element4.
X */
X
#if spCOMPATIBILITY
#define spTemplate TemplateStruct
#endif
X
/* Begin `spTemplate'. */
struct  spTemplate
{   spREAL    *Element1       ;
X    spREAL    *Element2       ;
X    spREAL    *Element3Negated;
X    spREAL    *Element4Negated;
};
X
X
X
X
X
/*
X *   FUNCTION TYPE DEFINITIONS
X *
X *   The type of every user accessible function is declared here.
X */
X
/* Begin function declarations. */
X
spcEXTERN  void     spClear( char* );
spcEXTERN  spREAL   spCondition( char*, spREAL, int* );
spcEXTERN  char    *spCreate( int, int, int* );
spcEXTERN  void     spDeleteRowAndCol( char*, int, int );
spcEXTERN  void     spDestroy( char* );
spcEXTERN  int      spElementCount( char* );
spcEXTERN  int      spError( char* );
spcEXTERN  int      spFactor( char* );
spcEXTERN  int      spFileMatrix( char*, char*, char*, int, int, int );
spcEXTERN  int      spFileStats( char*, char*, char* );
spcEXTERN  int      spFillinCount( char* );
spcEXTERN  int      spGetAdmittance( char*, int, int,
X				struct spTemplate* );
spcEXTERN  spREAL  *spGetElement( char*, int, int );
spcEXTERN  char    *spGetInitInfo( spREAL* );
spcEXTERN  int      spGetOnes( char*, int, int, int,
X				struct spTemplate* );
spcEXTERN  int      spGetQuad( char*, int, int, int, int,
X				struct spTemplate* );
spcEXTERN  int      spGetSize( char*, int );
spcEXTERN  int      spInitialize( char*, int (*)() );
spcEXTERN  void     spInstallInitInfo( spREAL*, char* );
spcEXTERN  spREAL   spLargestElement( char* );
spcEXTERN  void     spMNA_Preorder( char* );
spcEXTERN  spREAL   spNorm( char* );
spcEXTERN  int      spOrderAndFactor( char*, spREAL[], spREAL,
X				spREAL, int );
spcEXTERN  void     spPartition( char*, int );
spcEXTERN  void     spPrint( char*, int, int, int );
spcEXTERN  spREAL   spPseudoCondition( char* );
spcEXTERN  spREAL   spRoundoff( char*, spREAL );
spcEXTERN  void     spScale( char*, spREAL[], spREAL[] );
spcEXTERN  void     spSetComplex( char* );
spcEXTERN  void     spSetReal( char* );
spcEXTERN  void     spStripFills( char* );
spcEXTERN  void     spWhereSingular( char*, int*, int* );
X
/* Functions with argument lists that are dependent on options. */
X
#if spCOMPLEX
spcEXTERN  void     spDeterminant( char*, int*, spREAL*, spREAL* );
#else /* NOT spCOMPLEX */
spcEXTERN  void     spDeterminant( char*, int*, spREAL* );
#endif /* NOT spCOMPLEX */
#if spCOMPLEX && spSEPARATED_COMPLEX_VECTORS
spcEXTERN  int      spFileVector( char*, char* , spREAL[], spREAL[]);
spcEXTERN  void     spMultiply( char*, spREAL[], spREAL[], spREAL[],
X				spREAL[] );
spcEXTERN  void     spMultTransposed( char*, spREAL[], spREAL[],
X				spREAL[], spREAL[] );
spcEXTERN  void     spSolve( char*, spREAL[], spREAL[], spREAL[],
X				spREAL[] );
spcEXTERN  void     spSolveTransposed( char*, spREAL[], spREAL[],
X				spREAL[], spREAL[] );
#else /* NOT  (spCOMPLEX && spSEPARATED_COMPLEX_VECTORS) */
spcEXTERN  int      spFileVector( char*, char* , spREAL[] );
spcEXTERN  void     spMultiply( char*, spREAL[], spREAL[] );
spcEXTERN  void     spMultTransposed( char*, spREAL[], spREAL[] );
spcEXTERN  void     spSolve( char*, spREAL[], spREAL[] );
spcEXTERN  void     spSolveTransposed( char*, spREAL[], spREAL[] );
#endif /* NOT  (spCOMPLEX && spSEPARATED_COMPLEX_VECTORS) */
#endif  /* spOKAY */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spSpice3.h'; eval "$shar_touch") &&
  chmod 0600 'sparse/spSpice3.h'
if test $? -ne 0
then ${echo} 'restore of sparse/spSpice3.h failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spSpice3.h: MD5 check failed'
       ) << \SHAR_EOF
797a57330d34a47fc2934b567695c2c9  sparse/spSpice3.h
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spSpice3.h'` -ne 12073 && \
  ${echo} 'restoration warning:  size of sparse/spSpice3.h is not 12073'
  fi
fi
# ============= sparse/spTest.c ==============
if test -f 'sparse/spTest.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spTest.c (file already exists)'
else
${echo} 'x - extracting sparse/spTest.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spTest.c' &&
/*
X *  TEST MODULE for the sparse matrix routines
X *
X *  Author:                     Advisor:
X *     Kenneth S. Kundert           Alberto Sangiovanni-Vincentelli
X *     UC Berkeley
X *
X *  This file contains the test routine for the sparse matrix routines.
X *  They are able to read matrices from files and solve them.
X *
X *  >>> Functions contained in this file:
X *  main
X *  ReadMatrixFromFile
X *  Init
X *  CheckOutComplexArray
X *  CheckInAllComplexArrays
X *  PrintMatrixErrorMessage
X *  InterpretCommandLine
X *  GetProgramName
X *  Usage
X *  EnlargeVectors
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spTest.c,v 1.5 2003/06/30 19:40:51 kundert Exp $";
#endif
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  stdio.h math.h ctype.h
X *      Standard C libraries.
X *  spConfig.h
X *      Macros that customize the sparse matrix package. It is not normally
X *      necessary, nor is normally particularly desirable to include this
X *      file into the calling routines.  Nor should spINSIDE_SPARSE be defined.
X *      It is done in this test file so that the complex test routines may be
X *      removed when they don't exist in Sparse.
X *  spMatrix.h
X *      Macros and declarations to be imported by the user.
X */
X
#define  YES    1
#define  NO     0
X
#include <stdio.h>
#include <math.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#define spINSIDE_SPARSE
#include "spConfig.h"
#undef spINSIDE_SPARSE
#include "spMatrix.h"
X
X
/* Declarations that should be in strings.h. 
extern int strcmp(), strncmp(), strlen();*/
X
#ifdef lint
#undef  MULTIPLICATION
#undef  DETERMINANT
X
#define  MULTIPLICATION                 YES
#define  DETERMINANT                    YES
X
#define LINT    YES
#else /* not lint */
#define LINT    NO
#endif /* not lint */
X
X
X
X
X
X
X
/*
X *   TIMING
X */
X
X
#ifndef vms
#   include <sys/param.h>
#endif
#ifndef HZ
#       ifdef __STDC__
#       include <time.h>
#       include <limits.h>
#       define HZ   CLK_TCK
#   else
#       ifdef mips
#           include <time.h>
#           define HZ   CLK_TCK
#       endif
#   endif
#endif
#ifndef HZ
#   ifdef vax
#       ifdef unix
#           define HZ   60
#       endif
#       ifdef vms
#           define HZ   100
#       endif
#   endif
#   ifdef hpux
#       ifdef hp300
#           define HZ   50
#       endif
#       ifdef hp500
#           define HZ   60
#       endif
#   endif
#   ifdef hpux
#       ifdef hp300
#           define HZ   50
#       endif
#       ifdef hp500
#           define HZ   60
#       endif
#   endif
#endif
X
/* Routine that queries the system to find the process time. */
double
Time()
{
X    struct time {long user, system, childuser, childsystem;} time;
X    (void)times(&time);
X    return (double)time.user / (double)HZ;
}
X
X
X
X
X
/*
X *  MACROS
X */
X
#define  BOOLEAN  int
#define  NOT  !
#define  AND  &&
#define  OR  ||
#define  ALLOC(type,number) ((type *)malloc((unsigned)(sizeof(type)*(number))))
#define  ABS(a)         ((a) < 0.0 ? -(a) : (a))
#ifdef MAX
#undef  MAX
#endif
#ifdef MIN
#undef  MIN
#endif
#define  MAX(a,b)       ((a) > (b) ? (a) : (b))
#define  MIN(a,b)       ((a) < (b) ? (a) : (b))
X
X
X
X
X
X
/*
X *  IMAGINARY VECTORS
X *
X *  The imaginary vectors iRHS and iSolution are only needed when the
X *  options spCOMPLEX and spSEPARATED_COMPLEX_VECTORS are set.  The following
X *  macro makes it easy to include or exclude these vectors as needed.
X */
X
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
#define IMAG_VECTORS    , iRHS, iSolution
#else
#define IMAG_VECTORS
#endif
X
X
X
X
X
X
X
/*
X *   GLOBAL DECLARATIONS
X *
X *   These variables, types, and macros are used throughout this file.
X *
X *   >>> Macros
X *   PRINT_LIMIT
X *       The maximum number of terms to be printed form the solution vector.
X *       May be overridden by the -n option.
X *
X *   >>> Variable types:
X *   ElementRecord
X *       A structure for holding data for each matrix element.
X *
X *   >>> Global variables:
X *  ProgramName  (char *)
X *      The name of the test program with any path stripped off.
X *  FileName  (char *)
X *      The name of the current file name.
X *  Complex  (BOOLEAN)
X *      The flag that indicates whether the matrix is complex or real.
X *  Element  (ElementRecord[])
X *      Array used to hold information about all the elements.
X *  Matrix  (char *)
X *      The pointer to the matrix.
X *  Size  (int)
X *      The size of the matrix.
X *  RHS  (RealVector)
X *      The right-hand side vector (b in Ax = b).
X *  Solution  (RealVector)
X *      The solution vector (x in Ax = b).
X *  RHS_Verif  (RealVector)
X *      The calculated RHS vector.
X */
X
/* Begin global declarations. */
#define  PRINT_LIMIT  9
X
typedef  spREAL  RealNumber, *RealVector;
X
typedef  struct
{   RealNumber Real;
X    RealNumber Imag;
} ComplexNumber, *ComplexVector;
X
static char *ProgramName;
static char *FileName;
static int  Size, MaxSize = 0;
static int  PrintLimit = PRINT_LIMIT, Iterations = 1, ColumnAsRHS = 1;
static BOOLEAN  Complex, SolutionOnly = NO, RealAsComplex = NO, Transposed = NO;
static BOOLEAN  CreatePlotFiles = NO, UseColumnAsRHS = NO, PrintLimitSet = NO;
static BOOLEAN ExpansionWarningGiven, DiagPivoting = DIAGONAL_PIVOTING;
static char  Message[BUFSIZ], *Matrix = NULL;
static RealNumber AbsThreshold = (RealNumber)0, RelThreshold = (RealNumber)0;
static RealVector RHS, Solution, RHS_Verif;
static RealVector iRHS, iSolution, iRHS_Verif;
static ComplexVector  cRHS, cSolution, cRHS_Verif;
X
X
X
X
X
X
/*
X * Function declarations
X */
X
static int  ReadMatrixFromFile();
static int  Init();
static ComplexVector CheckOutComplexArray();
static void CheckInAllComplexArrays();
static void PrintMatrixErrorMessage();
static int  InterpretCommandLine();
static char *GetProgramName();
static void Usage();
static void EnlargeVectors();
X
X
X
X
X
X
X
/*
X *  MAIN TEST ROUTINE for sparse matrix routines
X *
X *  This routine reads a matrix from a file and solves it several
X *  times.  The solution is printed along with some statistics.
X *  The format expected for the input matrix is the same as what is output by
X *  spFileMatrix and spFileVector.
X *
X *  >>> Local variables:
X *  Determinant  (RealNumber)
X *      Real portion of the determinant of the matrix.
X *  iDeterminant  (RealNumber)
X *      Imaginary portion of the determinant of the matrix.
X *  Error  (int)
X *      Holds error status.
X *  Last  (int)
X *      The index of the last term to be printed of the solution.
X *  Iterations  (int)
X *      The number of times that the matrix will be factored and solved.
X *  MaxRHS  (RealNumber)
X *      The largest term in the given RHS vector.
X *  Residual  (RealNumber)
X *      The sum of the magnitude of the differences in each corresponding
X *      term of the given and calculated RHS vector.
X *  Exponent  (int)
X *      Exponent for the determinant.
X *  Growth  (RealNumber)
X *      The growth that has occurred in the matrix during the factorization.
X *
X *  >>> Timing variables:
X *  BuildTime  (double)
X *      The time required to build up the matrix including the time to clear
X *      the matrix.
X *  ConditionTime  (double)
X *      The time required to compute the condition number.
X *  DeterminantTime  (double)
X *      The time required to compute the determinant.
X *  FactorTime  (double)
X *      The time required to factor the matrix without ordering.
X *  InitialFactorTime  (double)
X *      The time required to factor the matrix with ordering.
X *  SolveTime  (double)
X *      The time required to perform the forward and backward elimination.
X *  StartTime  (double)
X *      The time that a timing interval was started.
X *
X *  >>> Global variables:
X *  Complex  <used>
X *  Matrix  <set>
X *  Size  <used>
X *  RHS  <used>
X *  iRHS  <used>
X */
X
X
int
main( int ArgCount, char **Args )
{
register  long I;
int  Error, Last, Elements, Fillins;
RealNumber  MaxRHS, Residual;
RealNumber  Determinant, iDeterminant;
int  Exponent;
RealNumber  ConditionNumber, PseudoCondition;
RealNumber  LargestBefore, LargestAfter, Roundoff, InfNorm;
BOOLEAN StandardInput;
char j, PlotFile[BUFSIZ], ErrMsg[BUFSIZ];
double  StartTime, BeginTime, BuildTime, FactorTime, SolveTime, PartitionTime;
double  InitialFactorTime, ConditionTime, DeterminantTime;
extern double  Time();
X
/* Begin `main'. */
X
X    BeginTime = Time();
X    ArgCount = InterpretCommandLine( ArgCount, Args );
X
/* Assure that the Sparse is compatible with this test program.*/
#   if NOT EXPANDABLE OR NOT INITIALIZE OR NOT ARRAY_OFFSET
X        fprintf(stderr, 
X                "%s: Sparse is configured inappropriately for test program.\n",
X                ProgramName);
X        fprintf(stderr,
X      "    Enable EXPANDABLE, INITIALIZE, and ARRAY_OFFSET in `spConfig.h'.\n");
X        exit(1);
#   endif
X
/* Print copyright notice. */
X    printf("Sparse1.4\nCopyright (c) 2003, Kenneth S. Kundert.\nAll rights reserved.\n\n");
X
X    do
X    {
/* Initialization. */
X        BuildTime = FactorTime = SolveTime = 0.0;
X        ExpansionWarningGiven = NO;
X    
/* Create matrix. */
X        Matrix = spCreate( 0, spCOMPLEX, &Error );
X        if (Matrix == NULL)
X        {   fprintf(stderr, "%s: insufficient memory available.\n",
X                            ProgramName);
X            exit(1);
X        }
X        if( Error >= spFATAL ) goto End;
X
/* Read matrix. */
X        if (ArgCount == 0)
X            FileName = NULL;
X        else
X            FileName = *(++Args);
X        Error = ReadMatrixFromFile();
X        if( Error) goto End;
X        StandardInput = (FileName == NULL);
X
/* Clear solution vector if row and column numbers are not densely packed. */
X        if (spGetSize(Matrix, YES) != spGetSize(Matrix, NO))
X        {   if (Complex OR RealAsComplex)
X            {   for (I = Size; I > 0; I--)
X                    cSolution[I].Real = cSolution[I].Imag = 0.0;
X            }
X            else
X            {   for (I = Size; I > 0; I--)
X                    Solution[I] = 0.0;
X            }
X        }
X
/* Perform initial build, factor, and solve. */
X        (void)spInitialize(Matrix, Init);
X
#if MODIFIED_NODAL
X        spMNA_Preorder( Matrix );
#endif
#if DOCUMENTATION
X        if (CreatePlotFiles)
X        {   if (StandardInput)
X                (void)sprintf(PlotFile, "bef");
X            else
X                (void)sprintf(PlotFile, "%s.bef", FileName);
X            if (NOT spFileMatrix( Matrix, PlotFile, FileName, NO, NO, NO ))
X            {   (void)sprintf(ErrMsg,"%s: plotfile `%s'",ProgramName,PlotFile);
X                perror( ErrMsg );
X            }
X        }
#if NO
X        spPrint( Matrix, NO /*reodered*/, NO /*data*/, NO /*header*/ );
#endif
#endif /* DOCUMENTATION */
#if STABILITY
X        if (NOT SolutionOnly) LargestBefore = spLargestElement(Matrix);
#endif
#if CONDITION
X        if (NOT SolutionOnly) InfNorm = spNorm(Matrix);
#endif
X
X        StartTime = Time();
X        Error = spOrderAndFactor( Matrix, RHS, RelThreshold, AbsThreshold,
X                                  DiagPivoting );
X        InitialFactorTime = Time() - StartTime;
X        if (Error != spOKAY) spErrorMessage( Matrix, stderr, ProgramName );
X        if( Error >= spFATAL )
X            goto End;
X
#if DOCUMENTATION
X        if (CreatePlotFiles)
X        {   if (StandardInput)
X                (void)sprintf(PlotFile, "aft");
X            else
X                (void)sprintf(PlotFile, "%s.aft", FileName);
X            if (NOT spFileMatrix( Matrix, PlotFile, FileName, YES, NO, NO ))
X            {   (void)sprintf(ErrMsg,"%s: plotfile `%s'",ProgramName,PlotFile);
X                perror( ErrMsg );
X            }
X        }
#if NO
X        spFileStats( Matrix, FileName, "stats" );
#endif
#endif /* DOCUMENTATION */
X
/*
X * IMAG_VECTORS is a macro that replaces itself with `, iRHS, iSolution'
X * if the options spCOMPLEX and spSEPARATED_COMPLEX_VECTORS are set,
X * otherwise it disappears without a trace.
X */
#if TRANSPOSE
X        if (Transposed)
X            spSolveTransposed( Matrix, RHS, Solution IMAG_VECTORS );
X        else
#endif
X            spSolve( Matrix, RHS, Solution IMAG_VECTORS );
X
X        if (SolutionOnly)
X            Iterations = 0;
X        else
X        {
#if STABILITY
X            LargestAfter = spLargestElement(Matrix);
X            Roundoff = spRoundoff(Matrix, LargestAfter);
#endif
#if CONDITION
X            StartTime = Time();
X            ConditionNumber = spCondition(Matrix, InfNorm, &Error);
X            ConditionTime = Time() - StartTime;
X            spErrorMessage( Matrix, stderr, ProgramName );
#endif
#if PSEUDOCONDITION
X            PseudoCondition = spPseudoCondition(Matrix);
#endif
X
X            StartTime = Time();
X            spPartition( Matrix, spDEFAULT_PARTITION );
X            PartitionTime = Time() - StartTime;
X        }
X
/* Solve system of equations Iterations times. */
X        for(I = 1; I <= Iterations; I++)
X        {   StartTime = Time();
X            (void)spInitialize(Matrix, Init);
X            BuildTime += Time() - StartTime;
X
X            StartTime = Time();
X            Error = spFactor( Matrix );
X            FactorTime += Time() - StartTime;
X            if (Error != spOKAY) spErrorMessage( Matrix, stderr, ProgramName );
X            if (Error >= spFATAL) goto End;
X
X            StartTime = Time();
/*
X * IMAG_VECTORS is a macro that replaces itself with `, iRHS, iSolution'
X * if the options spCOMPLEX and spSEPARATED_COMPLEX_VECTORS are set,
X * otherwise it disappears without a trace.
X */
#if TRANSPOSE
X            if (Transposed)
X                spSolveTransposed(Matrix, RHS, Solution IMAG_VECTORS );
X            else
#endif
X                spSolve( Matrix, RHS, Solution IMAG_VECTORS );
X            SolveTime += Time() - StartTime;
X        }
X
/* Print Solution. */
X        if (SolutionOnly)
X        {   if (PrintLimitSet)
X                Last = MIN( PrintLimit, Size );
X            else
X                Last = Size;
X            j = ' ';
X        }
X        else
X        {   Last = (PrintLimit > Size) ? Size : PrintLimit;
X            if (Last > 0) printf("Solution:\n");
X            j = 'j';
X        }
X
X        if (Complex OR RealAsComplex)
X        {
#if spSEPARATED_COMPLEX_VECTORS
X            for (I = 1; I <= Last; I++)
X            {   printf("%-16.9g   %-.9g%c\n", (double)Solution[I],
X                                              (double)iSolution[I], j);
X            }
#else
X            for (I = 1; I <= Last; I++)
X            {   printf("%-16.9g   %-.9g%c\n", (double)cSolution[I].Real,
X                                              (double)cSolution[I].Imag, j);
X            }
#endif
X        }
X        else
X        {   for (I = 1; I <= Last; I++)
X                printf("%-.9g\n", (double)Solution[I]);
X        }
X        if (Last < Size AND Last != 0)
X            printf("Solution list truncated.\n");
X        printf("\n");
X
#if DETERMINANT
/* Calculate determinant. */
X        if (NOT SolutionOnly)
X        {   StartTime = Time();
#if spCOMPLEX
X            spDeterminant( Matrix, &Exponent, &Determinant, &iDeterminant );
#else
X            spDeterminant( Matrix, &Exponent, &Determinant );
#endif
X            DeterminantTime = Time() - StartTime;
X            if (Complex OR RealAsComplex)
X            {   Determinant = hypot( Determinant, iDeterminant );
X                while (Determinant >= 10.0)
X                {   Determinant *= 0.1;
X                    Exponent++;
X                }
X            }
X        }
#else
X        Determinant = 0.0;   Exponent = 0;
#endif
X
#if MULTIPLICATION
X        if (NOT SolutionOnly)
X        {
/* Calculate difference between actual RHS vector and RHS vector
X * calculated from solution. */
X
/* Find the largest element in the given RHS vector. */
X            MaxRHS = 0.0;
X
X            if (Complex OR RealAsComplex)
X            {
#if spSEPARATED_COMPLEX_VECTORS
X                for (I = 1; I <= Size; I++)
X                {   if (ABS(RHS[I]) > MaxRHS)
X                        MaxRHS = ABS(RHS[I]);
X                    if (ABS(iRHS[I]) > MaxRHS)
X                        MaxRHS = ABS(iRHS[I]);
X                }
#else
X                for (I = 1; I <= Size; I++)
X                {   if (ABS(cRHS[I].Real) > MaxRHS)
X                        MaxRHS = ABS(cRHS[I].Real);
X                    if (ABS(cRHS[I].Imag) > MaxRHS)
X                        MaxRHS = ABS(cRHS[I].Imag);
X                }
#endif
X            }
X            else
X            {   for (I = 1; I <= Size; I++)
X                {   if (ABS(RHS[I]) > MaxRHS)
X                        MaxRHS = ABS(RHS[I]);
X                }
X            }
X
/* Rebuild matrix. */
X            (void)spInitialize(Matrix, Init);
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X            if (Transposed)
X            {   spMultTransposed( Matrix, RHS_Verif, Solution,
X                                          iRHS_Verif, iSolution);
X            }
X            else spMultiply(Matrix, RHS_Verif, Solution, iRHS_Verif, iSolution);
#else
X            if (Transposed)
X                spMultTransposed( Matrix, RHS_Verif, Solution );
X            else
X                spMultiply( Matrix, RHS_Verif, Solution );
#endif
X
/* Calculate residual. */
X            Residual = 0.0;
X            if (Complex OR RealAsComplex)
X            {
#if spSEPARATED_COMPLEX_VECTORS
X                for (I = 1; I <= Size; I++)
X                {   Residual += ABS(RHS[I] - RHS_Verif[I])
X                                   + ABS(iRHS[I] - iRHS_Verif[I]);
X                }
#else
X                for (I = 1; I <= Size; I++)
X                {   Residual += ABS(cRHS[I].Real - cRHS_Verif[I].Real)
X                                   + ABS(cRHS[I].Imag - cRHS_Verif[I].Imag);
X                }
#endif
X            }
X            else
X            {   for (I = 1; I <= Size; I++)
X                    Residual += ABS(RHS[I] - RHS_Verif[I]);
X            }
X        }
#endif
X
/* Print statistics. */
X        if (NOT SolutionOnly)
X        {   Elements = spElementCount(Matrix);
X            Fillins = spFillinCount(Matrix);
X            
X            printf("Initial factor time = %.2f.\n", InitialFactorTime);
X            printf("Partition time = %.2f.\n", PartitionTime);
X            if (Iterations > 0)
X            {   printf("Build time = %.3f.\n", (BuildTime/Iterations));
X                printf("Factor time = %.3f.\n",(FactorTime/Iterations));
X                printf("Solve time = %.3f.\n", (SolveTime/Iterations));
X            }
#if STABILITY
X            printf("Condition time = %.2f.\n", ConditionTime);
#endif
#if DETERMINANT
X            printf("Determinant time = %.2f.\n", DeterminantTime);
#endif
X            printf("\nTotal number of elements = %d.\n", Elements);
X            printf("Average number of elements per row initially = %.2f.\n",
X                        (double)(Elements - Fillins) /
X                        (double)spGetSize(Matrix, NO));
X            printf("Total number of fill-ins = %d.\n", Fillins);
#if DETERMINANT OR MULTIPLICATION OR PSEUDOCONDITION OR CONDITION OR STABILITY
X            putchar('\n');
#endif
#if STABILITY
X            if (LargestBefore != 0.0)
X                printf("Growth = %.2g.\n", LargestAfter / LargestBefore);
X            printf("Max error in matrix = %.2g.\n", Roundoff);
#endif
#if STABILITY
X            if(ABS(ConditionNumber) > 10 * SMALLEST_REAL);
X                printf("Condition number = %.2g.\n", 1.0 / ConditionNumber);
#endif
#if CONDITION AND STABILITY
X            printf("Estimated upper bound of error in solution = %.2g.\n",
X                    Roundoff / ConditionNumber);
#endif
#if PSEUDOCONDITION
X            printf("PseudoCondition = %.2g.\n", PseudoCondition);
#endif
#if DETERMINANT
X            printf("Determinant = %.3g", (double)Determinant );
X            if (Determinant != 0.0 AND Exponent != 0)
X                printf("e%d", Exponent);
X            putchar('.'); putchar('\n');
#endif
#if MULTIPLICATION
X            if (MaxRHS != 0.0)
X                printf("Normalized residual = %.2g.\n", (Residual / MaxRHS));
#endif
X        }
X
End:;
X        (void)fflush(stdout);
X        CheckInAllComplexArrays();
X        spDestroy(Matrix);
X        Matrix = NULL;
X    } while( --ArgCount > 0 );
X
X    if (NOT SolutionOnly)
X    {   printf("\nAggregate resource usage:\n");
X        printf("    Time required = %.2f seconds.\n", Time() - BeginTime);
X        printf("    Virtual memory used = %d kBytes.\n\n", ((int)sbrk(0))/1000);
X    }
X    exit (0);
}
X
X
X
X
X
X
X
X
X
X
X
/*
X *   READ MATRIX FROM FILE
X *
X *   This function reads the input file for the matrix and the RHS vector.
X *   If no RHS vector exists, one is created.  If there is an error in the
X *   file, the appropriate error messages are delivered to standard output.
X *
X *   >>> Returned:
X *   The error status is returned.  If no error occurred, a zero is returned.
X *   Otherwise, a one is returned.
X *
X *   >>> Local variables:
X *   pMatrixFile  (FILE *)
X *       The pointer to the file that holds the matrix.
X *   InputString  (char [])
X *       String variable for holding input from the matrix file.
X *   Message  (char [])
X *       String variable that contains a one line descriptor of the matrix.
X *       Descriptor is taken from matrix file.
X *
X *   >>> Global variables:
X *   Complex  <set>
X *   Size  <set>
X *   Element  <set>
X *   RHS  <set>
X *   iRHS  <set>
X */
X
static int
ReadMatrixFromFile()
{
long I, Reads;
FILE *pMatrixFile;
char  sInput[BUFSIZ], sType[BUFSIZ], *p;
int Error, Row, Col, Count = 0, LineNumber, RHS_Col, IntSize;
double Real, Imag = 0.0;
ComplexNumber *pValue, *pInitInfo, *CheckOutComplexArray();
RealNumber *pElement;
static char *EndOfFile = "%s: unexpected end of file `%s' at line %d.\n";
static char *Syntax = "%s: syntax error in file `%s' at line %d.\n";
X
/* Begin `ReadMatrixFromFile'. */
X
/* Open matrix file in read mode. */
X    if (NOT SolutionOnly) putchar('\n');
X
X    if (FileName == NULL)
X    {   FileName = "standard input";
X        pMatrixFile = stdin;
X    }
X    else
X    {   pMatrixFile = fopen(FileName, "r");
X        if (pMatrixFile == NULL)
X        {   fprintf(stderr, "%s: file %s was not found.\n",
X                    ProgramName, FileName);
X            return 1;
X        }
X    }
X
X    Complex = NO;
X    LineNumber = 1;
X
/* Read and print label. */
X    if (NULL == fgets( Message, BUFSIZ, pMatrixFile ))
X    {   fprintf(stderr, EndOfFile, ProgramName, FileName, LineNumber);
X        return 1;
X    }
X
/* For compatibility with the old file syntax. */
X    if (!strncmp( Message, "Starting", 8 ))
X    {   /* Test for complex matrix. */
X        if (strncmp( Message, "Starting complex", 15 ) == 0)
X            Complex = YES;
X        LineNumber++;
X        if (NULL == fgets( Message, BUFSIZ, pMatrixFile ))
X        {   fprintf(stderr, EndOfFile, ProgramName, FileName, LineNumber);
X            return 1;
X        }
X    }
X    if (NOT SolutionOnly) printf("%-s\n", Message);
X
/* Read size of matrix and determine type of matrix. */
X    LineNumber++;
X    if (NULL == fgets( sInput, BUFSIZ, pMatrixFile ))
X    {   fprintf(stderr, EndOfFile, ProgramName, FileName, LineNumber);
X        return 1;
X    }
X    if ((Reads = sscanf( sInput,"%d %s", &Size, sType )) < 1)
X    {   fprintf(stderr, Syntax, ProgramName, FileName, LineNumber);
X        return 1;
X    }
X    if (Reads == 2)
X    {   for (p = sType; *p != '\0'; p++)
X            if (isupper(*p)) *p += 'a'-'A';
X        if (strncmp( sType, "complex", 7 ) == 0)
X            Complex = YES;
X        else if (strncmp( sType, "real", 7 ) == 0)
X            Complex = NO;
X        else
X        {   fprintf(stderr, Syntax, ProgramName, FileName, LineNumber);
X            return 1;
X        }
X    }
X    EnlargeVectors( Size, YES );
X    RHS_Col = MIN( Size, ColumnAsRHS );
X
#if NOT spCOMPLEX
X    if (Complex)
X    {   fprintf(stderr,
X                    "%s: Sparse is not configured to solve complex matrices.\n",
X                    ProgramName);
X        fprintf(stderr,"    Enable spCOMPLEX in `spConfig.h'.\n");
X        return 1;
X    }
#endif
#if NOT REAL
X    if (NOT (Complex OR RealAsComplex))
X    {   fprintf(stderr,
X                    "%s: Sparse is not configured to solve real matrices.\n",
X                    ProgramName);
X        fprintf(stderr,"    Enable REAL in `spConfig.h'.\n");
X        return 1;
X    }
#endif
X
/* Read matrix elements. */
X    do
X    {   if (Count == 0)
X            pValue = CheckOutComplexArray( Count = 1000 );
X
X        LineNumber++;
X        if (NULL == fgets( sInput, BUFSIZ, pMatrixFile ))
X        {   fprintf(stderr, "%s: unexpected end of file `%s' at line %d.\n",
X                    ProgramName, FileName, LineNumber);
X            return 1;
X        }
X
X        if (Complex)
X        {   Reads = sscanf( sInput,"%d%d%lf%lf", &Row, &Col, &Real, &Imag );
X            if (Reads != 4)
X            {   fprintf(stderr, "%s: syntax error in file `%s' at line %d.\n",
X                        ProgramName, FileName, LineNumber);
X                return 1;
X            }
X        }
X        else
X        {   Reads = sscanf( sInput,"%d%d%lf", &Row, &Col, &Real );
X            if (Reads != 3)
X            {   fprintf(stderr, "%s: syntax error in file `%s' at line %d.\n",
X                        ProgramName, FileName, LineNumber);
X                return 1;
X            }
X        }
X        if(Row < 0 OR Col < 0)
X        {   fprintf(stderr, "%s: index not positive in file `%s' at line %d.\n",
X                        ProgramName, FileName, LineNumber);
X            return 1;
X        }
X        if(Row > Size OR Col > Size)
X        {   if (NOT ExpansionWarningGiven)
X            {   fprintf( stderr,
X         "%s: computed and given matrix size differ in file `%s' at line %d.\n",
X                        ProgramName, FileName, LineNumber);
X                ExpansionWarningGiven = YES;
X            }
X            Size = MAX(Row, Col);
X            EnlargeVectors( Size, NO );
X        }
X        pElement = spGetElement( Matrix, Row, Col );
X        if (pElement == NULL)
X        {   fprintf(stderr, "%s: insufficient memory available.\n",
X                            ProgramName);
X            exit(1);
X        }
X        pInitInfo = (ComplexNumber *)spGetInitInfo( pElement );
X        if (pInitInfo == NULL)
X        {   pValue[--Count].Real = Real;
X            pValue[Count].Imag = Imag;
X            spInstallInitInfo( pElement, (char *)(pValue + Count) );
X        }
X        else
X        {   pInitInfo->Real += Real;
X            pInitInfo->Imag += Imag;
X        }
X
/* Save into RHS vector if in desired column. */
X        if (Col == RHS_Col)
X        {   if (Complex OR RealAsComplex)
X            {
#if spSEPARATED_COMPLEX_VECTORS
X                RHS[Row] = Real;
X                iRHS[Row] = Imag;
#else
X                cRHS[Row].Real = Real;
X                cRHS[Row].Imag = Imag;
#endif
X            }
X            else RHS[Row] = Real;
X        }
X    } while (Row != 0 AND Col != 0);
X
X    Size = spGetSize( Matrix, YES );
X    if (Error = spErrorState( Matrix ) != spOKAY)
X    {   spErrorMessage( Matrix, stderr, ProgramName );
X        if( Error >= spFATAL ) return 1;
X    }
X
/* Read RHS vector. */
X    if (NOT UseColumnAsRHS AND (NULL != fgets( sInput, BUFSIZ, pMatrixFile )))
X    {
/* RHS vector exists, read it. */
X        LineNumber++;
X        for (I = 1; I <= Size; I++)
X        {   if (I != 1 OR (strncmp( sInput, "Beginning", 8 ) == 0))
X            {   LineNumber++;
X                if (NULL == fgets( sInput, BUFSIZ, pMatrixFile ))
X                {   fprintf(stderr,
X                            "%s: unexpected end of file `%s' at line %d.\n",
X                            ProgramName, FileName, LineNumber);
X                    return 1;
X                }
X            }
X
X            if (Complex)
X            {
#if spSEPARATED_COMPLEX_VECTORS
X                Reads = sscanf( sInput,"%lf%lf", &RHS[I], &iRHS[I] );
#else
X                Reads = sscanf( sInput, "%lf%lf", &cRHS[I].Real,
X                                                  &cRHS[I].Imag );
#endif
X                if (Reads != 2)
X                {   fprintf(stderr,
X                            "%s: syntax error in file `%s' at line %d.\n",
X                            ProgramName, FileName, LineNumber);
X                    return 1;
X                }
X            }
X            else /* Not complex. */
X            {   Reads = sscanf( sInput, "%lf", &RHS[I] );
X                if (Reads != 1)
X                {   fprintf(stderr,
X                            "%s: syntax error in file `%s' at line %d.\n",
X                            ProgramName, FileName, LineNumber);
X                    return 1;
X                }
X            }
X        }
X
X        if (RealAsComplex AND NOT Complex)
X        {
#if spSEPARATED_COMPLEX_VECTORS
X            for (I = 1; I <= Size; I++) iRHS[I] = 0.0;
#else
X            for (I = Size; I > 0; I--)
X            {   cRHS[I].Real = RHS[I];
X                cRHS[I].Imag = 0.0;
X            }
#endif
X        }
X    }
X
/* Print out the size and the type of the matrix. */
X    if (NOT SolutionOnly)
X    {   IntSize = spGetSize( Matrix, NO );
X        printf("Matrix is %d x %d ", IntSize, IntSize);
X        if (IntSize != Size)
X            printf("(external size is %d x %d) ", Size, Size);
X        if (Complex OR RealAsComplex)
X            printf("and complex.\n");
X        else
X            printf("and real.\n");
X    }
X
X
X    if (Complex OR RealAsComplex)
X        spSetComplex( Matrix );
X    else
X        spSetReal( Matrix );
X
X    (void)fclose(pMatrixFile);
X    return 0;
}
X
X
X
X
X
X
X
X
X
X
/*
X *   INITIALIZE MATRIX ELEMENT
X *
X *   This function copys the InitInfo to the Real and Imag matrix element
X *   values.
X *
X *   >>> Returned:
X *   A zero is returns, signifying that no error can be made.
X */
X
/*ARGSUSED*/
X
static int
Init( RealNumber *pElement, char *pInitInfo, int Row, int Col )
{
/* Begin `Init'. */
X    *pElement = *(RealNumber *)pInitInfo;
X    if (Complex OR RealAsComplex)
X        *(pElement+1) = *((RealNumber *)pInitInfo+1);
X    return 0;
}
X
X
X
X
X
X
X
X
/*
X *  COMPLEX ARRAY ALLOCATION
X *
X *  These routines are used to check out and in arrays of complex numbers.
X */
X
static struct Bin {
X    ComplexVector   Array;
X    struct Bin     *Next;
}  *FirstArray, *CurrentArray = NULL;
X
X
static ComplexVector
CheckOutComplexArray( int Count )
{
struct Bin Bin, *pBin;
ComplexVector Temp;
X
/* Begin `CheckOutComplexArray'. */
X
X    if (CurrentArray == NULL OR CurrentArray->Next == NULL)
X    {   pBin = ALLOC( struct Bin, 1);
X        Temp = ALLOC( ComplexNumber, Count );
X        if (pBin == NULL OR Temp == NULL)
X        {   fprintf( stderr, "%s: insufficient memory available.\n",
X                             ProgramName);
X            exit(1);
X        }
X        Bin.Array = Temp;
X        Bin.Next = NULL;
X        *pBin = Bin;
X        if (CurrentArray == NULL)
X            FirstArray = CurrentArray = pBin;
X        else
X        {   CurrentArray->Next = pBin;
X            CurrentArray = pBin;
X        }
X    }
X    else
X    {   pBin = CurrentArray;
X        CurrentArray = pBin->Next;
X    }
X
X    return pBin->Array;
}
X
X
static void
CheckInAllComplexArrays()
{
X
/* Begin `CheckInAllComplexArrays'. */
X    if (CurrentArray != NULL)
X        CurrentArray = FirstArray;
X    return;
}
X
X
X
X
X
/*
X *  INTERPRET THE COMMAND LINE ARGUMENTS
X */
X
static int
InterpretCommandLine( int ArgCount, char *Args[] )
{
int I, FileCount = 0;
char *GetProgramName();
X
/* Begin `InterpretCommandLine'. */
X
/* Determine the name of the program. */
X    ProgramName = GetProgramName(Args[0]);
X
/* Step through the argument list, interpreting and deleting the options. */
X    for (I = 1; I < ArgCount; I++)
X    {   if (!strcmp(Args[I], "-a"))
X        {   if (ArgCount == I OR (sscanf(Args[I+1],"%lf", &AbsThreshold) != 1))
X            {   AbsThreshold = 0.0;
X                Usage(Args[I]);
X            }
X            else I++;
X        }
X        else if (!strcmp(Args[I], "-r"))
X        {   if (ArgCount == I OR (sscanf(Args[I+1],"%lf", &RelThreshold) != 1))
X            {   RelThreshold = 0.0;
X                Usage(Args[I]);
X            }
X            else I++;
X        }
X        else if (!strcmp(Args[I], "-x"))
X        {
#if spCOMPLEX
X            RealAsComplex = YES;
#else
X            fprintf(stderr,
X                    "%s: Sparse is not configured to solve complex matrices.\n",
X                    ProgramName);
X            fprintf(stderr,"    Enable spCOMPLEX in `spConfig.h'.\n");
#endif
X        }
X        else if (!strcmp(Args[I], "-s"))
X            SolutionOnly = YES;
X        else if (!strcmp(Args[I], "-c"))
X            DiagPivoting = NO;
X        else if (!strcmp(Args[I], "-t"))
X        {
#if TRANSPOSE
X            Transposed = YES;
#else
X            fprintf(stderr,
X                   "%s: Sparse is not configured to solve transposed system.\n",
X                    ProgramName);
X            fprintf(stderr,"    Enable TRANSPOSE in `spConfig.h'.\n");
#endif
X        }
X        else if (!strcmp(Args[I], "-n"))
X        {   if (ArgCount == I OR (sscanf(Args[I+1],"%d", &PrintLimit) != 1))
X            {   PrintLimit = PRINT_LIMIT;
X                Usage(Args[I]);
X            }
X            else
X            {   PrintLimitSet = YES;
X                I++;
X            }
X        }
X        else if (!strcmp(Args[I], "-i"))
X        {   if (ArgCount == I OR (sscanf(Args[I+1],"%d", &Iterations) != 1))
X            {   Iterations = 1;
X                Usage(Args[I]);
X            }
X            else I++;
X        }
X        else if (!strcmp(Args[I], "-b"))
X        {   if (ArgCount == I OR (sscanf(Args[I+1],"%d", &ColumnAsRHS) != 1))
X            {   ColumnAsRHS = 1;
X                UseColumnAsRHS = YES;
X            }
X            else
X            {   UseColumnAsRHS = YES;
X                ColumnAsRHS = MAX( ColumnAsRHS, 1 );
X                I++;
X            }
X        }
X        else if (!strcmp(Args[I], "-p"))
X        {
#if DOCUMENTATION
X            CreatePlotFiles = YES;
#else
X            fprintf(stderr,
X                    "%s: Sparse is not configured to generate plot files.\n",
X                    ProgramName);
X            fprintf(stderr,"    Enable DOCUMENTATION in `spConfig.h'.\n");
#endif
X        }
X        else if (!strcmp(Args[I], "-u"))
X            Usage( (char *)NULL );
X        else if (Args[I][0] == '-')
X            Usage(Args[I]);
X        else Args[++FileCount] = Args[I];
X    }
X
X    return FileCount;
}
X
X
X
X
X
X
X
/*
X *  PROGRAM NAME
X *
X *  Removes path from argv[0] and returns program name.
X *  Assumes UNIX style path names.
X */
X
static char *
GetProgramName( char *Arg0 )
{
char *pTail;
/* Begin `GetProgramName'. */
X
#   ifdef vms
X        return "sparse";
#   else
X    {   pTail = Arg0 + strlen(Arg0)-1;
X        while (pTail != Arg0 AND *(pTail-1) != '/')
X            --pTail;
X        return pTail;
X    }
#   endif
}
X
X
X
X
X
/*
X *  USAGE WARNING
X *
X *  Sends a warning to the user when the command line syntax is wrong.
X */
X
static void
Usage( char *sBadOpt )
{
/* Begin `Usage'. */
X
X    if (sBadOpt != NULL)
X    {   fprintf(stderr, "%s: unknown or deformed option `%s'.\n",
X                ProgramName, sBadOpt);
X    }
X
X    fprintf(stderr, "\nUsage: %s [options] [file names]\n\n", ProgramName);
X    fprintf(stderr, "Options:\n");
X    fprintf(stderr,
X    "    -s      Print solution rather than run statistics.\n");
X    fprintf( stderr, "    -r x    Use x as relative threshold.\n");
X    fprintf( stderr, "    -a x    Use x as absolute threshold.\n");
X    fprintf( stderr, "    -n n    Print first n terms of solution vector.\n");
X    fprintf( stderr, "    -i n    Repeat build/factor/solve n times.\n");
X    fprintf( stderr, "    -b n    Use n'th column of matrix as b in Ax=b.\n");
#if DIAGONAL_PIVOTING
X    fprintf( stderr,
X    "    -c      Use complete (as opposed to diagonal) pivoting.\n");
#endif
#if DOCUMENTATION
X    fprintf( stderr,
X    "    -p      Create plot files `filename.bef' and `filename.aft'.\n");
#endif
#if spCOMPLEX
X    fprintf( stderr,
"    -x      Treat real matrix as complex with imaginary part zero.\n");
#endif
#if TRANSPOSE
X    fprintf( stderr, "    -t      Solve transposed system.\n");
#endif
X    fprintf( stderr, "    -u      Print usage message.\n");
X    exit(1);
}
X
X
X
X
X
X
/*
X *  ENLARGE VECTORS
X *
X *  Allocate or enlarge vectors.
X */
X
static void
EnlargeVectors( int NewSize, int Clear )
{
int I, PrevSize = MaxSize;
RealVector OldRHS = RHS, iOldRHS = iRHS;
ComplexVector cOldRHS = cRHS;
#if spCOMPLEX
#   define SCALE 2
#else
#   define SCALE 1
#endif
X
/* Begin `EnlargeVectors'. */
X    if (NewSize > PrevSize)
X    {   if (MaxSize != 0)
X        {   free( (char *)Solution );
X            free( (char *)RHS_Verif );
X        }
X        RHS = ALLOC( RealNumber, SCALE*(NewSize+1) );
X        Solution = ALLOC( RealNumber, SCALE*(NewSize+1) );
X        RHS_Verif = ALLOC( RealNumber, SCALE*(NewSize+1) );
X        if (NOT RHS OR NOT Solution OR NOT RHS_Verif)
X        {   fprintf(stderr, "%s: insufficient memory available.\n",
X                            ProgramName);
X            exit(1);
X        }
X        cRHS = (ComplexVector)RHS;
X        cSolution = (ComplexVector)Solution;
X        cRHS_Verif = (ComplexVector)RHS_Verif;
X        iRHS = RHS + NewSize + 1;
X        iSolution = Solution + NewSize + 1;
X        iRHS_Verif = RHS_Verif + NewSize + 1;
X
/* Copy data from old RHS to new RHS. */
X        if (NOT Clear)
X        {
/* Copy old RHS vector to new. */
X            if (Complex OR RealAsComplex)
X            {   for (I = PrevSize; I > 0; I--)
X                {
#if spSEPARATED_COMPLEX_VECTORS OR LINT
X                    RHS[I] = OldRHS[I];
X                    iRHS[I] = iOldRHS[I];
#endif
#if (NOT spSEPARATED_COMPLEX_VECTORS) OR LINT
X                    cRHS[I] = cOldRHS[I];
#endif
X                }
X            }
X            else
X            {   for (I = PrevSize; I > 0; I--)
X                    RHS[I] = OldRHS[I];
X            }
X        }
X        if (MaxSize != 0) free( (char *)OldRHS );
X        MaxSize = NewSize;
X    }
X
/* Either completely clear or clear remaining portion of RHS vector. */
X    if ((NewSize > PrevSize) OR Clear)
X    {   if (Clear)
X        {   NewSize = MAX( NewSize, PrevSize );
X            PrevSize = 0;
X        }
X
X        if (Complex OR RealAsComplex)
X        {   for (I = NewSize; I > PrevSize; I--)
X            {
#if spSEPARATED_COMPLEX_VECTORS OR LINT
X                RHS[I] = 0.0;
X                iRHS[I] = 0.0;
#endif
#if NOT spSEPARATED_COMPLEX_VECTORS OR LINT
X                cRHS[I].Real = 0.0;
X                cRHS[I].Imag = 0.0;
#endif
X            }
X        }
X        else
X        {   for (I = NewSize; I > PrevSize; I--)
X                RHS[I] = 0.0;
X        }
X    }
X
X    return;
}
X
SHAR_EOF
  (set 20 16 10 12 10 44 44 'sparse/spTest.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spTest.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spTest.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spTest.c: MD5 check failed'
       ) << \SHAR_EOF
2daa948475f9e5da22b3953a8c6ce606  sparse/spTest.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spTest.c'` -ne 38455 && \
  ${echo} 'restoration warning:  size of sparse/spTest.c is not 38455'
  fi
fi
# ============= sparse/spUtils.c ==============
if test -f 'sparse/spUtils.c' && test "$first_param" != -c; then
  ${echo} 'x -SKIPPING sparse/spUtils.c (file already exists)'
else
${echo} 'x - extracting sparse/spUtils.c (text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sparse/spUtils.c' &&
/*
X *  MATRIX UTILITY MODULE
X *
X *  Author:                     Advising professor:
X *      Kenneth S. Kundert          Alberto Sangiovanni-Vincentelli
X *      UC Berkeley
X */
/*! \file
X *  This file contains various optional utility routines.
X *
X *  Objects that begin with the \a spc prefix are considered private
X *  and should not be used.
X *
X *  \author
X *  Kenneth S. Kundert <kundert@users.sourceforge.net>
X */
/*  >>> User accessible functions contained in this file:
X *  spMNA_Preorder
X *  spScale
X *  spMultiply
X *  spMultTransposed
X *  spDeterminant
X *  spStrip
X *  spDeleteRowAndCol
X *  spPseudoCondition
X *  spCondition
X *  spNorm
X *  spLargestElement
X *  spRoundoff
X *  spErrorMessage
X *
X *  >>> Other functions contained in this file:
X *  CountTwins
X *  SwapCols
X *  ScaleComplexMatrix
X *  ComplexMatrixMultiply
X *  ComplexCondition
X */
X
X
/*
X *  Revision and copyright information.
X *
X *  Copyright (c) 1985-2003 by Kenneth S. Kundert
X */
X
#ifndef lint
static char copyright[] =
X    "Sparse1.4: Copyright (c) 1985-2003 by Kenneth S. Kundert";
static char RCSid[] =
X    "@(#)$Header: /cvsroot/sparse/src/spUtils.c,v 1.4 2003/06/30 19:40:52 kundert Exp $";
#endif
X
X
X
/*
X *  IMPORTS
X *
X *  >>> Import descriptions:
X *  spConfig.h
X *      Macros that customize the sparse matrix routines.
X *  spMatrix.h
X *      Macros and declarations to be imported by the user.
X *  spDefs.h
X *      Matrix type and macro definitions for the sparse matrix routines.
X */
X
#define spINSIDE_SPARSE
#include <stdio.h>
#include "spConfig.h"
#include "spMatrix.h"
#include "spDefs.h"
X
X
X
X
X
/*
X *  Function declarations
X */
X
static int CountTwins( MatrixPtr, int, ElementPtr*, ElementPtr* );
static void SwapCols( MatrixPtr, ElementPtr, ElementPtr );
static void ScaleComplexMatrix( MatrixPtr, RealVector, RealVector );
#if spSEPARATED_COMPLEX_VECTORS
static void ComplexMatrixMultiply( MatrixPtr,
X			RealVector, RealVector, RealVector, RealVector );
static void ComplexTransposedMatrixMultiply( MatrixPtr,
X			RealVector, RealVector, RealVector, RealVector );
#else
static void ComplexMatrixMultiply( MatrixPtr,
X			RealVector, RealVector );
static void ComplexTransposedMatrixMultiply( MatrixPtr,
X			RealVector, RealVector );
#endif
static RealNumber ComplexCondition( MatrixPtr, RealNumber, int* );
X
X
X
X
X
X
#if MODIFIED_NODAL
/*!
X *  This routine massages modified node admittance matrices to remove
X *  zeros from the diagonal.  It takes advantage of the fact that the
X *  row and column associated with a zero diagonal usually have
X *  structural ones placed symmetricly.  This routine should be used
X *  only on modified node admittance matrices and should be executed
X *  after the matrix has been built but before the factorization
X *  begins.  It should be executed for the initial factorization only
X *  and should be executed before the rows have been linked.  Thus it
X *  should be run before using spScale(), spMultiply(),
X *  spDeleteRowAndCol(), or spNorm().
X *
X *  This routine exploits the fact that the structural ones are placed
X *  in the matrix in symmetric twins.  For example, the stamps for
X *  grounded and a floating voltage sources are \code
X *  grounded:              floating:
X *  [  x   x   1 ]         [  x   x   1 ]
X *  [  x   x     ]         [  x   x  -1 ]
X *  [  1         ]         [  1  -1     ]
X *  \endcode
X *  Notice for the grounded source, there is one set of twins, and for
X *  the floating, there are two sets.  We remove the zero from the diagonal
X *  by swapping the rows associated with a set of twins.  For example: \code
X *  grounded:              floating 1:            floating 2:
X *  [  1         ]         [  1  -1     ]         [  x   x   1 ]
X *  [  x   x     ]         [  x   x  -1 ]         [  1  -1     ]
X *  [  x   x   1 ]         [  x   x   1 ]         [  x   x  -1 ]
X *  \endcode
X *
X *  It is important to deal with any zero diagonals that only have one
X *  set of twins before dealing with those that have more than one because
X *  swapping row destroys the symmetry of any twins in the rows being
X *  swapped, which may limit future moves.  Consider \code
X *  [  x   x   1     ]
X *  [  x   x  -1   1 ]
X *  [  1  -1         ]
X *  [      1         ]
X *  \endcode
X *  There is one set of twins for diagonal 4 and two for diagonal 3.
X *  Dealing with diagonal 4 first requires swapping rows 2 and 4. \code
X *  [  x   x   1     ]
X *  [      1         ]
X *  [  1  -1         ]
X *  [  x   x  -1   1 ]
X *  \endcode
X *  We can now deal with diagonal 3 by swapping rows 1 and 3. \code
X *  [  1  -1         ]
X *  [      1         ]
X *  [  x   x   1     ]
X *  [  x   x  -1   1 ]
X *  \endcode
X *  And we are done, there are no zeros left on the diagonal.  However, if
X *  we originally dealt with diagonal 3 first, we could swap rows 2 and 3 \code
X *  [  x   x   1     ]
X *  [  1  -1         ]
X *  [  x   x  -1   1 ]
X *  [      1         ]
X *  \endcode
X *  Diagonal 4 no longer has a symmetric twin and we cannot continue.
X *
X *  So we always take care of lone twins first.  When none remain, we
X *  choose arbitrarily a set of twins for a diagonal with more than one set
X *  and swap the rows corresponding to that twin.  We then deal with any
X *  lone twins that were created and repeat the procedure until no
X *  zero diagonals with symmetric twins remain.
X *
X *  In this particular implementation, columns are swapped rather than rows.
X *  The algorithm used in this function was developed by Ken Kundert and
X *  Tom Quarles.
X *
X *  \param *  eMatrix 
X *      Pointer to the matrix to be preordered.
X */
/*  >>> Local variables;
X *  J  (int)
X *      Column with zero diagonal being currently considered.
X *  pTwin1  (ElementPtr)
X *      Pointer to the twin found in the column belonging to the zero diagonal.
X *  pTwin2  (ElementPtr)
X *      Pointer to the twin found in the row belonging to the zero diagonal.
X *      belonging to the zero diagonal.
X *  AnotherPassNeeded  (BOOLEAN)
X *      Flag indicating that at least one zero diagonal with symmetric twins
X *      remain.
X *  StartAt  (int)
X *      Column number of first zero diagonal with symmetric twins.
X *  Swapped  (BOOLEAN)
X *      Flag indicating that columns were swapped on this pass.
X *  Twins  (int)
X *      Number of symmetric twins corresponding to current zero diagonal.
X */
X
void
spMNA_Preorder( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  int  J, Size;
ElementPtr  pTwin1, pTwin2;
int  Twins, StartAt = 1;
BOOLEAN  Swapped, AnotherPassNeeded;
X
/* Begin `spMNA_Preorder'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X
X    if (Matrix->RowsLinked) return;
X    Size = Matrix->Size;
X    Matrix->Reordered = YES;
X
X    do
X    {   AnotherPassNeeded = Swapped = NO;
X
/* Search for zero diagonals with lone twins. */
X        for (J = StartAt; J <= Size; J++)
X        {   if (Matrix->Diag[J] == NULL)
X            {   Twins = CountTwins( Matrix, J, &pTwin1, &pTwin2 );
X                if (Twins == 1)
X                {   /* Lone twins found, swap rows. */
X                    SwapCols( Matrix, pTwin1, pTwin2 );
X                    Swapped = YES;
X                }
X                else if ((Twins > 1) AND NOT AnotherPassNeeded)
X                {   AnotherPassNeeded = YES;
X                    StartAt = J;
X                }
X            }
X        }
X
/* All lone twins are gone, look for zero diagonals with multiple twins. */
X        if (AnotherPassNeeded)
X        {   for (J = StartAt; NOT Swapped AND (J <= Size); J++)
X            {   if (Matrix->Diag[J] == NULL)
X                {   Twins = CountTwins( Matrix, J, &pTwin1, &pTwin2 );
X                    SwapCols( Matrix, pTwin1, pTwin2 );
X                    Swapped = YES;
X                }
X            }
X        }
X    } while (AnotherPassNeeded);
X    return;
}
X
X
X
X
/*
X *  COUNT TWINS
X *
X *  This function counts the number of symmetric twins associated with
X *  a zero diagonal and returns one set of twins if any exist.  The
X *  count is terminated early at two.
X */
X
static int
CountTwins(
X    MatrixPtr Matrix,
X    int Col,
X    ElementPtr *ppTwin1,
X    ElementPtr *ppTwin2
)
{
int Row, Twins = 0;
ElementPtr pTwin1, pTwin2;
X
/* Begin `CountTwins'. */
X
X    pTwin1 = Matrix->FirstInCol[Col];
X    while (pTwin1 != NULL)
X    {   if (ABS(pTwin1->Real) == 1.0)
X        {   Row = pTwin1->Row;
X            pTwin2 = Matrix->FirstInCol[Row];
X            while ((pTwin2 != NULL) AND (pTwin2->Row != Col))
X                pTwin2 = pTwin2->NextInCol;
X            if ((pTwin2 != NULL) AND (ABS(pTwin2->Real) == 1.0))
X            {   /* Found symmetric twins. */
X                if (++Twins >= 2) return Twins;
X                (*ppTwin1 = pTwin1)->Col = Col;
X                (*ppTwin2 = pTwin2)->Col = Row;
X            }
X        }
X        pTwin1 = pTwin1->NextInCol;
X    }
X    return Twins;
}
X
X
X
X
/*
X *  SWAP COLUMNS
X *
X *  This function swaps two columns and is applicable before the rows are
X *  linked.
X */
X
static void
SwapCols(
X    MatrixPtr Matrix,
X    ElementPtr pTwin1,
X    ElementPtr pTwin2
)
{
int Col1 = pTwin1->Col, Col2 = pTwin2->Col;
X
/* Begin `SwapCols'. */
X
X    SWAP (ElementPtr, Matrix->FirstInCol[Col1], Matrix->FirstInCol[Col2]);
X    SWAP (int, Matrix->IntToExtColMap[Col1], Matrix->IntToExtColMap[Col2]);
#if TRANSLATE
X    Matrix->ExtToIntColMap[Matrix->IntToExtColMap[Col2]]=Col2;
X    Matrix->ExtToIntColMap[Matrix->IntToExtColMap[Col1]]=Col1;
#endif
X
X    Matrix->Diag[Col1] = pTwin2;
X    Matrix->Diag[Col2] = pTwin1;
X    Matrix->NumberOfInterchangesIsOdd = NOT Matrix->NumberOfInterchangesIsOdd;
X    return;
}
#endif /* MODIFIED_NODAL */
X
X
X
X
X
X
X
X
X
#if SCALING
/*!
X *  This function scales the matrix to enhance the possibility of
X *  finding a good pivoting order.  Note that scaling enhances accuracy
X *  of the solution only if it affects the pivoting order, so it makes
X *  no sense to scale the matrix before spFactor().  If scaling is
X *  desired it should be done before spOrderAndFactor().  There
X *  are several things to take into account when choosing the scale
X *  factors.  First, the scale factors are directly multiplied against
X *  the elements in the matrix.  To prevent roundoff, each scale factor
X *  should be equal to an integer power of the number base of the
X *  machine.  Since most machines operate in base two, scale factors
X *  should be a power of two.  Second, the matrix should be scaled such
X *  that the matrix of element uncertainties is equilibrated.  Third,
X *  this function multiplies the scale factors by the elements, so if
X *  one row tends to have uncertainties 1000 times smaller than the
X *  other rows, then its scale factor should be 1024, not 1/1024.
X *  Fourth, to save time, this function does not scale rows or columns
X *  if their scale factors are equal to one.  Thus, the scale factors
X *  should be normalized to the most common scale factor.  Rows and
X *  columns should be normalized separately.  For example, if the size
X *  of the matrix is 100 and 10 rows tend to have uncertainties near
X *  1e-6 and the remaining 90 have uncertainties near 1e-12, then the
X *  scale factor for the 10 should be 1/1,048,576 and the scale factors
X *  for the remaining 90 should be 1.  Fifth, since this routine
X *  directly operates on the matrix, it is necessary to apply the scale
X *  factors to the RHS and Solution vectors.  It may be easier to
X *  simply use spOrderAndFactor() on a scaled matrix to choose the
X *  pivoting order, and then throw away the matrix.  Subsequent
X *  factorizations, performed with spFactor(), will not need to have
X *  the RHS and Solution vectors descaled.  Lastly, this function
X *  should not be executed before the function spMNA_Preorder().
X *
X *  \param eMatrix
X *      Pointer to the matrix to be scaled.
X *  \param SolutionScaleFactors
X *      The array of Solution scale factors.  These factors scale the columns.
X *      All scale factors are real valued.
X *  \param RHS_ScaleFactors
X *      The array of RHS scale factors.  These factors scale the rows.
X *      All scale factors are real valued.
X */
/*  >>> Local variables:
X *  lSize  (int)
X *      Local version of the size of the matrix.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  pExtOrder  (int *)
X *      Pointer into either IntToExtRowMap or IntToExtColMap vector. Used to
X *      compensate for any row or column swaps that have been performed.
X *  ScaleFactor  (RealNumber)
X *      The scale factor being used on the current row or column.
X */
X
void
spScale(
X    spMatrix eMatrix,
X    spREAL RHS_ScaleFactors[],
X    spREAL SolutionScaleFactors[]
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register ElementPtr  pElement;
register int  I, lSize, *pExtOrder;
RealNumber  ScaleFactor;
void ScaleComplexMatrix();
X
/* Begin `spScale'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X    if (NOT Matrix->RowsLinked) spcLinkRows( Matrix );
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   ScaleComplexMatrix( Matrix, RHS_ScaleFactors, SolutionScaleFactors );
X        return;
X    }
#endif
X
#if REAL
X    lSize = Matrix->Size;
X
/* Correct pointers to arrays for ARRAY_OFFSET */
#if NOT ARRAY_OFFSET
X    --RHS_ScaleFactors;
X    --SolutionScaleFactors;
#endif
X
/* Scale Rows */
X    pExtOrder = &Matrix->IntToExtRowMap[1];
X    for (I = 1; I <= lSize; I++)
X    {   if ((ScaleFactor = RHS_ScaleFactors[*(pExtOrder++)]) != 1.0)
X        {   pElement = Matrix->FirstInRow[I];
X
X            while (pElement != NULL)
X            {   pElement->Real *= ScaleFactor;
X                pElement = pElement->NextInRow;
X            }
X        }
X    }
X
/* Scale Columns */
X    pExtOrder = &Matrix->IntToExtColMap[1];
X    for (I = 1; I <= lSize; I++)
X    {   if ((ScaleFactor = SolutionScaleFactors[*(pExtOrder++)]) != 1.0)
X        {   pElement = Matrix->FirstInCol[I];
X
X            while (pElement != NULL)
X            {   pElement->Real *= ScaleFactor;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X    return;
X
#endif /* REAL */
}
#endif /* SCALING */
X
X
X
X
X
X
X
X
X
#if spCOMPLEX AND SCALING
/*
X *  SCALE COMPLEX MATRIX
X *
X *  This function scales the matrix to enhance the possibility of
X *  finding a good pivoting order.  Note that scaling enhances accuracy
X *  of the solution only if it affects the pivoting order, so it makes
X *  no sense to scale the matrix before spFactor().  If scaling is
X *  desired it should be done before spOrderAndFactor().  There
X *  are several things to take into account when choosing the scale
X *  factors.  First, the scale factors are directly multiplied against
X *  the elements in the matrix.  To prevent roundoff, each scale factor
X *  should be equal to an integer power of the number base of the
X *  machine.  Since most machines operate in base two, scale factors
X *  should be a power of two.  Second, the matrix should be scaled such
X *  that the matrix of element uncertainties is equilibrated.  Third,
X *  this function multiplies the scale factors by the elements, so if
X *  one row tends to have uncertainties 1000 times smaller than the
X *  other rows, then its scale factor should be 1024, not 1/1024.
X *  Fourth, to save time, this function does not scale rows or columns
X *  if their scale factors are equal to one.  Thus, the scale factors
X *  should be normalized to the most common scale factor.  Rows and
X *  columns should be normalized separately.  For example, if the size
X *  of the matrix is 100 and 10 rows tend to have uncertainties near
X *  1e-6 and the remaining 90 have uncertainties near 1e-12, then the
X *  scale factor for the 10 should be 1/1,048,576 and the scale factors
X *  for the remaining 90 should be 1. Fifth, since this routine
X *  directly operates on the matrix, it is necessary to apply the scale
X *  factors to the RHS and Solution vectors.  It may be easier to
X *  simply use spOrderAndFactor() on a scaled matrix to choose the
X *  pivoting order, and then throw away the matrix.  Subsequent
X *  factorizations, performed with spFactor(), will not need to have
X *  the RHS and Solution vectors descaled.  Lastly, this function
X *  should not be executed before the function spMNA_Preorder.
X *
X *  >>> Arguments:
X *  Matrix  <input> (char *)
X *      Pointer to the matrix to be scaled.
X *  SolutionScaleFactors  <input>  (RealVector)
X *      The array of Solution scale factors.  These factors scale the columns.
X *      All scale factors are real valued.
X *  RHS_ScaleFactors  <input>  (RealVector)
X *      The array of RHS scale factors.  These factors scale the rows.
X *      All scale factors are real valued.
X *
X *  >>> Local variables:
X *  lSize  (int)
X *      Local version of the size of the matrix.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.
X *  pExtOrder  (int *)
X *      Pointer into either IntToExtRowMap or IntToExtColMap vector. Used to
X *      compensate for any row or column swaps that have been performed.
X *  ScaleFactor  (RealNumber)
X *      The scale factor being used on the current row or column.
X */
X
static void
ScaleComplexMatrix(
X    MatrixPtr Matrix,
X    register RealVector RHS_ScaleFactors,
X    register RealVector SolutionScaleFactors
)
{
register ElementPtr  pElement;
register int  I, lSize, *pExtOrder;
RealNumber  ScaleFactor;
X
/* Begin `ScaleComplexMatrix'. */
X    lSize = Matrix->Size;
X
/* Correct pointers to arrays for ARRAY_OFFSET */
#if NOT ARRAY_OFFSET
X    --RHS_ScaleFactors;
X    --SolutionScaleFactors;
#endif
X
/* Scale Rows */
X    pExtOrder = &Matrix->IntToExtRowMap[1];
X    for (I = 1; I <= lSize; I++)
X    {   if ((ScaleFactor = RHS_ScaleFactors[*(pExtOrder++)]) != 1.0)
X        {   pElement = Matrix->FirstInRow[I];
X
X            while (pElement != NULL)
X            {   pElement->Real *= ScaleFactor;
X                pElement->Imag *= ScaleFactor;
X                pElement = pElement->NextInRow;
X            }
X        }
X    }
X
/* Scale Columns */
X    pExtOrder = &Matrix->IntToExtColMap[1];
X    for (I = 1; I <= lSize; I++)
X    {   if ((ScaleFactor = SolutionScaleFactors[*(pExtOrder++)]) != 1.0)
X        {   pElement = Matrix->FirstInCol[I];
X
X            while (pElement != NULL)
X            {   pElement->Real *= ScaleFactor;
X                pElement->Imag *= ScaleFactor;
X                pElement = pElement->NextInCol;
X            }
X        }
X    }
X    return;
}
#endif /* SCALING AND spCOMPLEX */
X
X
X
X
X
X
X
X
#if MULTIPLICATION
/*!
X *  Multiplies matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be used
X *  as a test to see if solutions are correct.  It should not be used
X *  before spMNA_Preorder().
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X *  \param RHS
X *      RHS is the right hand side. This is what is being solved for.
X *  \param Solution
X *      Solution is the vector being multiplied by the matrix.
X *  \param iRHS
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and \a spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iSolution
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and \a spSEPARATED_COMPLEX_VECTORS is true.
X */
X
void
spMultiply(
X    spMatrix eMatrix,
X    spREAL RHS[],
X    spREAL Solution[]
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X    , spREAL iRHS[]
X    , spREAL iSolution[]
#endif
)
{
register  ElementPtr  pElement;
register  RealVector  Vector;
register  RealNumber  Sum;
register  int  I, *pExtOrder;
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
extern void ComplexMatrixMultiply();
X
/* Begin `spMultiply'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X    if (NOT Matrix->RowsLinked)
X	spcLinkRows(Matrix);
X    if (NOT Matrix->InternalVectorsAllocated)
X	spcCreateInternalVectors( Matrix );
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   ComplexMatrixMultiply( Matrix, RHS, Solution IMAG_VECTORS );
X        return;
X    }
#endif
X
#if REAL
#if NOT ARRAY_OFFSET
/* Correct array pointers for ARRAY_OFFSET. */
X    --RHS;
X    --Solution;
#endif
X
/* Initialize Intermediate vector with reordered Solution vector. */
X    Vector = Matrix->Intermediate;
X    pExtOrder = &Matrix->IntToExtColMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X        Vector[I] = Solution[*(pExtOrder--)];
X
X    pExtOrder = &Matrix->IntToExtRowMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X    {   pElement = Matrix->FirstInRow[I];
X        Sum = 0.0;
X
X        while (pElement != NULL)
X        {   Sum += pElement->Real * Vector[pElement->Col];
X            pElement = pElement->NextInRow;
X        }
X        RHS[*pExtOrder--] = Sum;
X    }
X    return;
#endif /* REAL */
}
#endif /* MULTIPLICATION */
X
X
X
X
X
X
X
#if spCOMPLEX AND MULTIPLICATION
/*
X *  COMPLEX MATRIX MULTIPLICATION
X *
X *  Multiplies matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be  used
X *  as a test to see if solutions are correct.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (char *)
X *      Pointer to the matrix.
X *  RHS  <output>  (RealVector)
X *      RHS is the right hand side. This is what is being solved for.
X *      This is only the real portion of the right-hand side if the matrix
X *      is complex and spSEPARATED_COMPLEX_VECTORS is set true.
X *  Solution  <input>  (RealVector)
X *      Solution is the vector being multiplied by the matrix. This is only
X *      the real portion if the matrix is complex and
X *      spSEPARATED_COMPLEX_VECTORS is set true.
X *  iRHS  <output>  (RealVector)
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X *  iSolution  <input>  (RealVector)
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X */
X
static void
ComplexMatrixMultiply(
X    MatrixPtr  Matrix,
X    RealVector RHS,
X    RealVector Solution
#if spSEPARATED_COMPLEX_VECTORS
X    , RealVector iRHS
X    , RealVector iSolution
#endif
)
{
register  ElementPtr  pElement;
register  ComplexVector  Vector;
ComplexNumber  Sum;
register  int  I, *pExtOrder;
X
/* Begin `ComplexMatrixMultiply'. */
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spSEPARATED_COMPLEX_VECTORS
X    --RHS;              --iRHS;
X    --Solution;         --iSolution;
#else
X    RHS -= 2;           Solution -= 2;
#endif
#endif
X
/* Initialize Intermediate vector with reordered Solution vector. */
X    Vector = (ComplexVector)Matrix->Intermediate;
X    pExtOrder = &Matrix->IntToExtColMap[Matrix->Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Matrix->Size; I > 0; I--)
X    {   Vector[I].Real = Solution[*pExtOrder];
X        Vector[I].Imag = iSolution[*(pExtOrder--)];
X    }
#else
X    for (I = Matrix->Size; I > 0; I--)
X        Vector[I] = ((ComplexVector)Solution)[*(pExtOrder--)];
#endif
X
X    pExtOrder = &Matrix->IntToExtRowMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X    {   pElement = Matrix->FirstInRow[I];
X        Sum.Real = Sum.Imag = 0.0;
X
X        while (pElement != NULL)
X        {   /* Cmplx expression : Sum += Element * Vector[Col] */
X            CMPLX_MULT_ADD_ASSIGN( Sum, *pElement, Vector[pElement->Col] );
X            pElement = pElement->NextInRow;
X        }
X
#if spSEPARATED_COMPLEX_VECTORS
X        RHS[*pExtOrder] = Sum.Real;
X        iRHS[*pExtOrder--] = Sum.Imag;
#else
X        ((ComplexVector)RHS)[*pExtOrder--] = Sum;
#endif
X    }
X    return;
}
#endif /* spCOMPLEX AND MULTIPLICATION */
X
X
X
X
X
X
X
X
#if MULTIPLICATION AND TRANSPOSE
/*!
X *  Multiplies transposed matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be used
X *  as a test to see if solutions are correct.  It should not be used
X *  before spMNA_Preorder().
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X *  \param RHS
X *      RHS is the right hand side. This is what is being solved for.
X *  \param Solution
X *      Solution is the vector being multiplied by the matrix.
X *  \param iRHS
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and \a spSEPARATED_COMPLEX_VECTORS is true.
X *  \param iSolution
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and \a spSEPARATED_COMPLEX_VECTORS is true.
X */
X
void
spMultTransposed(
X    spMatrix eMatrix,
X    spREAL RHS[],
X    spREAL Solution[]
#if spCOMPLEX AND spSEPARATED_COMPLEX_VECTORS
X    , spREAL iRHS[]
X    , spREAL iSolution[]
#endif
)
{
register  ElementPtr  pElement;
register  RealVector  Vector;
register  RealNumber  Sum;
register  int  I, *pExtOrder;
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
extern void ComplexTransposedMatrixMultiply();
X
/* Begin `spMultTransposed'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X    if (NOT Matrix->InternalVectorsAllocated)
X	spcCreateInternalVectors( Matrix );
X
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   ComplexTransposedMatrixMultiply( Matrix, RHS, Solution IMAG_VECTORS );
X        return;
X    }
#endif
X
#if REAL
#if NOT ARRAY_OFFSET
/* Correct array pointers for ARRAY_OFFSET. */
X    --RHS;
X    --Solution;
#endif
X
/* Initialize Intermediate vector with reordered Solution vector. */
X    Vector = Matrix->Intermediate;
X    pExtOrder = &Matrix->IntToExtRowMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X        Vector[I] = Solution[*(pExtOrder--)];
X
X    pExtOrder = &Matrix->IntToExtColMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X    {   pElement = Matrix->FirstInCol[I];
X        Sum = 0.0;
X
X        while (pElement != NULL)
X        {   Sum += pElement->Real * Vector[pElement->Row];
X            pElement = pElement->NextInCol;
X        }
X        RHS[*pExtOrder--] = Sum;
X    }
X    return;
#endif /* REAL */
}
#endif /* MULTIPLICATION AND TRANSPOSE */
X
X
X
X
X
X
X
#if spCOMPLEX AND MULTIPLICATION AND TRANSPOSE
/*
X *  COMPLEX TRANSPOSED MATRIX MULTIPLICATION
X *
X *  Multiplies transposed matrix by solution vector to find source vector.
X *  Assumes matrix has not been factored.  This routine can be  used
X *  as a test to see if solutions are correct.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (char *)
X *      Pointer to the matrix.
X *  RHS  <output>  (RealVector)
X *      RHS is the right hand side. This is what is being solved for.
X *      This is only the real portion of the right-hand side if the matrix
X *      is complex and spSEPARATED_COMPLEX_VECTORS is set true.
X *  Solution  <input>  (RealVector)
X *      Solution is the vector being multiplied by the matrix. This is only
X *      the real portion if the matrix is complex and
X *      spSEPARATED_COMPLEX_VECTORS is set true.
X *  iRHS  <output>  (RealVector)
X *      iRHS is the imaginary portion of the right hand side. This is
X *      what is being solved for.  This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X *  iSolution  <input>  (RealVector)
X *      iSolution is the imaginary portion of the vector being multiplied
X *      by the matrix. This is only necessary if the matrix is
X *      complex and spSEPARATED_COMPLEX_VECTORS is true.
X *
X *  >>> Obscure Macros
X *  IMAG_VECTORS
X *      Replaces itself with `, iRHS, iSolution' if the options spCOMPLEX and
X *      spSEPARATED_COMPLEX_VECTORS are set, otherwise it disappears
X *      without a trace.
X */
X
static void
ComplexTransposedMatrixMultiply(
X    MatrixPtr  Matrix,
X    RealVector RHS,
X    RealVector Solution
#if spSEPARATED_COMPLEX_VECTORS
X    , RealVector iRHS
X    , RealVector iSolution
#endif
)
{
register  ElementPtr  pElement;
register  ComplexVector  Vector;
ComplexNumber  Sum;
register  int  I, *pExtOrder;
X
/* Begin `ComplexTransposedMatrixMultiply'. */
X
/* Correct array pointers for ARRAY_OFFSET. */
#if NOT ARRAY_OFFSET
#if spSEPARATED_COMPLEX_VECTORS
X    --RHS;              --iRHS;
X    --Solution;         --iSolution;
#else
X    RHS -= 2;           Solution -= 2;
#endif
#endif
X
/* Initialize Intermediate vector with reordered Solution vector. */
X    Vector = (ComplexVector)Matrix->Intermediate;
X    pExtOrder = &Matrix->IntToExtRowMap[Matrix->Size];
X
#if spSEPARATED_COMPLEX_VECTORS
X    for (I = Matrix->Size; I > 0; I--)
X    {   Vector[I].Real = Solution[*pExtOrder];
X        Vector[I].Imag = iSolution[*(pExtOrder--)];
X    }
#else
X    for (I = Matrix->Size; I > 0; I--)
X        Vector[I] = ((ComplexVector)Solution)[*(pExtOrder--)];
#endif
X
X    pExtOrder = &Matrix->IntToExtColMap[Matrix->Size];
X    for (I = Matrix->Size; I > 0; I--)
X    {   pElement = Matrix->FirstInCol[I];
X        Sum.Real = Sum.Imag = 0.0;
X
X        while (pElement != NULL)
X        {   /* Cmplx expression : Sum += Element * Vector[Row] */
X            CMPLX_MULT_ADD_ASSIGN( Sum, *pElement, Vector[pElement->Row] );
X            pElement = pElement->NextInCol;
X        }
X
#if spSEPARATED_COMPLEX_VECTORS
X        RHS[*pExtOrder] = Sum.Real;
X        iRHS[*pExtOrder--] = Sum.Imag;
#else
X        ((ComplexVector)RHS)[*pExtOrder--] = Sum;
#endif
X    }
X    return;
}
#endif /* spCOMPLEX AND MULTIPLICATION AND TRANSPOSE */
X
X
X
X
X
X
X
X
#if DETERMINANT
/*!
X *  This routine in capable of calculating the determinant of the
X *  matrix once the LU factorization has been performed.  Hence, only
X *  use this routine after spFactor() and before spClear().
X *  The determinant equals the product of all the diagonal elements of
X *  the lower triangular matrix L, except that this product may need
X *  negating.  Whether the product or the negative product equals the
X *  determinant is determined by the number of row and column
X *  interchanges performed.  Note that the determinants of matrices can
X *  be very large or very small.  On large matrices, the determinant
X *  can be far larger or smaller than can be represented by a floating
X *  point number.  For this reason the determinant is scaled to a
X *  reasonable value and the logarithm of the scale factor is returned.
X *
X *  \param eMatrix
X *      A pointer to the matrix for which the determinant is desired.
X *  \param pExponent
X *      The logarithm base 10 of the scale factor for the determinant.  To find
X *      the actual determinant, Exponent should be added to the exponent of
X *      Determinant.
X *  \param pDeterminant
X *      The real portion of the determinant.   This number is scaled to be
X *      greater than or equal to 1.0 and less than 10.0.
X *  \param piDeterminant
X *      The imaginary portion of the determinant.  When the matrix is real
X *      this pointer need not be supplied, nothing will be returned.   This
X *      number is scaled to be greater than or equal to 1.0 and less than 10.0.
X */
/*  >>> Local variables:
X *  Norm  (RealNumber)
X *      L-infinity norm of a complex number.
X *  Size  (int)
X *      Local storage for Matrix->Size.  Placed in a register for speed.
X *  Temp  (RealNumber)
X *      Temporary storage for real portion of determinant.
X */
X
void
spDeterminant(
X    spMatrix eMatrix,
X    int *pExponent,
X    spREAL *pDeterminant
#if spCOMPLEX
X    , spREAL *piDeterminant
#endif
)
{
register MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register int I, Size;
RealNumber Norm, nr, ni;
ComplexNumber Pivot, cDeterminant;
X
#define  NORM(a)     (nr = ABS((a).Real), ni = ABS((a).Imag), MAX (nr,ni))
X
/* Begin `spDeterminant'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X    *pExponent = 0;
X
X    if (Matrix->Error == spSINGULAR)
X    {   *pDeterminant = 0.0;
#if spCOMPLEX
X        if (Matrix->Complex) *piDeterminant = 0.0;
#endif
X        return;
X    }
X
X    Size = Matrix->Size;
X    I = 0;
X
#if spCOMPLEX
X    if (Matrix->Complex)        /* Complex Case. */
X    {   cDeterminant.Real = 1.0;
X        cDeterminant.Imag = 0.0;
X
X        while (++I <= Size)
X        {   CMPLX_RECIPROCAL( Pivot, *Matrix->Diag[I] );
X            CMPLX_MULT_ASSIGN( cDeterminant, Pivot );
X
/* Scale Determinant. */
X            Norm = NORM( cDeterminant );
X            if (Norm != 0.0)
X            {   while (Norm >= 1.0e12)
X                {   cDeterminant.Real *= 1.0e-12;
X                    cDeterminant.Imag *= 1.0e-12;
X                    *pExponent += 12;
X                    Norm = NORM( cDeterminant );
X                }
X                while (Norm < 1.0e-12)
X                {   cDeterminant.Real *= 1.0e12;
X                    cDeterminant.Imag *= 1.0e12;
X                    *pExponent -= 12;
X                    Norm = NORM( cDeterminant );
X                }
X            }
X        }
X
/* Scale Determinant again, this time to be between 1.0 <= x < 10.0. */
X        Norm = NORM( cDeterminant );
X        if (Norm != 0.0)
X        {   while (Norm >= 10.0)
X            {   cDeterminant.Real *= 0.1;
X                cDeterminant.Imag *= 0.1;
X                (*pExponent)++;
X                Norm = NORM( cDeterminant );
X            }
X            while (Norm < 1.0)
X            {   cDeterminant.Real *= 10.0;
X                cDeterminant.Imag *= 10.0;
X                (*pExponent)--;
X                Norm = NORM( cDeterminant );
X            }
X        }
X        if (Matrix->NumberOfInterchangesIsOdd)
X            CMPLX_NEGATE( cDeterminant );
X        
X        *pDeterminant = cDeterminant.Real;
X        *piDeterminant = cDeterminant.Imag;
X    }
#endif /* spCOMPLEX */
#if REAL AND spCOMPLEX
X    else
#endif
#if REAL
X    {   /* Real Case. */
X        *pDeterminant = 1.0;
X
X        while (++I <= Size)
X        {   *pDeterminant /= Matrix->Diag[I]->Real;
X
/* Scale Determinant. */
X            if (*pDeterminant != 0.0)
X            {   while (ABS(*pDeterminant) >= 1.0e12)
X                {   *pDeterminant *= 1.0e-12;
X                    *pExponent += 12;
X                }
X                while (ABS(*pDeterminant) < 1.0e-12)
X                {   *pDeterminant *= 1.0e12;
X                    *pExponent -= 12;
X                }
X            }
X        }
X
/* Scale Determinant again, this time to be between 1.0 <= x < 10.0. */
X        if (*pDeterminant != 0.0)
X        {   while (ABS(*pDeterminant) >= 10.0)
X            {   *pDeterminant *= 0.1;
X                (*pExponent)++;
X            }
X            while (ABS(*pDeterminant) < 1.0)
X            {   *pDeterminant *= 10.0;
X                (*pExponent)--;
X            }
X        }
X        if (Matrix->NumberOfInterchangesIsOdd)
X            *pDeterminant = -*pDeterminant;
X    }
#endif /* REAL */
}
#endif /* DETERMINANT */
X
X
X
X
X
X
X
X
#if STRIP
X
/*!
X *  Strips the matrix of all fill-ins.
X *
X *  \param eMatrix
X *      Pointer to the matrix to be stripped.
X */
/*  >>> Local variables:
X *  pElement  (ElementPtr)
X *      Pointer that is used to step through the matrix.
X *  ppElement  (ElementPtr *)
X *      Pointer to the location of an ElementPtr.  This location will be
X *      updated if a fill-in is stripped from the matrix.
X *  pFillin  (ElementPtr)
X *      Pointer used to step through the lists of fill-ins while marking them.
X *  pLastFillin  (ElementPtr)
X *      A pointer to the last fill-in in the list.  Used to terminate a loop.
X *  pListNode  (struct  FillinListNodeStruct *)
X *      A pointer to a node in the FillinList linked-list.
X */
X
void
spStripFills( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
struct FillinListNodeStruct  *pListNode;
X
/* Begin `spStripFills'. */
X    ASSERT_IS_SPARSE( Matrix );
X    if (Matrix->Fillins == 0) return;
X    Matrix->NeedsOrdering = YES;
X    Matrix->Elements -= Matrix->Fillins;
X    Matrix->Fillins = 0;
X
/* Mark the fill-ins. */
X    {   register  ElementPtr  pFillin, pLastFillin;
X
X        pListNode = Matrix->LastFillinListNode = Matrix->FirstFillinListNode;
X        Matrix->FillinsRemaining = pListNode->NumberOfFillinsInList;
X        Matrix->NextAvailFillin = pListNode->pFillinList;
X
X        while (pListNode != NULL)
X        {   pFillin = pListNode->pFillinList;
X            pLastFillin = &(pFillin[ pListNode->NumberOfFillinsInList - 1 ]);
X            while (pFillin <= pLastFillin)
X                (pFillin++)->Row = 0;
X            pListNode = pListNode->Next;
X        }
X    }
X
/* Unlink fill-ins by searching for elements marked with Row = 0. */
X    {   register  ElementPtr pElement, *ppElement;
X        register  int  I, Size = Matrix->Size;
X
/* Unlink fill-ins in all columns. */
X        for (I = 1; I <= Size; I++)
X        {   ppElement = &(Matrix->FirstInCol[I]);
X            while ((pElement = *ppElement) != NULL)
X            {   if (pElement->Row == 0)
X                {   *ppElement = pElement->NextInCol;  /* Unlink fill-in. */
X                    if (Matrix->Diag[pElement->Col] == pElement)
X                        Matrix->Diag[pElement->Col] = NULL;
X                }
X                else
X                    ppElement = &pElement->NextInCol;  /* Skip element. */
X            }
X        }
X
/* Unlink fill-ins in all rows. */
X        for (I = 1; I <= Size; I++)
X        {   ppElement = &(Matrix->FirstInRow[I]);
X            while ((pElement = *ppElement) != NULL)
X            {   if (pElement->Row == 0)
X                    *ppElement = pElement->NextInRow;  /* Unlink fill-in. */
X                else
X                    ppElement = &pElement->NextInRow;  /* Skip element. */
X            }
X        }
X    }
X    return;
}
#endif
X
X
X
X
X
X
X
#if TRANSLATE AND DELETE
/*!
X *  Deletes a row and a column from a matrix.
X *
X *  Sparse will abort if an attempt is made to delete a row or column that
X *  doesn't exist.
X *
X *  \param eMatrix
X *      Pointer to the matrix in which the row and column are to be deleted.
X *  \param Row
X *      Row to be deleted.
X *  \param Col
X *      Column to be deleted.
X */
/*  >>> Local variables:
X *  ExtCol  (int)
X *      The external column that is being deleted.
X *  ExtRow  (int)
X *      The external row that is being deleted.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the matrix.  Used when scanning rows and
X *      columns in order to eliminate elements from the last row or column.
X *  ppElement  (ElementPtr *)
X *      Pointer to the location of an ElementPtr.  This location will be
X *      filled with a NULL pointer if it is the new last element in its row
X *      or column.
X *  pElement  (ElementPtr)
X *      Pointer to an element in the last row or column of the matrix.
X *  Size  (int)
X *      The local version Matrix->Size, the size of the matrix.
X */
X
void
spDeleteRowAndCol(
X    spMatrix eMatrix,
X    int  Row,
X    int  Col
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register  ElementPtr  pElement, *ppElement, pLastElement;
int  Size, ExtRow, ExtCol;
X
/* Begin `spDeleteRowAndCol'. */
X    ASSERT_IS_SPARSE( Matrix );
X    vASSERT( (Row > 0) AND (Col > 0), "Nonpositive row or column number" );
X    vASSERT( (Row <= Matrix->ExtSize) AND (Col <= Matrix->ExtSize),
X	     "Row or column number too large" );
X
X    Size = Matrix->Size;
X    ExtRow = Row;
X    ExtCol = Col;
X    if (NOT Matrix->RowsLinked) spcLinkRows( Matrix );
X
X    Row = Matrix->ExtToIntRowMap[Row];
X    Col = Matrix->ExtToIntColMap[Col];
X    ASSERT( Row > 0 AND Col > 0 );
X
/* Move Row so that it is the last row in the matrix. */
X    if (Row != Size) spcRowExchange( Matrix, Row, Size );
X
/* Move Col so that it is the last column in the matrix. */
X    if (Col != Size) spcColExchange( Matrix, Col, Size );
X
/* Correct Diag pointers. */
X    if (Row == Col)
X        SWAP( ElementPtr, Matrix->Diag[Row], Matrix->Diag[Size] )
X    else
X    {   Matrix->Diag[Row] = spcFindDiag( Matrix, Row );
X	Matrix->Diag[Col] = spcFindDiag( Matrix, Col );
X    }
X
/*
X * Delete last row and column of the matrix.
X */
/* Break the column links to every element in the last row. */
X    pLastElement = Matrix->FirstInRow[ Size ];
X    while (pLastElement != NULL)
X    {   ppElement = &(Matrix->FirstInCol[ pLastElement->Col ]);
X        while ((pElement = *ppElement) != NULL)
X        {   if (pElement == pLastElement)
X                *ppElement = NULL;  /* Unlink last element in column. */
X            else
X                ppElement = &pElement->NextInCol;  /* Skip element. */
X        }
X        pLastElement = pLastElement->NextInRow;
X    }
X
/* Break the row links to every element in the last column. */
X    pLastElement = Matrix->FirstInCol[ Size ];
X    while (pLastElement != NULL)
X    {   ppElement = &(Matrix->FirstInRow[ pLastElement->Row ]);
X        while ((pElement = *ppElement) != NULL)
X        {   if (pElement == pLastElement)
X                *ppElement = NULL;  /* Unlink last element in row. */
X            else
X                ppElement = &pElement->NextInRow;  /* Skip element. */
X        }
X        pLastElement = pLastElement->NextInCol;
X    }
X
/* Clean up some details. */
X    Matrix->Size = Size - 1;
X    Matrix->Diag[Size] = NULL;
X    Matrix->FirstInRow[Size] = NULL;
X    Matrix->FirstInCol[Size] = NULL;
X    Matrix->CurrentSize--;
X    Matrix->ExtToIntRowMap[ExtRow] = -1;
X    Matrix->ExtToIntColMap[ExtCol] = -1;
X    Matrix->NeedsOrdering = YES;
X
X    return;
}
#endif
X
X
X
X
X
X
X
X
#if PSEUDOCONDITION
/*!
X *  Computes the magnitude of the ratio of the largest to the smallest
X *  pivots.  This quantity is an indicator of ill-conditioning in the
X *  matrix.  If this ratio is large, and if the matrix is scaled such
X *  that uncertainties in the RHS and the matrix entries are
X *  equilibrated, then the matrix is ill-conditioned.  However, a small
X *  ratio does not necessarily imply that the matrix is
X *  well-conditioned.  This routine must only be used after a matrix has
X *  been factored by spOrderAndFactor() or spFactor() and before it is
X *  cleared by spClear() or spInitialize().  The pseudocondition is
X *  faster to compute than the condition number calculated by
X *  spCondition(), but is not as informative.
X *
X *  \return
X *  The magnitude of the ratio of the largest to smallest pivot used during
X *  previous factorization.  If the matrix was singular, zero is returned.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X */
X
spREAL
spPseudoCondition( spMatrix eMatrix )
{
X    MatrixPtr  Matrix = (MatrixPtr)eMatrix;
X    register int I;
X    register ArrayOfElementPtrs Diag;
X    RealNumber MaxPivot, MinPivot, Mag;
X
X    /* Begin `spPseudoCondition'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X    if (Matrix->Error == spSINGULAR OR Matrix->Error == spZERO_DIAG)
X	return 0.0;
X
X    Diag = Matrix->Diag;
X    MaxPivot = MinPivot = ELEMENT_MAG( Diag[1] );
X    for (I = 2; I <= Matrix->Size; I++)
X    {   Mag = ELEMENT_MAG( Diag[I] );
X	if (Mag > MaxPivot)
X	    MaxPivot = Mag;
X	else if (Mag < MinPivot)
X	    MinPivot = Mag;
X    }
X    ASSERT( MaxPivot > 0.0 );
X    return MaxPivot / MinPivot;
}
#endif
X
X
X
X
X
X
X
X
#if CONDITION
/*!
X *  Computes an estimate of the condition number using a variation on
X *  the LINPACK condition number estimation algorithm.  This quantity is
X *  an indicator of ill-conditioning in the matrix.  To avoid problems
X *  with overflow, the reciprocal of the condition number is returned.
X *  If this number is small, and if the matrix is scaled such that
X *  uncertainties in the RHS and the matrix entries are equilibrated,
X *  then the matrix is ill-conditioned.  If the this number is near
X *  one, the matrix is well conditioned.  This routine must only be
X *  used after a matrix has been factored by spOrderAndFactor() or
X *  spFactor() and before it is cleared by spClear() or spInitialize().
X *
X *  Unlike the LINPACK condition number estimator, this routines
X *  returns the L infinity condition number.  This is an artifact of
X *  Sparse placing ones on the diagonal of the upper triangular matrix
X *  rather than the lower.  This difference should be of no importance.
X *
X *  \b References:
X *
X *  A.K. Cline, C.B. Moler, G.W. Stewart, J.H. Wilkinson.  An estimate
X *  for the condition number of a matrix.  SIAM Journal on Numerical
X *  Analysis.  Vol. 16, No. 2, pages 368-375, April 1979.
X *  
X *  J.J. Dongarra, C.B. Moler, J.R. Bunch, G.W. Stewart.  LINPACK
X *  User's Guide.  SIAM, 1979.
X *  
X *  Roger G. Grimes, John G. Lewis.  Condition number estimation for
X *  sparse matrices.  SIAM Journal on Scientific and Statistical
X *  Computing.  Vol. 2, No. 4, pages 384-388, December 1981.
X *  
X *  Dianne Prost O'Leary.  Estimating matrix condition numbers.  SIAM
X *  Journal on Scientific and Statistical Computing.  Vol. 1, No. 2,
X *  pages 205-209, June 1980.
X *
X *  \return
X *  The reciprocal of the condition number.  If the matrix was singular,
X *  zero is returned.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X *  \param NormOfMatrix
X *      The L-infinity norm of the unfactored matrix as computed by
X *      spNorm().
X *  \param pError
X *      Used to return error code.  Possible errors include \a spSINGULAR
X *      or \a spNO_MEMORY.
X */
X
spREAL
spCondition( 
X    spMatrix eMatrix,
X    spREAL NormOfMatrix,
X    int *pError
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register ElementPtr pElement;
register RealVector T, Tm;
register int I, K, Row;
ElementPtr pPivot;
int Size;
RealNumber E, Em, Wp, Wm, ASp, ASm, ASw, ASy, ASv, ASz, MaxY, ScaleFactor;
RealNumber Linpack, OLeary, InvNormOfInverse, ComplexCondition();
#define SLACK   1e4
X
/* Begin `spCondition'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X    *pError = Matrix->Error;
X    if (Matrix->Error >= spFATAL) return 0.0;
X    if (NormOfMatrix == 0.0)
X    {   *pError = spSINGULAR;
X        return 0.0;
X    }
X
#if spCOMPLEX
X    if (Matrix->Complex)
X        return ComplexCondition( Matrix, NormOfMatrix, pError );
#endif
X
#if REAL
X    Size = Matrix->Size;
X    T = Matrix->Intermediate;
#if spCOMPLEX
X    Tm = Matrix->Intermediate + Size;
#else
X    Tm = ALLOC( RealNumber, Size+1 );
X    if (Tm == NULL)
X    {   *pError = spNO_MEMORY;
X        return 0.0;
X    }
#endif
X    for (I = Size; I > 0; I--) T[I] = 0.0;
X
/*
X * Part 1.  Ay = e.
X * Solve Ay = LUy = e where e consists of +1 and -1 terms with the sign
X * chosen to maximize the size of w in Lw = e.  Since the terms in w can
X * get very large, scaling is used to avoid overflow.
X */
X
/* Forward elimination. Solves Lw = e while choosing e. */
X    E = 1.0;
X    for (I = 1; I <= Size; I++)
X    {   pPivot = Matrix->Diag[I];
X        if (T[I] < 0.0) Em = -E; else Em = E;
X        Wm = (Em + T[I]) * pPivot->Real;
X        if (ABS(Wm) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), ABS(Wm) );
X            for (K = Size; K > 0; K--) T[K] *= ScaleFactor;
X            E *= ScaleFactor;
X            Em *= ScaleFactor;
X            Wm = (Em + T[I]) * pPivot->Real;
X        }
X        Wp = (T[I] - Em) * pPivot->Real;
X        ASp = ABS(T[I] - Em);
X        ASm = ABS(Em + T[I]);
X
/* Update T for both values of W, minus value is placed in Tm. */
X        pElement = pPivot->NextInCol;
X        while (pElement != NULL)
X        {   Row = pElement->Row;
X            Tm[Row] = T[Row] - (Wm * pElement->Real);
X            T[Row] -= (Wp * pElement->Real);
X            ASp += ABS(T[Row]);
X            ASm += ABS(Tm[Row]);
X            pElement = pElement->NextInCol;
X        }
X
/* If minus value causes more growth, overwrite T with its values. */
X        if (ASm > ASp)
X        {   T[I] = Wm;
X            pElement = pPivot->NextInCol;
X            while (pElement != NULL)
X            {   T[pElement->Row] = Tm[pElement->Row];
X                pElement = pElement->NextInCol;
X            }
X        }
X        else T[I] = Wp;
X    }
X
/* Compute 1-norm of T, which now contains w, and scale ||T|| to 1/SLACK. */
X    for (ASw = 0.0, I = Size; I > 0; I--) ASw += ABS(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASw);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) T[I] *= ScaleFactor;
X        E *= ScaleFactor;
X    }
X
/* Backward Substitution. Solves Uy = w.*/
X    for (I = Size; I >= 1; I--)
X    {   pElement = Matrix->Diag[I]->NextInRow;
X        while (pElement != NULL)
X        {   T[I] -= pElement->Real * T[pElement->Col];
X            pElement = pElement->NextInRow;
X        }
X        if (ABS(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), ABS(T[I]) );
X            for (K = Size; K > 0; K--) T[K] *= ScaleFactor;
X            E *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains y, and scale ||T|| to 1/SLACK. */
X    for (ASy = 0.0, I = Size; I > 0; I--) ASy += ABS(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASy);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) T[I] *= ScaleFactor;
X        ASy = 1.0 / SLACK;
X        E *= ScaleFactor;
X    }
X
/* Compute infinity-norm of T for O'Leary's estimate. */
X    for (MaxY = 0.0, I = Size; I > 0; I--)
X        if (MaxY < ABS(T[I])) MaxY = ABS(T[I]);
X
/*
X * Part 2.  A* z = y where the * represents the transpose.
X * Recall that A = LU implies A* = U* L*.
X */
X
/* Forward elimination, U* v = y. */
X    for (I = 1; I <= Size; I++)
X    {   pElement = Matrix->Diag[I]->NextInRow;
X        while (pElement != NULL)
X        {   T[pElement->Col] -= T[I] * pElement->Real;
X            pElement = pElement->NextInRow;
X        }
X        if (ABS(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), ABS(T[I]) );
X            for (K = Size; K > 0; K--) T[K] *= ScaleFactor;
X            ASy *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains v, and scale ||T|| to 1/SLACK. */
X    for (ASv = 0.0, I = Size; I > 0; I--) ASv += ABS(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASv);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) T[I] *= ScaleFactor;
X        ASy *= ScaleFactor;
X    }
X
/* Backward Substitution, L* z = v. */
X    for (I = Size; I >= 1; I--)
X    {   pPivot = Matrix->Diag[I];
X        pElement = pPivot->NextInCol;
X        while (pElement != NULL)
X        {   T[I] -= pElement->Real * T[pElement->Row];
X            pElement = pElement->NextInCol;
X        }
X        T[I] *= pPivot->Real;
X        if (ABS(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), ABS(T[I]) );
X            for (K = Size; K > 0; K--) T[K] *= ScaleFactor;
X            ASy *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains z. */
X    for (ASz = 0.0, I = Size; I > 0; I--) ASz += ABS(T[I]);
X
#if NOT spCOMPLEX
X    FREE( Tm );
#endif
X
X    Linpack = ASy / ASz;
X    OLeary = E / MaxY;
X    InvNormOfInverse = MIN( Linpack, OLeary );
X    return InvNormOfInverse / NormOfMatrix;
#endif /* REAL */
}
X
X
X
X
X
#if spCOMPLEX
/*
X *  ESTIMATE CONDITION NUMBER
X *
X *  Complex version of spCondition().
X *
X *  >>> Returns:
X *  The reciprocal of the condition number.
X *
X *  >>> Arguments:
X *  Matrix  <input>  (MatrixPtr)
X *      Pointer to the matrix.
X *  NormOfMatrix  <input>  (RealNumber)
X *      The L-infinity norm of the unfactored matrix as computed by
X *      spNorm().
X *  pError  <output>  (int *)
X *      Used to return error code.
X *
X *  >>> Possible errors:
X *  spNO_MEMORY
X */
X
static RealNumber
ComplexCondition(
X    MatrixPtr Matrix,
X    RealNumber NormOfMatrix,
X    int *pError
)
{
register ElementPtr pElement;
register ComplexVector T, Tm;
register int I, K, Row;
ElementPtr pPivot;
int Size;
RealNumber E, Em, ASp, ASm, ASw, ASy, ASv, ASz, MaxY, ScaleFactor;
RealNumber Linpack, OLeary, InvNormOfInverse;
ComplexNumber Wp, Wm;
X
/* Begin `ComplexCondition'. */
X
X    Size = Matrix->Size;
X    T = (ComplexVector)Matrix->Intermediate;
X    Tm = ALLOC( ComplexNumber, Size+1 );
X    if (Tm == NULL)
X    {   *pError = spNO_MEMORY;
X        return 0.0;
X    }
X    for (I = Size; I > 0; I--) T[I].Real = T[I].Imag = 0.0;
X
/*
X * Part 1.  Ay = e.
X * Solve Ay = LUy = e where e consists of +1 and -1 terms with the sign
X * chosen to maximize the size of w in Lw = e.  Since the terms in w can
X * get very large, scaling is used to avoid overflow.
X */
X
/* Forward elimination. Solves Lw = e while choosing e. */
X    E = 1.0;
X    for (I = 1; I <= Size; I++)
X    {   pPivot = Matrix->Diag[I];
X        if (T[I].Real < 0.0) Em = -E; else Em = E;
X        Wm = T[I];
X        Wm.Real += Em;
X        ASm = CMPLX_1_NORM( Wm );
X        CMPLX_MULT_ASSIGN( Wm, *pPivot );
X        if (CMPLX_1_NORM(Wm) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), CMPLX_1_NORM(Wm) );
X            for (K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
X            E *= ScaleFactor;
X            Em *= ScaleFactor;
X            ASm *= ScaleFactor;
X            SCLR_MULT_ASSIGN( Wm, ScaleFactor );
X        }
X        Wp = T[I];
X        Wp.Real -= Em;
X        ASp = CMPLX_1_NORM( Wp );
X        CMPLX_MULT_ASSIGN( Wp, *pPivot );
X
/* Update T for both values of W, minus value is placed in Tm. */
X        pElement = pPivot->NextInCol;
X        while (pElement != NULL)
X        {   Row = pElement->Row;
X            /* Cmplx expr: Tm[Row] = T[Row] - (Wp * *pElement). */
X            CMPLX_MULT_SUBT( Tm[Row], Wm, *pElement, T[Row] );
X            /* Cmplx expr: T[Row] -= Wp * *pElement. */
X            CMPLX_MULT_SUBT_ASSIGN( T[Row], Wm, *pElement );
X            ASp += CMPLX_1_NORM(T[Row]);
X            ASm += CMPLX_1_NORM(Tm[Row]);
X            pElement = pElement->NextInCol;
X        }
X
/* If minus value causes more growth, overwrite T with its values. */
X        if (ASm > ASp)
X        {   T[I] = Wm;
X            pElement = pPivot->NextInCol;
X            while (pElement != NULL)
X            {   T[pElement->Row] = Tm[pElement->Row];
X                pElement = pElement->NextInCol;
X            }
X        }
X        else T[I] = Wp;
X    }
X
/* Compute 1-norm of T, which now contains w, and scale ||T|| to 1/SLACK. */
X    for (ASw = 0.0, I = Size; I > 0; I--) ASw += CMPLX_1_NORM(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASw);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );
X        E *= ScaleFactor;
X    }
X
/* Backward Substitution. Solves Uy = w.*/
X    for (I = Size; I >= 1; I--)
X    {   pElement = Matrix->Diag[I]->NextInRow;
X        while (pElement != NULL)
X        {   /* Cmplx expr: T[I] -= T[pElement->Col] * *pElement. */
X            CMPLX_MULT_SUBT_ASSIGN( T[I], T[pElement->Col], *pElement );
X            pElement = pElement->NextInRow;
X        }
X        if (CMPLX_1_NORM(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
X            for (K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
X            E *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains y, and scale ||T|| to 1/SLACK. */
X    for (ASy = 0.0, I = Size; I > 0; I--) ASy += CMPLX_1_NORM(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASy);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );
X        ASy = 1.0 / SLACK;
X        E *= ScaleFactor;
X    }
X
/* Compute infinity-norm of T for O'Leary's estimate. */
X    for (MaxY = 0.0, I = Size; I > 0; I--)
X        if (MaxY < CMPLX_1_NORM(T[I])) MaxY = CMPLX_1_NORM(T[I]);
X
/*
X * Part 2.  A* z = y where the * represents the transpose.
X * Recall that A = LU implies A* = U* L*.
X */
X
/* Forward elimination, U* v = y. */
X    for (I = 1; I <= Size; I++)
X    {   pElement = Matrix->Diag[I]->NextInRow;
X        while (pElement != NULL)
X        {   /* Cmplx expr: T[pElement->Col] -= T[I] * *pElement. */
X            CMPLX_MULT_SUBT_ASSIGN( T[pElement->Col], T[I], *pElement );
X            pElement = pElement->NextInRow;
X        }
X        if (CMPLX_1_NORM(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
X            for (K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
X            ASy *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains v, and scale ||T|| to 1/SLACK. */
X    for (ASv = 0.0, I = Size; I > 0; I--) ASv += CMPLX_1_NORM(T[I]);
X    ScaleFactor = 1.0 / (SLACK * ASv);
X    if (ScaleFactor < 0.5)
X    {   for (I = Size; I > 0; I--) SCLR_MULT_ASSIGN( T[I], ScaleFactor );
X        ASy *= ScaleFactor;
X    }
X
/* Backward Substitution, L* z = v. */
X    for (I = Size; I >= 1; I--)
X    {   pPivot = Matrix->Diag[I];
X        pElement = pPivot->NextInCol;
X        while (pElement != NULL)
X        {   /* Cmplx expr: T[I] -= T[pElement->Row] * *pElement. */
X            CMPLX_MULT_SUBT_ASSIGN( T[I], T[pElement->Row], *pElement );
X            pElement = pElement->NextInCol;
X        }
X        CMPLX_MULT_ASSIGN( T[I], *pPivot );
X        if (CMPLX_1_NORM(T[I]) > SLACK)
X        {   ScaleFactor = 1.0 / MAX( SQR( SLACK ), CMPLX_1_NORM(T[I]) );
X            for (K = Size; K > 0; K--) SCLR_MULT_ASSIGN( T[K], ScaleFactor );
X            ASy *= ScaleFactor;
X        }
X    }
X
/* Compute 1-norm of T, which now contains z. */
X    for (ASz = 0.0, I = Size; I > 0; I--) ASz += CMPLX_1_NORM(T[I]);
X
X    FREE( Tm );
X
X    Linpack = ASy / ASz;
X    OLeary = E / MaxY;
X    InvNormOfInverse = MIN( Linpack, OLeary );
X    return InvNormOfInverse / NormOfMatrix;
}
#endif /* spCOMPLEX */
X
X
X
X
X
/*!
X *  Computes the L-infinity norm of an unfactored matrix.  It is a fatal
X *  error to pass this routine a factored matrix.
X *
X *  \return
X *  The largest absolute row sum of matrix.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X */
X
spREAL
spNorm( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register ElementPtr pElement;
register int I;
RealNumber Max = 0.0, AbsRowSum;
X
/* Begin `spNorm'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_NOT_FACTORED( Matrix );
X    if (NOT Matrix->RowsLinked) spcLinkRows( Matrix );
X
/* Compute row sums. */
#if REAL
X    if (NOT Matrix->Complex)
X    {   for (I = Matrix->Size; I > 0; I--)
X        {   pElement = Matrix->FirstInRow[I];
X            AbsRowSum = 0.0;
X            while (pElement != NULL)
X            {   AbsRowSum += ABS( pElement->Real );
X                pElement = pElement->NextInRow;
X            }
X            if (Max < AbsRowSum) Max = AbsRowSum;
X        }
X    }
#endif
#if spCOMPLEX
X    if (Matrix->Complex)
X    {   for (I = Matrix->Size; I > 0; I--)
X        {   pElement = Matrix->FirstInRow[I];
X            AbsRowSum = 0.0;
X            while (pElement != NULL)
X            {   AbsRowSum += CMPLX_1_NORM( *pElement );
X                pElement = pElement->NextInRow;
X            }
X            if (Max < AbsRowSum) Max = AbsRowSum;
X        }
X    }
#endif
X    return Max;
}
#endif /* CONDITION */
X
X
X
X
X
X
#if STABILITY
/*!
X *  This routine, along with spRoundoff(), are used to gauge the stability of a
X *  factorization.  If the factorization is determined to be too unstable,
X *  then the matrix should be reordered.  The routines compute quantities
X *  that are needed in the computation of a bound on the error attributed
X *  to any one element in the matrix during the factorization.  In other
X *  words, there is a matrix \f$ E = [e_{ij}] \f$ of error terms such that
X *  \f$ A+E = LU \f$.  This routine finds a bound on \f$ |e_{ij}| \f$.
X *  Erisman & Reid [1] showed that \f$ |e_{ij}| < 3.01 u \rho m_{ij} \f$,
X *  where \f$ u \f$ is the machine rounding unit,
X *  \f$ \rho = \max a_{ij} \f$ where the max is taken over every row \f$ i \f$,
X *  column \f$ j \f$, and step \f$ k \f$, and \f$ m_{ij} \f$ is the number
X *  of multiplications required in the computation of \f$ l_{ij} \f$ if
X *  \f$ i > j \f$ or \f$ u_{ij} \f$ otherwise.  Barlow [2] showed that
X *  \f$ \rho < \max_i || l_i ||_p \max_j || u_j ||_q \f$ where
X *  \f$ 1/p + 1/q = 1 \f$.
X *
X *  spLargestElement() finds the magnitude on the largest element in the
X *  matrix.  If the matrix has not yet been factored, the largest
X *  element is found by direct search.  If the matrix is factored, a
X *  bound on the largest element in any of the reduced submatrices is
X *  computed using Barlow with \f$ p = \infty \f$ and \f$ q = 1 \f$.
X *  The ratio of these
X *  two numbers is the growth, which can be used to determine if the
X *  pivoting order is adequate.  A large growth implies that
X *  considerable error has been made in the factorization and that it
X *  is probably a good idea to reorder the matrix.  If a large growth
X *  in encountered after using spFactor(), reconstruct the matrix and
X *  refactor using spOrderAndFactor().  If a large growth is
X *  encountered after using spOrderAndFactor(), refactor using
X *  spOrderAndFactor() with the pivot threshold increased, say to 0.1.
X *
X *  Using only the size of the matrix as an upper bound on \f$ m_{ij} \f$ and
X *  Barlow's bound, the user can estimate the size of the matrix error
X *  terms \f$ e_{ij} \f$ using the bound of Erisman and Reid.  spRoundoff() 
X *  computes a tighter bound (with more work) based on work by Gear
X *  [3], \f$ |e_{ij}| < 1.01 u \rho (t c^3 + (1 + t)c^2) \f$ where
X *  \f$ t \f$ is the threshold and \f$ c \f$ is the maximum number of
X *  off-diagonal elements in any row of \f$ L \f$.  The expensive part
X *  of computing this bound is determining the maximum number of
X *  off-diagonals in \f$ L \f$, which changes
X *  only when the order of the matrix changes.  This number is computed
X *  and saved, and only recomputed if the matrix is reordered.
X *
X *  [1] A. M. Erisman, J. K. Reid.  Monitoring the stability of the
X *      triangular factorization of a sparse matrix.  Numerische
X *      Mathematik.  Vol. 22, No. 3, 1974, pp 183-186.
X *
X *  [2] J. L. Barlow.  A note on monitoring the stability of triangular
X *      decomposition of sparse matrices.  "SIAM Journal of Scientific
X *      and Statistical Computing."  Vol. 7, No. 1, January 1986, pp 166-168.
X *
X *  [3] I. S. Duff, A. M. Erisman, J. K. Reid.  "Direct Methods for Sparse
X *      Matrices."  Oxford 1986. pp 99.
X *
X *  \return
X *  If matrix is not factored, returns the magnitude of the largest element in
X *  the matrix.  If the matrix is factored, a bound on the magnitude of the
X *  largest element in any of the reduced submatrices is returned.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X */
X
spREAL
spLargestElement( spMatrix eMatrix )
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register int I;
RealNumber Mag, AbsColSum, Max = 0.0, MaxRow = 0.0, MaxCol = 0.0;
RealNumber Pivot;
ComplexNumber cPivot;
register ElementPtr pElement, pDiag;
X
/* Begin `spLargestElement'. */
X    ASSERT_IS_SPARSE( Matrix );
X
#if REAL
X    if (Matrix->Factored AND NOT Matrix->Complex)
X    {   if (Matrix->Error == spSINGULAR) return 0.0;
X
/* Find the bound on the size of the largest element over all factorization. */
X        for (I = 1; I <= Matrix->Size; I++)
X        {   pDiag = Matrix->Diag[I];
X
/* Lower triangular matrix. */
X            Pivot = 1.0 / pDiag->Real;
X            Mag = ABS( Pivot );
X            if (Mag > MaxRow) MaxRow = Mag;
X            pElement = Matrix->FirstInRow[I];
X            while (pElement != pDiag)
X            {   Mag = ABS( pElement->Real );
X                if (Mag > MaxRow) MaxRow = Mag;
X                pElement = pElement->NextInRow;
X            }
X
/* Upper triangular matrix. */
X            pElement = Matrix->FirstInCol[I];
X            AbsColSum = 1.0;  /* Diagonal of U is unity. */
X            while (pElement != pDiag)
X            {   AbsColSum += ABS( pElement->Real );
X                pElement = pElement->NextInCol;
X            }
X            if (AbsColSum > MaxCol) MaxCol = AbsColSum;
X        }
X    }
X    else if (NOT Matrix->Complex)
X    {   for (I = 1; I <= Matrix->Size; I++)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   Mag = ABS( pElement->Real );
X                if (Mag > Max) Max = Mag;
X                pElement = pElement->NextInCol;
X            }
X        }
X        return Max;
X    }
#endif
#if spCOMPLEX
X    if (Matrix->Factored AND Matrix->Complex)
X    {   if (Matrix->Error == spSINGULAR) return 0.0;
X
/* Find the bound on the size of the largest element over all factorization. */
X        for (I = 1; I <= Matrix->Size; I++)
X        {   pDiag = Matrix->Diag[I];
X
/* Lower triangular matrix. */
X            CMPLX_RECIPROCAL( cPivot, *pDiag );
X            Mag = CMPLX_INF_NORM( cPivot );
X            if (Mag > MaxRow) MaxRow = Mag;
X            pElement = Matrix->FirstInRow[I];
X            while (pElement != pDiag)
X            {   Mag = CMPLX_INF_NORM( *pElement );
X                if (Mag > MaxRow) MaxRow = Mag;
X                pElement = pElement->NextInRow;
X            }
X
/* Upper triangular matrix. */
X            pElement = Matrix->FirstInCol[I];
X            AbsColSum = 1.0;  /* Diagonal of U is unity. */
X            while (pElement != pDiag)
X            {   AbsColSum += CMPLX_INF_NORM( *pElement );
X                pElement = pElement->NextInCol;
X            }
X            if (AbsColSum > MaxCol) MaxCol = AbsColSum;
X        }
X    }
X    else if (Matrix->Complex)
X    {   for (I = 1; I <= Matrix->Size; I++)
X        {   pElement = Matrix->FirstInCol[I];
X            while (pElement != NULL)
X            {   Mag = CMPLX_INF_NORM( *pElement );
X                if (Mag > Max) Max = Mag;
X                pElement = pElement->NextInCol;
X            }
X        }
X        return Max;
X    }
#endif
X    return MaxRow * MaxCol;
}
X
X
X
X
/*!
X *  This routine, along with spLargestElement(), are used to gauge the
X *  stability of a factorization. See description of spLargestElement()
X *  for more information.
X *
X *  \return
X *  Returns a bound on the magnitude of the largest element in
X *  \f$ E = A - LU \f$.
X *
X *  \param eMatrix
X *      Pointer to the matrix.
X *  \param Rho
X *      The bound on the magnitude of the largest element in any of the
X *      reduced submatrices.  This is the number computed by the function
X *      spLargestElement() when given a factored matrix.  If this number is
X *      negative, the bound will be computed automatically.
X */
X
spREAL
spRoundoff( 
X    spMatrix eMatrix,
X    spREAL Rho
)
{
MatrixPtr  Matrix = (MatrixPtr)eMatrix;
register ElementPtr pElement;
register int Count, I, MaxCount = 0;
RealNumber Reid, Gear;
X
/* Begin `spRoundoff'. */
X    ASSERT_IS_SPARSE( Matrix );
X    ASSERT_NO_ERRORS( Matrix );
X    ASSERT_IS_FACTORED( Matrix );
X
/* Compute Barlow's bound if it is not given. */
X    if (Rho < 0.0) Rho = spLargestElement( eMatrix );
X
/* Find the maximum number of off-diagonals in L if not previously computed. */
X    if (Matrix->MaxRowCountInLowerTri < 0)
X    {   for (I = Matrix->Size; I > 0; I--)
X        {   pElement = Matrix->FirstInRow[I];
X            Count = 0;
X            while (pElement->Col < I)
X            {   Count++;
X                pElement = pElement->NextInRow;
X            }
X            if (Count > MaxCount) MaxCount = Count;
X        }
X        Matrix->MaxRowCountInLowerTri = MaxCount;
X    }
X    else MaxCount = Matrix->MaxRowCountInLowerTri;
X
/* Compute error bound. */
X    Gear = 1.01*((MaxCount + 1) * Matrix->RelThreshold + 1.0) * SQR(MaxCount);
X    Reid = 3.01 * Matrix->Size;
X
X    if (Gear < Reid)
X        return (MACHINE_RESOLUTION * Rho * Gear);
X    else
X        return (MACHINE_RESOLUTION * Rho * Reid);
}
#endif
X
X
X
X
X
X
X
#if DOCUMENTATION
/*!
X *  This routine prints a short message describing the error error state
X *  of sparse.  No message is produced if there is no error.
X *  The error state is cleared.
X *
X *  \param eMatrix
X *	Matrix for which the error message is to be printed.
X *  \param Stream
X *	Stream to which the error message is to be printed.
X *  \param Originator
X *	Name of originator of error message.  If NULL, `sparse' is used.
X *	If zero-length string, no originator is printed.
X */
X
void
spErrorMessage(
X    spMatrix eMatrix,
X    FILE *Stream,
X    char *Originator
)
{
int Row, Col, Error;
X
/* Begin `spErrorMessage'. */
X    if (eMatrix == NULL)
X	Error = spNO_MEMORY;
X    else
X    {   ASSERT_IS_SPARSE( (MatrixPtr)eMatrix );
X	Error = ((MatrixPtr)eMatrix)->Error;
X    }
X
X    if (Error == spOKAY) return;
X    if (Originator == NULL) Originator = "sparse";
X    if (Stream == NULL) Stream = stderr;
X    if (Originator[0] != '\0') fprintf( Stream, "%s: ", Originator );
X    if (Error >= spFATAL)
X	fprintf( Stream, "fatal error: ");
X    else
X	fprintf( Stream, "warning: ");
/*
X * Print particular error message.
X * Do not use switch statement because error codes may not be unique.
X */
X    if (Error == spPANIC)
X	fprintf( Stream, "Sparse called improperly.\n");
X    else if (Error == spNO_MEMORY)
X	fprintf( Stream, "insufficient memory available.\n");
X    else if (Error == spMANGLED)
X	fprintf( Stream, "matrix is mangled.\n");
X    else if (Error == spSINGULAR)
X    {   spWhereSingular( eMatrix, &Row, &Col );
X	fprintf( Stream, "singular matrix detected at row %d and column %d.\n",
X		 Row, Col);
X    }
X    else if (Error == spZERO_DIAG)
X    {   spWhereSingular( eMatrix, &Row, &Col );
X	fprintf( Stream, "zero diagonal detected at row %d and column %d.\n",
X		 Row, Col);
X    }
X    else if (Error == spSMALL_PIVOT)
X    {   fprintf( Stream,
X	    "unable to find a pivot that is larger than absolute threshold.\n");
X    }
X    else ABORT();
X
X    ((MatrixPtr)eMatrix)->Error = spOKAY;
X    return;
}
#endif /* DOCUMENTATION */
SHAR_EOF
  (set 20 03 06 30 16 12 39 'sparse/spUtils.c'; eval "$shar_touch") &&
  chmod 0600 'sparse/spUtils.c'
if test $? -ne 0
then ${echo} 'restore of sparse/spUtils.c failed'
fi
  if ${md5check}
  then (
       ${MD5SUM} -c >/dev/null 2>&1 || ${echo} 'sparse/spUtils.c: MD5 check failed'
       ) << \SHAR_EOF
dd8d95f756acb3b1ebc24b765b120d3c  sparse/spUtils.c
SHAR_EOF
  else
test `LC_ALL=C wc -c < 'sparse/spUtils.c'` -ne 68909 && \
  ${echo} 'restoration warning:  size of sparse/spUtils.c is not 68909'
  fi
fi
if rm -fr ${lock_dir}
then ${echo} 'x - removed lock directory `'${lock_dir}\''.'
else ${echo} 'x - failed to remove lock directory `'${lock_dir}\''.'
  exit 1
fi
exit 0

